<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>My New Hugo Site</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="对 std::lock 的规避死锁的方法感兴趣，分析一下相关代码
在 mutex 里找到 lock 的定义
template &lt;class _Lock0, class _Lock1, class... _LockN&gt;
void lock(_Lock0&amp; _Lk0, _Lock1&amp; _Lk1, _LockN&amp;... _LkN) { // lock multiple locks, without deadlock
    _Lock_nonmember1(_Lk0, _Lk1, _LkN...);
}
_Lock_nonmember1 有两个重载

template &lt;class _Lock0, class _Lock1&gt;
void _Lock_nonmember1(_Lock0&amp; _Lk0, _Lock1&amp; _Lk1) {
    // lock 2 locks, without deadlock, special case for better codegen and reduced metaprogramming for common case
    while (_Lock_attempt_small(_Lk0, _Lk1) &amp;&amp; _Lock_attempt_small(_Lk1, _Lk0)) { // keep trying
    }
}

template &lt;class _Lock0, class _Lock1, class _Lock2, class... _LockN&gt;
void _Lock_nonmember1(_Lock0&amp; _Lk0, _Lock1&amp; _Lk1, _Lock2&amp; _Lk2, _LockN&amp;... _LkN) {
    // lock 3 or more locks, without deadlock
    int _Hard_lock = 0;
    while (_Hard_lock != -1) {
        _Hard_lock = _Lock_attempt(_Hard_lock, _Lk0, _Lk1, _Lk2, _LkN...);
    }
}
先看简单的情况，如果只有两个 mutex 会不断尝试以两种顺序加锁，如直到两个锁都获取到。">
    <meta name="generator" content="Hugo 0.139.2">
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    

    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/posts/2023-03-12-msvc-stl-std-lock/">
    

    <meta property="og:url" content="http://localhost:1313/posts/2023-03-12-msvc-stl-std-lock/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="My New Hugo Site">
  <meta property="og:description" content="对 std::lock 的规避死锁的方法感兴趣，分析一下相关代码
在 mutex 里找到 lock 的定义
template &lt;class _Lock0, class _Lock1, class... _LockN&gt; void lock(_Lock0&amp; _Lk0, _Lock1&amp; _Lk1, _LockN&amp;... _LkN) { // lock multiple locks, without deadlock _Lock_nonmember1(_Lk0, _Lk1, _LkN...); } _Lock_nonmember1 有两个重载
template &lt;class _Lock0, class _Lock1&gt; void _Lock_nonmember1(_Lock0&amp; _Lk0, _Lock1&amp; _Lk1) { // lock 2 locks, without deadlock, special case for better codegen and reduced metaprogramming for common case while (_Lock_attempt_small(_Lk0, _Lk1) &amp;&amp; _Lock_attempt_small(_Lk1, _Lk0)) { // keep trying } } template &lt;class _Lock0, class _Lock1, class _Lock2, class... _LockN&gt; void _Lock_nonmember1(_Lock0&amp; _Lk0, _Lock1&amp; _Lk1, _Lock2&amp; _Lk2, _LockN&amp;... _LkN) { // lock 3 or more locks, without deadlock int _Hard_lock = 0; while (_Hard_lock != -1) { _Hard_lock = _Lock_attempt(_Hard_lock, _Lk0, _Lk1, _Lk2, _LkN...); } } 先看简单的情况，如果只有两个 mutex 会不断尝试以两种顺序加锁，如直到两个锁都获取到。">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">

  <meta itemprop="name" content="My New Hugo Site">
  <meta itemprop="description" content="对 std::lock 的规避死锁的方法感兴趣，分析一下相关代码
在 mutex 里找到 lock 的定义
template &lt;class _Lock0, class _Lock1, class... _LockN&gt; void lock(_Lock0&amp; _Lk0, _Lock1&amp; _Lk1, _LockN&amp;... _LkN) { // lock multiple locks, without deadlock _Lock_nonmember1(_Lk0, _Lk1, _LkN...); } _Lock_nonmember1 有两个重载
template &lt;class _Lock0, class _Lock1&gt; void _Lock_nonmember1(_Lock0&amp; _Lk0, _Lock1&amp; _Lk1) { // lock 2 locks, without deadlock, special case for better codegen and reduced metaprogramming for common case while (_Lock_attempt_small(_Lk0, _Lk1) &amp;&amp; _Lock_attempt_small(_Lk1, _Lk0)) { // keep trying } } template &lt;class _Lock0, class _Lock1, class _Lock2, class... _LockN&gt; void _Lock_nonmember1(_Lock0&amp; _Lk0, _Lock1&amp; _Lk1, _Lock2&amp; _Lk2, _LockN&amp;... _LkN) { // lock 3 or more locks, without deadlock int _Hard_lock = 0; while (_Hard_lock != -1) { _Hard_lock = _Lock_attempt(_Hard_lock, _Lk0, _Lk1, _Lk2, _LkN...); } } 先看简单的情况，如果只有两个 mutex 会不断尝试以两种顺序加锁，如直到两个锁都获取到。">
  <meta itemprop="wordCount" content="701">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="My New Hugo Site">
  <meta name="twitter:description" content="对 std::lock 的规避死锁的方法感兴趣，分析一下相关代码
在 mutex 里找到 lock 的定义
template &lt;class _Lock0, class _Lock1, class... _LockN&gt; void lock(_Lock0&amp; _Lk0, _Lock1&amp; _Lk1, _LockN&amp;... _LkN) { // lock multiple locks, without deadlock _Lock_nonmember1(_Lk0, _Lk1, _LkN...); } _Lock_nonmember1 有两个重载
template &lt;class _Lock0, class _Lock1&gt; void _Lock_nonmember1(_Lock0&amp; _Lk0, _Lock1&amp; _Lk1) { // lock 2 locks, without deadlock, special case for better codegen and reduced metaprogramming for common case while (_Lock_attempt_small(_Lk0, _Lk1) &amp;&amp; _Lock_attempt_small(_Lk1, _Lk0)) { // keep trying } } template &lt;class _Lock0, class _Lock1, class _Lock2, class... _LockN&gt; void _Lock_nonmember1(_Lock0&amp; _Lk0, _Lock1&amp; _Lk1, _Lock2&amp; _Lk2, _LockN&amp;... _LkN) { // lock 3 or more locks, without deadlock int _Hard_lock = 0; while (_Hard_lock != -1) { _Hard_lock = _Lock_attempt(_Hard_lock, _Lk0, _Lk1, _Lk2, _LkN...); } } 先看简单的情况，如果只有两个 mutex 会不断尝试以两种顺序加锁，如直到两个锁都获取到。">

	
  </head><body class="ma0 avenir bg-near-white development">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        My New Hugo Site
      
    </a>
    <div class="flex-l items-center">
      

      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1"></h1>
      
      
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>对 std::lock 的规避死锁的方法感兴趣，分析一下相关代码</p>
<p>在 mutex 里找到 lock 的定义</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CPP" data-lang="CPP"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_Lock0</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_Lock1</span>, <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010">... </span><span style="color:#a6e22e">_LockN</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> lock(_Lock0<span style="color:#f92672">&amp;</span> _Lk0, _Lock1<span style="color:#f92672">&amp;</span> _Lk1, _LockN<span style="color:#f92672">&amp;</span>... _LkN) { <span style="color:#75715e">// lock multiple locks, without deadlock
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    _Lock_nonmember1(_Lk0, _Lk1, _LkN...);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>_Lock_nonmember1 有两个重载</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CPP" data-lang="CPP"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_Lock0</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_Lock1</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> _Lock_nonmember1(_Lock0<span style="color:#f92672">&amp;</span> _Lk0, _Lock1<span style="color:#f92672">&amp;</span> _Lk1) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// lock 2 locks, without deadlock, special case for better codegen and reduced metaprogramming for common case
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (_Lock_attempt_small(_Lk0, _Lk1) <span style="color:#f92672">&amp;&amp;</span> _Lock_attempt_small(_Lk1, _Lk0)) { <span style="color:#75715e">// keep trying
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_Lock0</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_Lock1</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_Lock2</span>, <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010">... </span><span style="color:#a6e22e">_LockN</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> _Lock_nonmember1(_Lock0<span style="color:#f92672">&amp;</span> _Lk0, _Lock1<span style="color:#f92672">&amp;</span> _Lk1, _Lock2<span style="color:#f92672">&amp;</span> _Lk2, _LockN<span style="color:#f92672">&amp;</span>... _LkN) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// lock 3 or more locks, without deadlock
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> _Hard_lock <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (_Hard_lock <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        _Hard_lock <span style="color:#f92672">=</span> _Lock_attempt(_Hard_lock, _Lk0, _Lk1, _Lk2, _LkN...);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>先看简单的情况，如果只有两个 mutex 会不断尝试以两种顺序加锁，如直到两个锁都获取到。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CPP" data-lang="CPP"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_Lock0</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_Lock1</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> _Lock_attempt_small(_Lock0<span style="color:#f92672">&amp;</span> _Lk0, _Lock1<span style="color:#f92672">&amp;</span> _Lk1) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// attempt to lock 2 locks, by first locking _Lk0, and then trying to lock _Lk1 returns whether to try again
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    _Lk0.lock();
</span></span><span style="display:flex;"><span>    _TRY_BEGIN
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">if</span> (_Lk1.try_lock()) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    _CATCH_ALL
</span></span><span style="display:flex;"><span>    _Lk0.unlock();
</span></span><span style="display:flex;"><span>    _RERAISE;
</span></span><span style="display:flex;"><span>    _CATCH_END
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    _Lk0.unlock();
</span></span><span style="display:flex;"><span>    _STD this_thread<span style="color:#f92672">::</span>yield();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// EXCEPTION MACROS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#if _HAS_EXCEPTIONS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define _TRY_BEGIN try {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define _CATCH(x) \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    }             \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    catch (x) {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define _CATCH_ALL \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    }              \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    catch (...) {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define _CATCH_END }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define _RERAISE  throw
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define _THROW(x) throw x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else </span><span style="color:#75715e">// _HAS_EXCEPTIONS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define _TRY_BEGIN \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    {              \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        if (1) {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define _CATCH(x) \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    }             \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    else if (0) {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define _CATCH_ALL \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    }              \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    else if (0) {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define _CATCH_END \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    }              \
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef _DEBUG
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define _RAISE(x) _invoke_watson(_CRT_WIDE(#x), __FUNCTIONW__, __FILEW__, __LINE__, 0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#else </span><span style="color:#75715e">// _DEBUG
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define _RAISE(x) _invoke_watson(nullptr, nullptr, nullptr, 0, 0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">// _DEBUG
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define _RERAISE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define _THROW(x) x._Raise()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#endif </span><span style="color:#75715e">// _HAS_EXCEPTIONS
</span></span></span></code></pre></div><p>再看一般情况</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CPP" data-lang="CPP"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_Lock0</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_Lock1</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_Lock2</span>, <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010">... </span><span style="color:#a6e22e">_LockN</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> _Lock_nonmember1(_Lock0<span style="color:#f92672">&amp;</span> _Lk0, _Lock1<span style="color:#f92672">&amp;</span> _Lk1, _Lock2<span style="color:#f92672">&amp;</span> _Lk2, _LockN<span style="color:#f92672">&amp;</span>... _LkN) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// lock 3 or more locks, without deadlock
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> _Hard_lock <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (_Hard_lock <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        _Hard_lock <span style="color:#f92672">=</span> _Lock_attempt(_Hard_lock, _Lk0, _Lk1, _Lk2, _LkN...);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// FUNCTION TEMPLATE lock
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010">... </span><span style="color:#a6e22e">_LockN</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> _Lock_attempt(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> _Hard_lock, _LockN<span style="color:#f92672">&amp;</span>... _LkN) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// attempt to lock 3 or more locks, starting by locking _LkN[_Hard_lock] and trying to lock the rest
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">using</span> _Indices <span style="color:#f92672">=</span> index_sequence_for<span style="color:#f92672">&lt;</span>_LockN...<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    _Lock_from_locks(_Hard_lock, _Indices{}, _LkN...);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> _Failed        <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> _Backout_start <span style="color:#f92672">=</span> _Hard_lock; <span style="color:#75715e">// that is, unlock _Hard_lock
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    _TRY_BEGIN
</span></span><span style="display:flex;"><span>    _Failed <span style="color:#f92672">=</span> _Try_lock_range(<span style="color:#ae81ff">0</span>, _Hard_lock, _LkN...);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (_Failed <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        _Backout_start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// that is, unlock [0, _Hard_lock] if the next throws
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        _Failed        <span style="color:#f92672">=</span> _Try_lock_range(_Hard_lock <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">sizeof</span>...(_LockN), _LkN...);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (_Failed <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) { <span style="color:#75715e">// we got all the locks
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    _CATCH_ALL
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_Unlock_locks</span>(_Backout_start, _Hard_lock <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, _Indices{}, _LkN...);
</span></span><span style="display:flex;"><span>    _RERAISE;
</span></span><span style="display:flex;"><span>    _CATCH_END
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// we didn&#39;t get all the locks, backout
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    _Unlock_locks(_Backout_start, _Hard_lock <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, _Indices{}, _LkN...);
</span></span><span style="display:flex;"><span>    _STD this_thread<span style="color:#f92672">::</span>yield();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> _Failed;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010">... </span><span style="color:#a6e22e">_Types</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> index_sequence_for <span style="color:#f92672">=</span> make_index_sequence<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">sizeof</span>...(_Types)<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span>size_t _Size<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> make_index_sequence <span style="color:#f92672">=</span> make_integer_sequence<span style="color:#f92672">&lt;</span>size_t, _Size<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span>size_t... _Vals<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> index_sequence <span style="color:#f92672">=</span> integer_sequence<span style="color:#f92672">&lt;</span>size_t, _Vals...<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ALIAS TEMPLATE make_integer_sequence
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_Ty</span>, _Ty _Size<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> make_integer_sequence <span style="color:#f92672">=</span> __make_integer_seq<span style="color:#f92672">&lt;</span>integer_sequence, _Ty, _Size<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// __make_integer_seq 是编译器提供的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 这里可以把 make_index_sequence 简单看成返回 index_sequence&lt;0, 1, ..., Size - 1&gt; 的函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 详细信息参考 https://en.cppreference.com/w/cpp/utility/integer_sequence 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// FUNCTION TEMPLATE _Lock_from_locks
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span>size_t... _Indices, <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010">... </span><span style="color:#a6e22e">_LockN</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> _Lock_from_locks(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> _Target, index_sequence<span style="color:#f92672">&lt;</span>_Indices...<span style="color:#f92672">&gt;</span>, _LockN<span style="color:#f92672">&amp;</span>... _LkN) { <span style="color:#75715e">// lock _LkN[_Target]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> _Ignored[] <span style="color:#f92672">=</span> {((<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(_Indices) <span style="color:#f92672">==</span> _Target <span style="color:#f92672">?</span> (<span style="color:#66d9ef">void</span>) _LkN.lock() <span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span>()), <span style="color:#ae81ff">0</span>)...};
</span></span><span style="display:flex;"><span>    (<span style="color:#66d9ef">void</span>) _Ignored;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// FUNCTION TEMPLATE try_lock
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010">... </span><span style="color:#a6e22e">_LockN</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> _Try_lock_range(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> _First, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> _Last, _LockN<span style="color:#f92672">&amp;</span>... _LkN) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">using</span> _Indices <span style="color:#f92672">=</span> index_sequence_for<span style="color:#f92672">&lt;</span>_LockN...<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> _Next      <span style="color:#f92672">=</span> _First;
</span></span><span style="display:flex;"><span>    _TRY_BEGIN
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (; _Next <span style="color:#f92672">!=</span> _Last; <span style="color:#f92672">++</span>_Next) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>_Try_lock_from_locks(_Next, _Indices{}, _LkN...)) { <span style="color:#75715e">// try_lock failed, backout
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            _Unlock_locks(_First, _Next, _Indices{}, _LkN...);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> _Next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    _CATCH_ALL
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_Unlock_locks</span>(_First, _Next, _Indices{}, _LkN...);
</span></span><span style="display:flex;"><span>    _RERAISE;
</span></span><span style="display:flex;"><span>    _CATCH_END
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// FUNCTION TEMPLATE _Try_lock_from_locks
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span>size_t... _Indices, <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010">... </span><span style="color:#a6e22e">_LockN</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> _Try_lock_from_locks(
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> _Target, index_sequence<span style="color:#f92672">&lt;</span>_Indices...<span style="color:#f92672">&gt;</span>, _LockN<span style="color:#f92672">&amp;</span>... _LkN) { <span style="color:#75715e">// try to lock _LkN[_Target]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> _Result{};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> _Ignored[] <span style="color:#f92672">=</span> {((<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(_Indices) <span style="color:#f92672">==</span> _Target <span style="color:#f92672">?</span> (<span style="color:#66d9ef">void</span>) (_Result <span style="color:#f92672">=</span> _LkN.try_lock()) <span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span>()), <span style="color:#ae81ff">0</span>)...};
</span></span><span style="display:flex;"><span>    (<span style="color:#66d9ef">void</span>) _Ignored;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> _Result;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// FUNCTION TEMPLATE _Unlock_locks
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span>size_t... _Indices, <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010">... </span><span style="color:#a6e22e">_LockN</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> _Unlock_locks(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> _First, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> _Last, index_sequence<span style="color:#f92672">&lt;</span>_Indices...<span style="color:#f92672">&gt;</span>, _LockN<span style="color:#f92672">&amp;</span>... _LkN) <span style="color:#66d9ef">noexcept</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* terminates */</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// unlock locks in _LkN[_First, _Last)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> _Ignored[] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>        ((_First <span style="color:#f92672">&lt;=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(_Indices) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(_Indices) <span style="color:#f92672">&lt;</span> _Last <span style="color:#f92672">?</span> (<span style="color:#66d9ef">void</span>) _LkN.unlock() <span style="color:#f92672">:</span> <span style="color:#66d9ef">void</span>()),
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">0</span>)...};
</span></span><span style="display:flex;"><span>    (<span style="color:#66d9ef">void</span>) _Ignored;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这段就是先用 <code>_Lock_from_locks</code> 函数锁住序号为 _Target 的锁，之后再调用  <code>_Try_lock_range</code> 尝试获取其 <code>_Target</code> 之前的锁，如果成功继续尝试获取 <code>_Target</code> 之后的锁，如果失败则释放所有的锁，将失败的位置设置为 <code>_Target</code>。</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://localhost:1313/" >
    &copy;  My New Hugo Site 2024 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
