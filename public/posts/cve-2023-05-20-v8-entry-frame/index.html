<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>My New Hugo Site</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="v8 栈帧系列1 - EntryFrame
v8 中有多种不同的栈帧，了解这些栈帧是我们理解 v8 解释器/Builtin 代码的基础，所以我打算学习一下常用的栈帧的格式，先来最基础的 EntryFrame。
从 CPP 跳到 Javascript 的入口点是 Builtins_JSEntry 函数，这个函数是由汇编实现的，代码在 x64 架构上是在 src/builtins/x64/builtins-x64.cc:Builtins::Generate_JSEntry 函数， 这个函数序言就会在栈上构造一个 EntryFrame。
void Builtins::Generate_JSEntry(MacroAssembler* masm) {
  Generate_JSEntryVariant(masm, StackFrame::ENTRY,
                          Builtins::kJSEntryTrampoline);
}

// Called with the native C calling convention. The corresponding function
// signature is either:
//   using JSEntryFunction = GeneratedCode&lt;Address(
//       Address root_register_value, Address new_target, Address target,
//       Address receiver, intptr_t argc, Address** argv)&gt;;
// or
//   using JSEntryFunction = GeneratedCode&lt;Address(
//       Address root_register_value, MicrotaskQueue* microtask_queue)&gt;;
void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
                             Builtins::Name entry_trampoline) {
  Label invoke, handler_entry, exit;
  Label not_outermost_js, not_outermost_js_2;

  {  // NOLINT. Scope block confuses linter.
    NoRootArrayScope uninitialized_root_register(masm);
    // Set up frame.
    __ pushq(rbp);
    __ movq(rbp, rsp);

    // Push the stack frame type.
    __ Push(Immediate(StackFrame::TypeToMarker(type)));
    // Reserve a slot for the context. It is filled after the root register has
    // been set up.
    __ AllocateStackSpace(kSystemPointerSize);
    // Save callee-saved registers (X64/X32/Win64 calling conventions).
    __ pushq(r12);
    __ pushq(r13);
    __ pushq(r14);
    __ pushq(r15);
#ifdef _WIN64
    __ pushq(rdi);  // Only callee save in Win64 ABI, argument in AMD64 ABI.
    __ pushq(rsi);  // Only callee save in Win64 ABI, argument in AMD64 ABI.
#endif
    __ pushq(rbx);

#ifdef _WIN64
    // On Win64 XMM6-XMM15 are callee-save.
    __ AllocateStackSpace(EntryFrameConstants::kXMMRegistersBlockSize);
    __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 0), xmm6);
    __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 1), xmm7);
    __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 2), xmm8);
    __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 3), xmm9);
    __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 4), xmm10);
    __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 5), xmm11);
    __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 6), xmm12);
    __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 7), xmm13);
    __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 8), xmm14);
    __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 9), xmm15);
    STATIC_ASSERT(EntryFrameConstants::kCalleeSaveXMMRegisters == 10);
    STATIC_ASSERT(EntryFrameConstants::kXMMRegistersBlockSize ==
                  EntryFrameConstants::kXMMRegisterSize *
                      EntryFrameConstants::kCalleeSaveXMMRegisters);
#endif

    // Initialize the root register.
    // C calling convention. The first argument is passed in arg_reg_1.
    __ movq(kRootRegister, arg_reg_1);
  }

  // Save copies of the top frame descriptor on the stack.
  ExternalReference c_entry_fp = ExternalReference::Create(
      IsolateAddressId::kCEntryFPAddress, masm-&gt;isolate());
  {
    Operand c_entry_fp_operand = masm-&gt;ExternalReferenceAsOperand(c_entry_fp);
    __ Push(c_entry_fp_operand);
  }

  // Store the context address in the previously-reserved slot.
  ExternalReference context_address = ExternalReference::Create(
      IsolateAddressId::kContextAddress, masm-&gt;isolate());
  __ Load(kScratchRegister, context_address);
  static constexpr int kOffsetToContextSlot = -2 * kSystemPointerSize;
  __ movq(Operand(rbp, kOffsetToContextSlot), kScratchRegister);

  // If this is the outermost JS call, set js_entry_sp value.
  ExternalReference js_entry_sp = ExternalReference::Create(
      IsolateAddressId::kJSEntrySPAddress, masm-&gt;isolate());
  __ Load(rax, js_entry_sp);
  __ testq(rax, rax);
  __ j(not_zero, &amp;not_outermost_js);
  __ Push(Immediate(StackFrame::OUTERMOST_JSENTRY_FRAME));
  __ movq(rax, rbp);
  __ Store(js_entry_sp, rax);
  Label cont;
  __ jmp(&amp;cont);
  __ bind(&amp;not_outermost_js);
  __ Push(Immediate(StackFrame::INNER_JSENTRY_FRAME));
  __ bind(&amp;cont);

  // Jump to a faked try block that does the invoke, with a faked catch
  // block that sets the pending exception.
  __ jmp(&amp;invoke);
  __ bind(&amp;handler_entry);

  // Store the current pc as the handler offset. It&#39;s used later to create the
  // handler table.
  masm-&gt;isolate()-&gt;builtins()-&gt;SetJSEntryHandlerOffset(handler_entry.pos());

  // Caught exception: Store result (exception) in the pending exception
  // field in the JSEnv and return a failure sentinel.
  ExternalReference pending_exception = ExternalReference::Create(
      IsolateAddressId::kPendingExceptionAddress, masm-&gt;isolate());
  __ Store(pending_exception, rax);
  __ LoadRoot(rax, RootIndex::kException);
  __ jmp(&amp;exit);

  // Invoke: Link this frame into the handler chain.
  __ bind(&amp;invoke);
  __ PushStackHandler();

  // Invoke the function by calling through JS entry trampoline builtin and
  // pop the faked function when we return.
  Handle&lt;Code&gt; trampoline_code =
      masm-&gt;isolate()-&gt;builtins()-&gt;builtin_handle(entry_trampoline);
  __ Call(trampoline_code, RelocInfo::CODE_TARGET);

  // Unlink this frame from the handler chain.
  __ PopStackHandler();

  __ bind(&amp;exit);
  // Check if the current stack frame is marked as the outermost JS frame.
  __ Pop(rbx);
  __ cmpq(rbx, Immediate(StackFrame::OUTERMOST_JSENTRY_FRAME));
  __ j(not_equal, &amp;not_outermost_js_2);
  __ Move(kScratchRegister, js_entry_sp);
  __ movq(Operand(kScratchRegister, 0), Immediate(0));
  __ bind(&amp;not_outermost_js_2);

  // Restore the top frame descriptor from the stack.
  {
    Operand c_entry_fp_operand = masm-&gt;ExternalReferenceAsOperand(c_entry_fp);
    __ Pop(c_entry_fp_operand);
  }

  // Restore callee-saved registers (X64 conventions).
#ifdef _WIN64
  // On Win64 XMM6-XMM15 are callee-save
  __ movdqu(xmm6, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 0));
  __ movdqu(xmm7, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 1));
  __ movdqu(xmm8, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 2));
  __ movdqu(xmm9, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 3));
  __ movdqu(xmm10, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 4));
  __ movdqu(xmm11, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 5));
  __ movdqu(xmm12, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 6));
  __ movdqu(xmm13, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 7));
  __ movdqu(xmm14, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 8));
  __ movdqu(xmm15, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 9));
  __ addq(rsp, Immediate(EntryFrameConstants::kXMMRegistersBlockSize));
#endif

  __ popq(rbx);
#ifdef _WIN64
  // Callee save on in Win64 ABI, arguments/volatile in AMD64 ABI.
  __ popq(rsi);
  __ popq(rdi);
#endif
  __ popq(r15);
  __ popq(r14);
  __ popq(r13);
  __ popq(r12);
  __ addq(rsp, Immediate(2 * kSystemPointerSize));  // remove markers

  // Restore frame pointer and return.
  __ popq(rbp);
  __ ret(0);
}
EntryFrame 的作用主要是保存 CPP 调用的现场，以便在 Javascript 执行完毕后返回到 上一层的 CPP 的代码中继续执行，保存的内容如下：">
    <meta name="generator" content="Hugo 0.139.2">
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    

    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/posts/cve-2023-05-20-v8-entry-frame/">
    

    <meta property="og:url" content="http://localhost:1313/posts/cve-2023-05-20-v8-entry-frame/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="My New Hugo Site">
  <meta property="og:description" content="v8 栈帧系列1 - EntryFrame v8 中有多种不同的栈帧，了解这些栈帧是我们理解 v8 解释器/Builtin 代码的基础，所以我打算学习一下常用的栈帧的格式，先来最基础的 EntryFrame。
从 CPP 跳到 Javascript 的入口点是 Builtins_JSEntry 函数，这个函数是由汇编实现的，代码在 x64 架构上是在 src/builtins/x64/builtins-x64.cc:Builtins::Generate_JSEntry 函数， 这个函数序言就会在栈上构造一个 EntryFrame。
void Builtins::Generate_JSEntry(MacroAssembler* masm) { Generate_JSEntryVariant(masm, StackFrame::ENTRY, Builtins::kJSEntryTrampoline); } // Called with the native C calling convention. The corresponding function // signature is either: // using JSEntryFunction = GeneratedCode&lt;Address( // Address root_register_value, Address new_target, Address target, // Address receiver, intptr_t argc, Address** argv)&gt;; // or // using JSEntryFunction = GeneratedCode&lt;Address( // Address root_register_value, MicrotaskQueue* microtask_queue)&gt;; void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type, Builtins::Name entry_trampoline) { Label invoke, handler_entry, exit; Label not_outermost_js, not_outermost_js_2; { // NOLINT. Scope block confuses linter. NoRootArrayScope uninitialized_root_register(masm); // Set up frame. __ pushq(rbp); __ movq(rbp, rsp); // Push the stack frame type. __ Push(Immediate(StackFrame::TypeToMarker(type))); // Reserve a slot for the context. It is filled after the root register has // been set up. __ AllocateStackSpace(kSystemPointerSize); // Save callee-saved registers (X64/X32/Win64 calling conventions). __ pushq(r12); __ pushq(r13); __ pushq(r14); __ pushq(r15); #ifdef _WIN64 __ pushq(rdi); // Only callee save in Win64 ABI, argument in AMD64 ABI. __ pushq(rsi); // Only callee save in Win64 ABI, argument in AMD64 ABI. #endif __ pushq(rbx); #ifdef _WIN64 // On Win64 XMM6-XMM15 are callee-save. __ AllocateStackSpace(EntryFrameConstants::kXMMRegistersBlockSize); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 0), xmm6); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 1), xmm7); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 2), xmm8); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 3), xmm9); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 4), xmm10); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 5), xmm11); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 6), xmm12); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 7), xmm13); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 8), xmm14); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 9), xmm15); STATIC_ASSERT(EntryFrameConstants::kCalleeSaveXMMRegisters == 10); STATIC_ASSERT(EntryFrameConstants::kXMMRegistersBlockSize == EntryFrameConstants::kXMMRegisterSize * EntryFrameConstants::kCalleeSaveXMMRegisters); #endif // Initialize the root register. // C calling convention. The first argument is passed in arg_reg_1. __ movq(kRootRegister, arg_reg_1); } // Save copies of the top frame descriptor on the stack. ExternalReference c_entry_fp = ExternalReference::Create( IsolateAddressId::kCEntryFPAddress, masm-&gt;isolate()); { Operand c_entry_fp_operand = masm-&gt;ExternalReferenceAsOperand(c_entry_fp); __ Push(c_entry_fp_operand); } // Store the context address in the previously-reserved slot. ExternalReference context_address = ExternalReference::Create( IsolateAddressId::kContextAddress, masm-&gt;isolate()); __ Load(kScratchRegister, context_address); static constexpr int kOffsetToContextSlot = -2 * kSystemPointerSize; __ movq(Operand(rbp, kOffsetToContextSlot), kScratchRegister); // If this is the outermost JS call, set js_entry_sp value. ExternalReference js_entry_sp = ExternalReference::Create( IsolateAddressId::kJSEntrySPAddress, masm-&gt;isolate()); __ Load(rax, js_entry_sp); __ testq(rax, rax); __ j(not_zero, &amp;not_outermost_js); __ Push(Immediate(StackFrame::OUTERMOST_JSENTRY_FRAME)); __ movq(rax, rbp); __ Store(js_entry_sp, rax); Label cont; __ jmp(&amp;cont); __ bind(&amp;not_outermost_js); __ Push(Immediate(StackFrame::INNER_JSENTRY_FRAME)); __ bind(&amp;cont); // Jump to a faked try block that does the invoke, with a faked catch // block that sets the pending exception. __ jmp(&amp;invoke); __ bind(&amp;handler_entry); // Store the current pc as the handler offset. It&#39;s used later to create the // handler table. masm-&gt;isolate()-&gt;builtins()-&gt;SetJSEntryHandlerOffset(handler_entry.pos()); // Caught exception: Store result (exception) in the pending exception // field in the JSEnv and return a failure sentinel. ExternalReference pending_exception = ExternalReference::Create( IsolateAddressId::kPendingExceptionAddress, masm-&gt;isolate()); __ Store(pending_exception, rax); __ LoadRoot(rax, RootIndex::kException); __ jmp(&amp;exit); // Invoke: Link this frame into the handler chain. __ bind(&amp;invoke); __ PushStackHandler(); // Invoke the function by calling through JS entry trampoline builtin and // pop the faked function when we return. Handle&lt;Code&gt; trampoline_code = masm-&gt;isolate()-&gt;builtins()-&gt;builtin_handle(entry_trampoline); __ Call(trampoline_code, RelocInfo::CODE_TARGET); // Unlink this frame from the handler chain. __ PopStackHandler(); __ bind(&amp;exit); // Check if the current stack frame is marked as the outermost JS frame. __ Pop(rbx); __ cmpq(rbx, Immediate(StackFrame::OUTERMOST_JSENTRY_FRAME)); __ j(not_equal, &amp;not_outermost_js_2); __ Move(kScratchRegister, js_entry_sp); __ movq(Operand(kScratchRegister, 0), Immediate(0)); __ bind(&amp;not_outermost_js_2); // Restore the top frame descriptor from the stack. { Operand c_entry_fp_operand = masm-&gt;ExternalReferenceAsOperand(c_entry_fp); __ Pop(c_entry_fp_operand); } // Restore callee-saved registers (X64 conventions). #ifdef _WIN64 // On Win64 XMM6-XMM15 are callee-save __ movdqu(xmm6, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 0)); __ movdqu(xmm7, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 1)); __ movdqu(xmm8, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 2)); __ movdqu(xmm9, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 3)); __ movdqu(xmm10, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 4)); __ movdqu(xmm11, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 5)); __ movdqu(xmm12, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 6)); __ movdqu(xmm13, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 7)); __ movdqu(xmm14, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 8)); __ movdqu(xmm15, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 9)); __ addq(rsp, Immediate(EntryFrameConstants::kXMMRegistersBlockSize)); #endif __ popq(rbx); #ifdef _WIN64 // Callee save on in Win64 ABI, arguments/volatile in AMD64 ABI. __ popq(rsi); __ popq(rdi); #endif __ popq(r15); __ popq(r14); __ popq(r13); __ popq(r12); __ addq(rsp, Immediate(2 * kSystemPointerSize)); // remove markers // Restore frame pointer and return. __ popq(rbp); __ ret(0); } EntryFrame 的作用主要是保存 CPP 调用的现场，以便在 Javascript 执行完毕后返回到 上一层的 CPP 的代码中继续执行，保存的内容如下：">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">

  <meta itemprop="name" content="My New Hugo Site">
  <meta itemprop="description" content="v8 栈帧系列1 - EntryFrame v8 中有多种不同的栈帧，了解这些栈帧是我们理解 v8 解释器/Builtin 代码的基础，所以我打算学习一下常用的栈帧的格式，先来最基础的 EntryFrame。
从 CPP 跳到 Javascript 的入口点是 Builtins_JSEntry 函数，这个函数是由汇编实现的，代码在 x64 架构上是在 src/builtins/x64/builtins-x64.cc:Builtins::Generate_JSEntry 函数， 这个函数序言就会在栈上构造一个 EntryFrame。
void Builtins::Generate_JSEntry(MacroAssembler* masm) { Generate_JSEntryVariant(masm, StackFrame::ENTRY, Builtins::kJSEntryTrampoline); } // Called with the native C calling convention. The corresponding function // signature is either: // using JSEntryFunction = GeneratedCode&lt;Address( // Address root_register_value, Address new_target, Address target, // Address receiver, intptr_t argc, Address** argv)&gt;; // or // using JSEntryFunction = GeneratedCode&lt;Address( // Address root_register_value, MicrotaskQueue* microtask_queue)&gt;; void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type, Builtins::Name entry_trampoline) { Label invoke, handler_entry, exit; Label not_outermost_js, not_outermost_js_2; { // NOLINT. Scope block confuses linter. NoRootArrayScope uninitialized_root_register(masm); // Set up frame. __ pushq(rbp); __ movq(rbp, rsp); // Push the stack frame type. __ Push(Immediate(StackFrame::TypeToMarker(type))); // Reserve a slot for the context. It is filled after the root register has // been set up. __ AllocateStackSpace(kSystemPointerSize); // Save callee-saved registers (X64/X32/Win64 calling conventions). __ pushq(r12); __ pushq(r13); __ pushq(r14); __ pushq(r15); #ifdef _WIN64 __ pushq(rdi); // Only callee save in Win64 ABI, argument in AMD64 ABI. __ pushq(rsi); // Only callee save in Win64 ABI, argument in AMD64 ABI. #endif __ pushq(rbx); #ifdef _WIN64 // On Win64 XMM6-XMM15 are callee-save. __ AllocateStackSpace(EntryFrameConstants::kXMMRegistersBlockSize); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 0), xmm6); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 1), xmm7); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 2), xmm8); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 3), xmm9); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 4), xmm10); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 5), xmm11); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 6), xmm12); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 7), xmm13); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 8), xmm14); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 9), xmm15); STATIC_ASSERT(EntryFrameConstants::kCalleeSaveXMMRegisters == 10); STATIC_ASSERT(EntryFrameConstants::kXMMRegistersBlockSize == EntryFrameConstants::kXMMRegisterSize * EntryFrameConstants::kCalleeSaveXMMRegisters); #endif // Initialize the root register. // C calling convention. The first argument is passed in arg_reg_1. __ movq(kRootRegister, arg_reg_1); } // Save copies of the top frame descriptor on the stack. ExternalReference c_entry_fp = ExternalReference::Create( IsolateAddressId::kCEntryFPAddress, masm-&gt;isolate()); { Operand c_entry_fp_operand = masm-&gt;ExternalReferenceAsOperand(c_entry_fp); __ Push(c_entry_fp_operand); } // Store the context address in the previously-reserved slot. ExternalReference context_address = ExternalReference::Create( IsolateAddressId::kContextAddress, masm-&gt;isolate()); __ Load(kScratchRegister, context_address); static constexpr int kOffsetToContextSlot = -2 * kSystemPointerSize; __ movq(Operand(rbp, kOffsetToContextSlot), kScratchRegister); // If this is the outermost JS call, set js_entry_sp value. ExternalReference js_entry_sp = ExternalReference::Create( IsolateAddressId::kJSEntrySPAddress, masm-&gt;isolate()); __ Load(rax, js_entry_sp); __ testq(rax, rax); __ j(not_zero, &amp;not_outermost_js); __ Push(Immediate(StackFrame::OUTERMOST_JSENTRY_FRAME)); __ movq(rax, rbp); __ Store(js_entry_sp, rax); Label cont; __ jmp(&amp;cont); __ bind(&amp;not_outermost_js); __ Push(Immediate(StackFrame::INNER_JSENTRY_FRAME)); __ bind(&amp;cont); // Jump to a faked try block that does the invoke, with a faked catch // block that sets the pending exception. __ jmp(&amp;invoke); __ bind(&amp;handler_entry); // Store the current pc as the handler offset. It&#39;s used later to create the // handler table. masm-&gt;isolate()-&gt;builtins()-&gt;SetJSEntryHandlerOffset(handler_entry.pos()); // Caught exception: Store result (exception) in the pending exception // field in the JSEnv and return a failure sentinel. ExternalReference pending_exception = ExternalReference::Create( IsolateAddressId::kPendingExceptionAddress, masm-&gt;isolate()); __ Store(pending_exception, rax); __ LoadRoot(rax, RootIndex::kException); __ jmp(&amp;exit); // Invoke: Link this frame into the handler chain. __ bind(&amp;invoke); __ PushStackHandler(); // Invoke the function by calling through JS entry trampoline builtin and // pop the faked function when we return. Handle&lt;Code&gt; trampoline_code = masm-&gt;isolate()-&gt;builtins()-&gt;builtin_handle(entry_trampoline); __ Call(trampoline_code, RelocInfo::CODE_TARGET); // Unlink this frame from the handler chain. __ PopStackHandler(); __ bind(&amp;exit); // Check if the current stack frame is marked as the outermost JS frame. __ Pop(rbx); __ cmpq(rbx, Immediate(StackFrame::OUTERMOST_JSENTRY_FRAME)); __ j(not_equal, &amp;not_outermost_js_2); __ Move(kScratchRegister, js_entry_sp); __ movq(Operand(kScratchRegister, 0), Immediate(0)); __ bind(&amp;not_outermost_js_2); // Restore the top frame descriptor from the stack. { Operand c_entry_fp_operand = masm-&gt;ExternalReferenceAsOperand(c_entry_fp); __ Pop(c_entry_fp_operand); } // Restore callee-saved registers (X64 conventions). #ifdef _WIN64 // On Win64 XMM6-XMM15 are callee-save __ movdqu(xmm6, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 0)); __ movdqu(xmm7, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 1)); __ movdqu(xmm8, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 2)); __ movdqu(xmm9, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 3)); __ movdqu(xmm10, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 4)); __ movdqu(xmm11, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 5)); __ movdqu(xmm12, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 6)); __ movdqu(xmm13, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 7)); __ movdqu(xmm14, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 8)); __ movdqu(xmm15, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 9)); __ addq(rsp, Immediate(EntryFrameConstants::kXMMRegistersBlockSize)); #endif __ popq(rbx); #ifdef _WIN64 // Callee save on in Win64 ABI, arguments/volatile in AMD64 ABI. __ popq(rsi); __ popq(rdi); #endif __ popq(r15); __ popq(r14); __ popq(r13); __ popq(r12); __ addq(rsp, Immediate(2 * kSystemPointerSize)); // remove markers // Restore frame pointer and return. __ popq(rbp); __ ret(0); } EntryFrame 的作用主要是保存 CPP 调用的现场，以便在 Javascript 执行完毕后返回到 上一层的 CPP 的代码中继续执行，保存的内容如下：">
  <meta itemprop="wordCount" content="3723">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="My New Hugo Site">
  <meta name="twitter:description" content="v8 栈帧系列1 - EntryFrame v8 中有多种不同的栈帧，了解这些栈帧是我们理解 v8 解释器/Builtin 代码的基础，所以我打算学习一下常用的栈帧的格式，先来最基础的 EntryFrame。
从 CPP 跳到 Javascript 的入口点是 Builtins_JSEntry 函数，这个函数是由汇编实现的，代码在 x64 架构上是在 src/builtins/x64/builtins-x64.cc:Builtins::Generate_JSEntry 函数， 这个函数序言就会在栈上构造一个 EntryFrame。
void Builtins::Generate_JSEntry(MacroAssembler* masm) { Generate_JSEntryVariant(masm, StackFrame::ENTRY, Builtins::kJSEntryTrampoline); } // Called with the native C calling convention. The corresponding function // signature is either: // using JSEntryFunction = GeneratedCode&lt;Address( // Address root_register_value, Address new_target, Address target, // Address receiver, intptr_t argc, Address** argv)&gt;; // or // using JSEntryFunction = GeneratedCode&lt;Address( // Address root_register_value, MicrotaskQueue* microtask_queue)&gt;; void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type, Builtins::Name entry_trampoline) { Label invoke, handler_entry, exit; Label not_outermost_js, not_outermost_js_2; { // NOLINT. Scope block confuses linter. NoRootArrayScope uninitialized_root_register(masm); // Set up frame. __ pushq(rbp); __ movq(rbp, rsp); // Push the stack frame type. __ Push(Immediate(StackFrame::TypeToMarker(type))); // Reserve a slot for the context. It is filled after the root register has // been set up. __ AllocateStackSpace(kSystemPointerSize); // Save callee-saved registers (X64/X32/Win64 calling conventions). __ pushq(r12); __ pushq(r13); __ pushq(r14); __ pushq(r15); #ifdef _WIN64 __ pushq(rdi); // Only callee save in Win64 ABI, argument in AMD64 ABI. __ pushq(rsi); // Only callee save in Win64 ABI, argument in AMD64 ABI. #endif __ pushq(rbx); #ifdef _WIN64 // On Win64 XMM6-XMM15 are callee-save. __ AllocateStackSpace(EntryFrameConstants::kXMMRegistersBlockSize); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 0), xmm6); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 1), xmm7); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 2), xmm8); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 3), xmm9); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 4), xmm10); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 5), xmm11); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 6), xmm12); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 7), xmm13); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 8), xmm14); __ movdqu(Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 9), xmm15); STATIC_ASSERT(EntryFrameConstants::kCalleeSaveXMMRegisters == 10); STATIC_ASSERT(EntryFrameConstants::kXMMRegistersBlockSize == EntryFrameConstants::kXMMRegisterSize * EntryFrameConstants::kCalleeSaveXMMRegisters); #endif // Initialize the root register. // C calling convention. The first argument is passed in arg_reg_1. __ movq(kRootRegister, arg_reg_1); } // Save copies of the top frame descriptor on the stack. ExternalReference c_entry_fp = ExternalReference::Create( IsolateAddressId::kCEntryFPAddress, masm-&gt;isolate()); { Operand c_entry_fp_operand = masm-&gt;ExternalReferenceAsOperand(c_entry_fp); __ Push(c_entry_fp_operand); } // Store the context address in the previously-reserved slot. ExternalReference context_address = ExternalReference::Create( IsolateAddressId::kContextAddress, masm-&gt;isolate()); __ Load(kScratchRegister, context_address); static constexpr int kOffsetToContextSlot = -2 * kSystemPointerSize; __ movq(Operand(rbp, kOffsetToContextSlot), kScratchRegister); // If this is the outermost JS call, set js_entry_sp value. ExternalReference js_entry_sp = ExternalReference::Create( IsolateAddressId::kJSEntrySPAddress, masm-&gt;isolate()); __ Load(rax, js_entry_sp); __ testq(rax, rax); __ j(not_zero, &amp;not_outermost_js); __ Push(Immediate(StackFrame::OUTERMOST_JSENTRY_FRAME)); __ movq(rax, rbp); __ Store(js_entry_sp, rax); Label cont; __ jmp(&amp;cont); __ bind(&amp;not_outermost_js); __ Push(Immediate(StackFrame::INNER_JSENTRY_FRAME)); __ bind(&amp;cont); // Jump to a faked try block that does the invoke, with a faked catch // block that sets the pending exception. __ jmp(&amp;invoke); __ bind(&amp;handler_entry); // Store the current pc as the handler offset. It&#39;s used later to create the // handler table. masm-&gt;isolate()-&gt;builtins()-&gt;SetJSEntryHandlerOffset(handler_entry.pos()); // Caught exception: Store result (exception) in the pending exception // field in the JSEnv and return a failure sentinel. ExternalReference pending_exception = ExternalReference::Create( IsolateAddressId::kPendingExceptionAddress, masm-&gt;isolate()); __ Store(pending_exception, rax); __ LoadRoot(rax, RootIndex::kException); __ jmp(&amp;exit); // Invoke: Link this frame into the handler chain. __ bind(&amp;invoke); __ PushStackHandler(); // Invoke the function by calling through JS entry trampoline builtin and // pop the faked function when we return. Handle&lt;Code&gt; trampoline_code = masm-&gt;isolate()-&gt;builtins()-&gt;builtin_handle(entry_trampoline); __ Call(trampoline_code, RelocInfo::CODE_TARGET); // Unlink this frame from the handler chain. __ PopStackHandler(); __ bind(&amp;exit); // Check if the current stack frame is marked as the outermost JS frame. __ Pop(rbx); __ cmpq(rbx, Immediate(StackFrame::OUTERMOST_JSENTRY_FRAME)); __ j(not_equal, &amp;not_outermost_js_2); __ Move(kScratchRegister, js_entry_sp); __ movq(Operand(kScratchRegister, 0), Immediate(0)); __ bind(&amp;not_outermost_js_2); // Restore the top frame descriptor from the stack. { Operand c_entry_fp_operand = masm-&gt;ExternalReferenceAsOperand(c_entry_fp); __ Pop(c_entry_fp_operand); } // Restore callee-saved registers (X64 conventions). #ifdef _WIN64 // On Win64 XMM6-XMM15 are callee-save __ movdqu(xmm6, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 0)); __ movdqu(xmm7, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 1)); __ movdqu(xmm8, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 2)); __ movdqu(xmm9, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 3)); __ movdqu(xmm10, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 4)); __ movdqu(xmm11, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 5)); __ movdqu(xmm12, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 6)); __ movdqu(xmm13, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 7)); __ movdqu(xmm14, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 8)); __ movdqu(xmm15, Operand(rsp, EntryFrameConstants::kXMMRegisterSize * 9)); __ addq(rsp, Immediate(EntryFrameConstants::kXMMRegistersBlockSize)); #endif __ popq(rbx); #ifdef _WIN64 // Callee save on in Win64 ABI, arguments/volatile in AMD64 ABI. __ popq(rsi); __ popq(rdi); #endif __ popq(r15); __ popq(r14); __ popq(r13); __ popq(r12); __ addq(rsp, Immediate(2 * kSystemPointerSize)); // remove markers // Restore frame pointer and return. __ popq(rbp); __ ret(0); } EntryFrame 的作用主要是保存 CPP 调用的现场，以便在 Javascript 执行完毕后返回到 上一层的 CPP 的代码中继续执行，保存的内容如下：">

	
  </head><body class="ma0 avenir bg-near-white development">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        My New Hugo Site
      
    </a>
    <div class="flex-l items-center">
      

      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1"></h1>
      
      
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h1 id="v8-栈帧系列1---entryframe">v8 栈帧系列1 - EntryFrame</h1>
<p>v8 中有多种不同的栈帧，了解这些栈帧是我们理解 v8 解释器/Builtin 代码的基础，所以我打算学习一下常用的栈帧的格式，先来最基础的 EntryFrame。</p>
<p>从 CPP 跳到 Javascript 的入口点是 Builtins_JSEntry 函数，这个函数是由汇编实现的，代码在 x64 架构上是在 src/builtins/x64/builtins-x64.cc:Builtins::Generate_JSEntry 函数， 这个函数序言就会在栈上构造一个 EntryFrame。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Builtins<span style="color:#f92672">::</span>Generate_JSEntry(MacroAssembler<span style="color:#f92672">*</span> masm) {
</span></span><span style="display:flex;"><span>  Generate_JSEntryVariant(masm, StackFrame<span style="color:#f92672">::</span>ENTRY,
</span></span><span style="display:flex;"><span>                          Builtins<span style="color:#f92672">::</span>kJSEntryTrampoline);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Called with the native C calling convention. The corresponding function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// signature is either:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   using JSEntryFunction = GeneratedCode&lt;Address(
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//       Address root_register_value, Address new_target, Address target,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//       Address receiver, intptr_t argc, Address** argv)&gt;;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// or
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   using JSEntryFunction = GeneratedCode&lt;Address(
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//       Address root_register_value, MicrotaskQueue* microtask_queue)&gt;;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Generate_JSEntryVariant</span>(MacroAssembler<span style="color:#f92672">*</span> masm, StackFrame<span style="color:#f92672">::</span>Type type,
</span></span><span style="display:flex;"><span>                             Builtins<span style="color:#f92672">::</span>Name entry_trampoline) {
</span></span><span style="display:flex;"><span>  Label invoke, handler_entry, exit;
</span></span><span style="display:flex;"><span>  Label not_outermost_js, not_outermost_js_2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  {  <span style="color:#75715e">// NOLINT. Scope block confuses linter.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    NoRootArrayScope uninitialized_root_register(masm);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Set up frame.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ pushq(rbp);
</span></span><span style="display:flex;"><span>    __ movq(rbp, rsp);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Push the stack frame type.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ Push(Immediate(StackFrame<span style="color:#f92672">::</span>TypeToMarker(type)));
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Reserve a slot for the context. It is filled after the root register has
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// been set up.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ AllocateStackSpace(kSystemPointerSize);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Save callee-saved registers (X64/X32/Win64 calling conventions).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ pushq(r12);
</span></span><span style="display:flex;"><span>    __ pushq(r13);
</span></span><span style="display:flex;"><span>    __ pushq(r14);
</span></span><span style="display:flex;"><span>    __ pushq(r15);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef _WIN64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ pushq(rdi);  <span style="color:#75715e">// Only callee save in Win64 ABI, argument in AMD64 ABI.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ pushq(rsi);  <span style="color:#75715e">// Only callee save in Win64 ABI, argument in AMD64 ABI.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ pushq(rbx);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef _WIN64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// On Win64 XMM6-XMM15 are callee-save.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ AllocateStackSpace(EntryFrameConstants<span style="color:#f92672">::</span>kXMMRegistersBlockSize);
</span></span><span style="display:flex;"><span>    __ movdqu(Operand(rsp, EntryFrameConstants<span style="color:#f92672">::</span>kXMMRegisterSize <span style="color:#f92672">*</span> <span style="color:#ae81ff">0</span>), xmm6);
</span></span><span style="display:flex;"><span>    __ movdqu(Operand(rsp, EntryFrameConstants<span style="color:#f92672">::</span>kXMMRegisterSize <span style="color:#f92672">*</span> <span style="color:#ae81ff">1</span>), xmm7);
</span></span><span style="display:flex;"><span>    __ movdqu(Operand(rsp, EntryFrameConstants<span style="color:#f92672">::</span>kXMMRegisterSize <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>), xmm8);
</span></span><span style="display:flex;"><span>    __ movdqu(Operand(rsp, EntryFrameConstants<span style="color:#f92672">::</span>kXMMRegisterSize <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span>), xmm9);
</span></span><span style="display:flex;"><span>    __ movdqu(Operand(rsp, EntryFrameConstants<span style="color:#f92672">::</span>kXMMRegisterSize <span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span>), xmm10);
</span></span><span style="display:flex;"><span>    __ movdqu(Operand(rsp, EntryFrameConstants<span style="color:#f92672">::</span>kXMMRegisterSize <span style="color:#f92672">*</span> <span style="color:#ae81ff">5</span>), xmm11);
</span></span><span style="display:flex;"><span>    __ movdqu(Operand(rsp, EntryFrameConstants<span style="color:#f92672">::</span>kXMMRegisterSize <span style="color:#f92672">*</span> <span style="color:#ae81ff">6</span>), xmm12);
</span></span><span style="display:flex;"><span>    __ movdqu(Operand(rsp, EntryFrameConstants<span style="color:#f92672">::</span>kXMMRegisterSize <span style="color:#f92672">*</span> <span style="color:#ae81ff">7</span>), xmm13);
</span></span><span style="display:flex;"><span>    __ movdqu(Operand(rsp, EntryFrameConstants<span style="color:#f92672">::</span>kXMMRegisterSize <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span>), xmm14);
</span></span><span style="display:flex;"><span>    __ movdqu(Operand(rsp, EntryFrameConstants<span style="color:#f92672">::</span>kXMMRegisterSize <span style="color:#f92672">*</span> <span style="color:#ae81ff">9</span>), xmm15);
</span></span><span style="display:flex;"><span>    STATIC_ASSERT(EntryFrameConstants<span style="color:#f92672">::</span>kCalleeSaveXMMRegisters <span style="color:#f92672">==</span> <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>    STATIC_ASSERT(EntryFrameConstants<span style="color:#f92672">::</span>kXMMRegistersBlockSize <span style="color:#f92672">==</span>
</span></span><span style="display:flex;"><span>                  EntryFrameConstants<span style="color:#f92672">::</span>kXMMRegisterSize <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>                      EntryFrameConstants<span style="color:#f92672">::</span>kCalleeSaveXMMRegisters);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Initialize the root register.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// C calling convention. The first argument is passed in arg_reg_1.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ movq(kRootRegister, arg_reg_1);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Save copies of the top frame descriptor on the stack.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ExternalReference c_entry_fp <span style="color:#f92672">=</span> ExternalReference<span style="color:#f92672">::</span>Create(
</span></span><span style="display:flex;"><span>      IsolateAddressId<span style="color:#f92672">::</span>kCEntryFPAddress, masm<span style="color:#f92672">-&gt;</span>isolate());
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    Operand c_entry_fp_operand <span style="color:#f92672">=</span> masm<span style="color:#f92672">-&gt;</span>ExternalReferenceAsOperand(c_entry_fp);
</span></span><span style="display:flex;"><span>    __ Push(c_entry_fp_operand);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Store the context address in the previously-reserved slot.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ExternalReference context_address <span style="color:#f92672">=</span> ExternalReference<span style="color:#f92672">::</span>Create(
</span></span><span style="display:flex;"><span>      IsolateAddressId<span style="color:#f92672">::</span>kContextAddress, masm<span style="color:#f92672">-&gt;</span>isolate());
</span></span><span style="display:flex;"><span>  __ Load(kScratchRegister, context_address);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">int</span> kOffsetToContextSlot <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> kSystemPointerSize;
</span></span><span style="display:flex;"><span>  __ movq(Operand(rbp, kOffsetToContextSlot), kScratchRegister);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// If this is the outermost JS call, set js_entry_sp value.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ExternalReference js_entry_sp <span style="color:#f92672">=</span> ExternalReference<span style="color:#f92672">::</span>Create(
</span></span><span style="display:flex;"><span>      IsolateAddressId<span style="color:#f92672">::</span>kJSEntrySPAddress, masm<span style="color:#f92672">-&gt;</span>isolate());
</span></span><span style="display:flex;"><span>  __ Load(rax, js_entry_sp);
</span></span><span style="display:flex;"><span>  __ testq(rax, rax);
</span></span><span style="display:flex;"><span>  __ j(not_zero, <span style="color:#f92672">&amp;</span>not_outermost_js);
</span></span><span style="display:flex;"><span>  __ Push(Immediate(StackFrame<span style="color:#f92672">::</span>OUTERMOST_JSENTRY_FRAME));
</span></span><span style="display:flex;"><span>  __ movq(rax, rbp);
</span></span><span style="display:flex;"><span>  __ Store(js_entry_sp, rax);
</span></span><span style="display:flex;"><span>  Label cont;
</span></span><span style="display:flex;"><span>  __ jmp(<span style="color:#f92672">&amp;</span>cont);
</span></span><span style="display:flex;"><span>  __ bind(<span style="color:#f92672">&amp;</span>not_outermost_js);
</span></span><span style="display:flex;"><span>  __ Push(Immediate(StackFrame<span style="color:#f92672">::</span>INNER_JSENTRY_FRAME));
</span></span><span style="display:flex;"><span>  __ bind(<span style="color:#f92672">&amp;</span>cont);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Jump to a faked try block that does the invoke, with a faked catch
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// block that sets the pending exception.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __ jmp(<span style="color:#f92672">&amp;</span>invoke);
</span></span><span style="display:flex;"><span>  __ bind(<span style="color:#f92672">&amp;</span>handler_entry);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Store the current pc as the handler offset. It&#39;s used later to create the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// handler table.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  masm<span style="color:#f92672">-&gt;</span>isolate()<span style="color:#f92672">-&gt;</span>builtins()<span style="color:#f92672">-&gt;</span>SetJSEntryHandlerOffset(handler_entry.pos());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Caught exception: Store result (exception) in the pending exception
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// field in the JSEnv and return a failure sentinel.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ExternalReference pending_exception <span style="color:#f92672">=</span> ExternalReference<span style="color:#f92672">::</span>Create(
</span></span><span style="display:flex;"><span>      IsolateAddressId<span style="color:#f92672">::</span>kPendingExceptionAddress, masm<span style="color:#f92672">-&gt;</span>isolate());
</span></span><span style="display:flex;"><span>  __ Store(pending_exception, rax);
</span></span><span style="display:flex;"><span>  __ LoadRoot(rax, RootIndex<span style="color:#f92672">::</span>kException);
</span></span><span style="display:flex;"><span>  __ jmp(<span style="color:#f92672">&amp;</span>exit);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Invoke: Link this frame into the handler chain.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __ bind(<span style="color:#f92672">&amp;</span>invoke);
</span></span><span style="display:flex;"><span>  __ PushStackHandler();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Invoke the function by calling through JS entry trampoline builtin and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// pop the faked function when we return.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Handle<span style="color:#f92672">&lt;</span>Code<span style="color:#f92672">&gt;</span> trampoline_code <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>      masm<span style="color:#f92672">-&gt;</span>isolate()<span style="color:#f92672">-&gt;</span>builtins()<span style="color:#f92672">-&gt;</span>builtin_handle(entry_trampoline);
</span></span><span style="display:flex;"><span>  __ Call(trampoline_code, RelocInfo<span style="color:#f92672">::</span>CODE_TARGET);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Unlink this frame from the handler chain.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __ PopStackHandler();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  __ bind(<span style="color:#f92672">&amp;</span>exit);
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Check if the current stack frame is marked as the outermost JS frame.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __ Pop(rbx);
</span></span><span style="display:flex;"><span>  __ cmpq(rbx, Immediate(StackFrame<span style="color:#f92672">::</span>OUTERMOST_JSENTRY_FRAME));
</span></span><span style="display:flex;"><span>  __ j(not_equal, <span style="color:#f92672">&amp;</span>not_outermost_js_2);
</span></span><span style="display:flex;"><span>  __ Move(kScratchRegister, js_entry_sp);
</span></span><span style="display:flex;"><span>  __ movq(Operand(kScratchRegister, <span style="color:#ae81ff">0</span>), Immediate(<span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>  __ bind(<span style="color:#f92672">&amp;</span>not_outermost_js_2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Restore the top frame descriptor from the stack.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  {
</span></span><span style="display:flex;"><span>    Operand c_entry_fp_operand <span style="color:#f92672">=</span> masm<span style="color:#f92672">-&gt;</span>ExternalReferenceAsOperand(c_entry_fp);
</span></span><span style="display:flex;"><span>    __ Pop(c_entry_fp_operand);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Restore callee-saved registers (X64 conventions).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#ifdef _WIN64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// On Win64 XMM6-XMM15 are callee-save
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __ movdqu(xmm6, Operand(rsp, EntryFrameConstants<span style="color:#f92672">::</span>kXMMRegisterSize <span style="color:#f92672">*</span> <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>  __ movdqu(xmm7, Operand(rsp, EntryFrameConstants<span style="color:#f92672">::</span>kXMMRegisterSize <span style="color:#f92672">*</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>  __ movdqu(xmm8, Operand(rsp, EntryFrameConstants<span style="color:#f92672">::</span>kXMMRegisterSize <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>));
</span></span><span style="display:flex;"><span>  __ movdqu(xmm9, Operand(rsp, EntryFrameConstants<span style="color:#f92672">::</span>kXMMRegisterSize <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span>));
</span></span><span style="display:flex;"><span>  __ movdqu(xmm10, Operand(rsp, EntryFrameConstants<span style="color:#f92672">::</span>kXMMRegisterSize <span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span>));
</span></span><span style="display:flex;"><span>  __ movdqu(xmm11, Operand(rsp, EntryFrameConstants<span style="color:#f92672">::</span>kXMMRegisterSize <span style="color:#f92672">*</span> <span style="color:#ae81ff">5</span>));
</span></span><span style="display:flex;"><span>  __ movdqu(xmm12, Operand(rsp, EntryFrameConstants<span style="color:#f92672">::</span>kXMMRegisterSize <span style="color:#f92672">*</span> <span style="color:#ae81ff">6</span>));
</span></span><span style="display:flex;"><span>  __ movdqu(xmm13, Operand(rsp, EntryFrameConstants<span style="color:#f92672">::</span>kXMMRegisterSize <span style="color:#f92672">*</span> <span style="color:#ae81ff">7</span>));
</span></span><span style="display:flex;"><span>  __ movdqu(xmm14, Operand(rsp, EntryFrameConstants<span style="color:#f92672">::</span>kXMMRegisterSize <span style="color:#f92672">*</span> <span style="color:#ae81ff">8</span>));
</span></span><span style="display:flex;"><span>  __ movdqu(xmm15, Operand(rsp, EntryFrameConstants<span style="color:#f92672">::</span>kXMMRegisterSize <span style="color:#f92672">*</span> <span style="color:#ae81ff">9</span>));
</span></span><span style="display:flex;"><span>  __ addq(rsp, Immediate(EntryFrameConstants<span style="color:#f92672">::</span>kXMMRegistersBlockSize));
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  __ popq(rbx);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef _WIN64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Callee save on in Win64 ABI, arguments/volatile in AMD64 ABI.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __ popq(rsi);
</span></span><span style="display:flex;"><span>  __ popq(rdi);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __ popq(r15);
</span></span><span style="display:flex;"><span>  __ popq(r14);
</span></span><span style="display:flex;"><span>  __ popq(r13);
</span></span><span style="display:flex;"><span>  __ popq(r12);
</span></span><span style="display:flex;"><span>  __ addq(rsp, Immediate(<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> kSystemPointerSize));  <span style="color:#75715e">// remove markers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Restore frame pointer and return.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __ popq(rbp);
</span></span><span style="display:flex;"><span>  __ ret(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>EntryFrame 的作用主要是保存 CPP 调用的现场，以便在 Javascript 执行完毕后返回到 上一层的 CPP 的代码中继续执行，保存的内容如下：</p>
<p>old HandlerAddress
0
JsFrameMarker (OUTERMOST_JSENTRY_FRAME/INNER_JSENTRY_FRAME)
old c_entry_fp
old xmm6 - xmm15
old RBX
old RSI
old RDI
old R15
old R14
old R13
old R12
Context
EntryFrame ID(2)
OLD RBP
Return Address
Reserve for arg1
Reserve for arg2
reserve for arg3
reserve for arg4
argc(CPP arg5)
argv(CPP arg6)</p>
<p>下面是 EntryFrame 的实际例子，Builtins_JSEntry 序言部分执行完成后 RBP 寄存器指向</p>
<p>![[Pasted image 20230520170535.png]]</p>
<p>对于最外层的 CPP -&gt; JS调用 Builtins_JSEntry 会把这个栈帧的 RBP 存储到 js_entry_sp 中。</p>
<p>通过 JsFrameMarker 可以看出，这里可能是第一次从 CPP 跳转到 Javscript 代码，也可能是从 Javascript 代码回调 CPP 代码以后，再跳转到 Javascript 代码，分别对应 OUTERMOST_JSENTRY_FRAME 和 INNER_JSENTRY_FRAME 两种情况。</p>
<p>构建好 EntryFrame 栈帧后，Call(trampoline_code 会调用 Builtins_JSEntryTrampoline 函数，这个函数的生成代码在 Buitlins::Generate_JSEntryTrampoline。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Builtins<span style="color:#f92672">::</span>Generate_JSEntryTrampoline(MacroAssembler<span style="color:#f92672">*</span> masm) {
</span></span><span style="display:flex;"><span>  Generate_JSEntryTrampolineHelper(masm, false);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Generate_JSEntryTrampolineHelper</span>(MacroAssembler<span style="color:#f92672">*</span> masm,
</span></span><span style="display:flex;"><span>                                             <span style="color:#66d9ef">bool</span> is_construct) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Expects six C++ function parameters.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// - Address root_register_value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// - Address new_target (tagged Object pointer)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// - Address function (tagged JSFunction pointer)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// - Address receiver (tagged Object pointer)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// - intptr_t argc
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// - Address** argv (pointer to array of tagged Object pointers)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// (see Handle::Invoke in execution.cc).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Open a C++ scope for the FrameScope.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Platform specific argument handling. After this, the stack contains
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// an internal frame and the pushed function and receiver, and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// register rax and rbx holds the argument count and argument array,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// while rdi holds the function pointer, rsi the context, and rdx the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// new.target.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// MSVC parameters in:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// rcx        : root_register_value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// rdx        : new_target
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// r8         : function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// r9         : receiver
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// [rsp+0x20] : argc
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// [rsp+0x28] : argv
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// GCC parameters in:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// rdi : root_register_value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// rsi : new_target
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// rdx : function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// rcx : receiver
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// r8  : argc
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// r9  : argv
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    __ movq(rdi, arg_reg_3);
</span></span><span style="display:flex;"><span>    __ Move(rdx, arg_reg_2);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// rdi : function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// rdx : new_target
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Clear the context before we push it when entering the internal frame.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ Set(rsi, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Enter an internal frame.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    FrameScope scope(masm, StackFrame<span style="color:#f92672">::</span>INTERNAL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Setup the context (we need to use the caller context from the isolate).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ExternalReference context_address <span style="color:#f92672">=</span> ExternalReference<span style="color:#f92672">::</span>Create(
</span></span><span style="display:flex;"><span>        IsolateAddressId<span style="color:#f92672">::</span>kContextAddress, masm<span style="color:#f92672">-&gt;</span>isolate());
</span></span><span style="display:flex;"><span>    __ movq(rsi, masm<span style="color:#f92672">-&gt;</span>ExternalReferenceAsOperand(context_address));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Push the function and the receiver onto the stack.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ Push(rdi);
</span></span><span style="display:flex;"><span>    __ Push(arg_reg_4);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef _WIN64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Load the previous frame pointer to access C arguments on stack
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ movq(kScratchRegister, Operand(rbp, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Load the number of arguments and setup pointer to the arguments.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ movq(rax, Operand(kScratchRegister, EntryFrameConstants<span style="color:#f92672">::</span>kArgcOffset));
</span></span><span style="display:flex;"><span>    __ movq(rbx, Operand(kScratchRegister, EntryFrameConstants<span style="color:#f92672">::</span>kArgvOffset));
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else   </span><span style="color:#75715e">// _WIN64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Load the number of arguments and setup pointer to the arguments.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ movq(rax, r8);
</span></span><span style="display:flex;"><span>    __ movq(rbx, r9);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif  </span><span style="color:#75715e">// _WIN64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Current stack contents:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// [rsp + 2 * kSystemPointerSize ... ] : Internal frame
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// [rsp + kSystemPointerSize]          : function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// [rsp]                         : receiver
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Current register contents:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// rax : argc
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// rbx : argv
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// rsi : context
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// rdi : function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// rdx : new.target
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Check if we have enough stack space to push all arguments.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Argument count in rax. Clobbers rcx.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Label enough_stack_space, stack_overflow;
</span></span><span style="display:flex;"><span>    Generate_StackOverflowCheck(masm, rax, rcx, <span style="color:#f92672">&amp;</span>stack_overflow, Label<span style="color:#f92672">::</span>kNear);
</span></span><span style="display:flex;"><span>    __ jmp(<span style="color:#f92672">&amp;</span>enough_stack_space, Label<span style="color:#f92672">::</span>kNear);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    __ bind(<span style="color:#f92672">&amp;</span>stack_overflow);
</span></span><span style="display:flex;"><span>    __ CallRuntime(Runtime<span style="color:#f92672">::</span>kThrowStackOverflow);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// This should be unreachable.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ int3();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    __ bind(<span style="color:#f92672">&amp;</span>enough_stack_space);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Copy arguments to the stack in a loop.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Register rbx points to array of pointers to handle locations.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Push the values of these handles.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Label loop, entry;
</span></span><span style="display:flex;"><span>    __ Set(rcx, <span style="color:#ae81ff">0</span>);  <span style="color:#75715e">// Set loop variable to 0.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ jmp(<span style="color:#f92672">&amp;</span>entry, Label<span style="color:#f92672">::</span>kNear);
</span></span><span style="display:flex;"><span>    __ bind(<span style="color:#f92672">&amp;</span>loop);
</span></span><span style="display:flex;"><span>    __ movq(kScratchRegister, Operand(rbx, rcx, times_system_pointer_size, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>    __ Push(Operand(kScratchRegister, <span style="color:#ae81ff">0</span>));  <span style="color:#75715e">// dereference handle
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ addq(rcx, Immediate(<span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>    __ bind(<span style="color:#f92672">&amp;</span>entry);
</span></span><span style="display:flex;"><span>    __ cmpq(rcx, rax);
</span></span><span style="display:flex;"><span>    __ j(not_equal, <span style="color:#f92672">&amp;</span>loop, Label<span style="color:#f92672">::</span>kNear);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Invoke the builtin code.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Handle<span style="color:#f92672">&lt;</span>Code<span style="color:#f92672">&gt;</span> builtin <span style="color:#f92672">=</span> is_construct
</span></span><span style="display:flex;"><span>                               <span style="color:#f92672">?</span> BUILTIN_CODE(masm<span style="color:#f92672">-&gt;</span>isolate(), Construct)
</span></span><span style="display:flex;"><span>                               <span style="color:#f92672">:</span> masm<span style="color:#f92672">-&gt;</span>isolate()<span style="color:#f92672">-&gt;</span>builtins()<span style="color:#f92672">-&gt;</span>Call();
</span></span><span style="display:flex;"><span>    __ Call(builtin, RelocInfo<span style="color:#f92672">::</span>CODE_TARGET);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Exit the internal frame. Notice that this also removes the empty
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// context and the function left on the stack by the code
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// invocation.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  __ ret(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个函数会创建另外一个栈帧 InternalFrame。</p>
<p>argument 0 - N  =&gt; CPP 代码传递过来的实参拷贝到栈上
receiver
function
FrameType(0x20)
old RBP</p>
<p>下面是一个实际的例子，例子中 CPP 调用没有提供参数，所以没有 argument 部分。</p>
<p>![[Pasted image 20230520195703.png]]</p>
<p>之后会调用 Builtins_Call_ReceiverIsAny，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Builtins<span style="color:#f92672">::</span>Generate_Call_ReceiverIsAny(MacroAssembler<span style="color:#f92672">*</span> masm) {
</span></span><span style="display:flex;"><span>  Generate_Call(masm, ConvertReceiverMode<span style="color:#f92672">::</span>kAny);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// static
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> Builtins<span style="color:#f92672">::</span>Generate_Call(MacroAssembler<span style="color:#f92672">*</span> masm, ConvertReceiverMode mode) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ----------- S t a t e -------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//  -- rax : the number of arguments (not including the receiver)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//  -- rdi : the target to call (can be any Object)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// -----------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  StackArgumentsAccessor <span style="color:#a6e22e">args</span>(rsp, rax);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Label non_callable;
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">JumpIfSmi</span>(rdi, <span style="color:#f92672">&amp;</span>non_callable);
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">CmpObjectType</span>(rdi, JS_FUNCTION_TYPE, rcx);
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">Jump</span>(masm<span style="color:#f92672">-&gt;</span>isolate()<span style="color:#f92672">-&gt;</span>builtins()<span style="color:#f92672">-&gt;</span>CallFunction(mode),
</span></span><span style="display:flex;"><span>          RelocInfo<span style="color:#f92672">::</span>CODE_TARGET, equal);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">CmpInstanceType</span>(rcx, JS_BOUND_FUNCTION_TYPE);
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">Jump</span>(BUILTIN_CODE(masm<span style="color:#f92672">-&gt;</span>isolate(), CallBoundFunction),
</span></span><span style="display:flex;"><span>          RelocInfo<span style="color:#f92672">::</span>CODE_TARGET, equal);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Check if target has a [[Call]] internal method.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __ <span style="color:#a6e22e">testb</span>(FieldOperand(rcx, Map<span style="color:#f92672">::</span>kBitFieldOffset),
</span></span><span style="display:flex;"><span>           Immediate(Map<span style="color:#f92672">::</span>IsCallableBit<span style="color:#f92672">::</span>kMask));
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">j</span>(zero, <span style="color:#f92672">&amp;</span>non_callable, Label<span style="color:#f92672">::</span>kNear);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Check if target is a proxy and call CallProxy external builtin
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __ <span style="color:#a6e22e">CmpInstanceType</span>(rcx, JS_PROXY_TYPE);
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">Jump</span>(BUILTIN_CODE(masm<span style="color:#f92672">-&gt;</span>isolate(), CallProxy), RelocInfo<span style="color:#f92672">::</span>CODE_TARGET,
</span></span><span style="display:flex;"><span>          equal);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 2. Call to something else, which might have a [[Call]] internal method (if
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// not we raise an exception).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Overwrite the original receiver with the (original) target.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __ <span style="color:#a6e22e">movq</span>(args.GetReceiverOperand(), rdi);
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Let the &#34;call_as_function_delegate&#34; take care of the rest.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __ <span style="color:#a6e22e">LoadNativeContextSlot</span>(Context<span style="color:#f92672">::</span>CALL_AS_FUNCTION_DELEGATE_INDEX, rdi);
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">Jump</span>(masm<span style="color:#f92672">-&gt;</span>isolate()<span style="color:#f92672">-&gt;</span>builtins()<span style="color:#f92672">-&gt;</span>CallFunction(
</span></span><span style="display:flex;"><span>              ConvertReceiverMode<span style="color:#f92672">::</span>kNotNullOrUndefined),
</span></span><span style="display:flex;"><span>          RelocInfo<span style="color:#f92672">::</span>CODE_TARGET);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 3. Call to something that is not callable.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __ <span style="color:#a6e22e">bind</span>(<span style="color:#f92672">&amp;</span>non_callable);
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    FrameScope <span style="color:#a6e22e">scope</span>(masm, StackFrame<span style="color:#f92672">::</span>INTERNAL);
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">Push</span>(rdi);
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">CallRuntime</span>(Runtime<span style="color:#f92672">::</span>kThrowCalledNonCallable);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个函数不会创建新栈帧，只是 JMP 到其他函数，一般情况下是 JMP 到 Builtins_CallFunction_ReceiverIsAny</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Builtins<span style="color:#f92672">::</span>Generate_CallFunction_ReceiverIsAny(MacroAssembler<span style="color:#f92672">*</span> masm) {
</span></span><span style="display:flex;"><span>  Generate_CallFunction(masm, ConvertReceiverMode<span style="color:#f92672">::</span>kAny);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// static
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> Builtins<span style="color:#f92672">::</span>Generate_CallFunction(MacroAssembler<span style="color:#f92672">*</span> masm,
</span></span><span style="display:flex;"><span>                                     ConvertReceiverMode mode) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ----------- S t a t e -------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//  -- rax : the number of arguments (not including the receiver)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//  -- rdi : the function to call (checked to be a JSFunction)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// -----------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  StackArgumentsAccessor <span style="color:#a6e22e">args</span>(rsp, rax);
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">AssertFunction</span>(rdi);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ES6 section 9.2.1 [[Call]] ( thisArgument, argumentsList)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Check that the function is not a &#34;classConstructor&#34;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Label class_constructor;
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">LoadTaggedPointerField</span>(
</span></span><span style="display:flex;"><span>      rdx, FieldOperand(rdi, JSFunction<span style="color:#f92672">::</span>kSharedFunctionInfoOffset));
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">testl</span>(FieldOperand(rdx, SharedFunctionInfo<span style="color:#f92672">::</span>kFlagsOffset),
</span></span><span style="display:flex;"><span>           Immediate(SharedFunctionInfo<span style="color:#f92672">::</span>IsClassConstructorBit<span style="color:#f92672">::</span>kMask));
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">j</span>(not_zero, <span style="color:#f92672">&amp;</span>class_constructor);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ----------- S t a t e -------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//  -- rax : the number of arguments (not including the receiver)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//  -- rdx : the shared function info.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//  -- rdi : the function to call (checked to be a JSFunction)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// -----------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Enter the context of the function; ToObject has to run in the function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// context, and we also need to take the global proxy from the function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// context in case of conversion.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __ <span style="color:#a6e22e">LoadTaggedPointerField</span>(rsi, FieldOperand(rdi, JSFunction<span style="color:#f92672">::</span>kContextOffset));
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// We need to convert the receiver for non-native sloppy mode functions.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Label done_convert;
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">testl</span>(FieldOperand(rdx, SharedFunctionInfo<span style="color:#f92672">::</span>kFlagsOffset),
</span></span><span style="display:flex;"><span>           Immediate(SharedFunctionInfo<span style="color:#f92672">::</span>IsNativeBit<span style="color:#f92672">::</span>kMask <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>                     SharedFunctionInfo<span style="color:#f92672">::</span>IsStrictBit<span style="color:#f92672">::</span>kMask));
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">j</span>(not_zero, <span style="color:#f92672">&amp;</span>done_convert);
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>	  ...
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">bind</span>(<span style="color:#f92672">&amp;</span>done_convert);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ----------- S t a t e -------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//  -- rax : the number of arguments (not including the receiver)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//  -- rdx : the shared function info.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//  -- rdi : the function to call (checked to be a JSFunction)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//  -- rsi : the function context.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// -----------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">movzxwq</span>(
</span></span><span style="display:flex;"><span>      rbx, FieldOperand(rdx, SharedFunctionInfo<span style="color:#f92672">::</span>kFormalParameterCountOffset));
</span></span><span style="display:flex;"><span>  ParameterCount <span style="color:#a6e22e">actual</span>(rax);
</span></span><span style="display:flex;"><span>  ParameterCount <span style="color:#a6e22e">expected</span>(rbx);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">InvokeFunctionCode</span>(rdi, no_reg, expected, actual, JUMP_FUNCTION);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// The function is a &#34;classConstructor&#34;, need to raise an exception.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __ <span style="color:#a6e22e">bind</span>(<span style="color:#f92672">&amp;</span>class_constructor);
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    FrameScope <span style="color:#a6e22e">frame</span>(masm, StackFrame<span style="color:#f92672">::</span>INTERNAL);
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">Push</span>(rdi);
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">CallRuntime</span>(Runtime<span style="color:#f92672">::</span>kThrowConstructorNonCallableError);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个一般情况下这个函数也不会构建 Frame，JMP 到 Buitins_InterpreterEntryTrampoline 函数。(如果形参和实参数量不符的话，可能会对栈帧做一些调整，我们先不考虑这种情况)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// Generate code for entering a JS function with the interpreter.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// On entry to the function the receiver and arguments have been pushed on the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// stack left to right.  The actual argument count matches the formal parameter
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// count expected by the function.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// The live registers are:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   o rdi: the JS function object being called
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   o rdx: the incoming new target or generator object
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   o rsi: our context
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   o rbp: the caller&#39;s frame pointer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//   o rsp: stack pointer (pointing to return address)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// The function builds an interpreter frame.  See InterpreterFrameConstants in
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// frames.h for its layout.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> Builtins<span style="color:#f92672">::</span>Generate_InterpreterEntryTrampoline(MacroAssembler<span style="color:#f92672">*</span> masm) {
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>  __ pushq(rbp);  <span style="color:#75715e">// Caller&#39;s frame pointer.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __ <span style="color:#a6e22e">movq</span>(rbp, rsp);
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">Push</span>(rsi);  <span style="color:#75715e">// Callee&#39;s context.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __ <span style="color:#a6e22e">Push</span>(rdi);  <span style="color:#75715e">// Callee&#39;s JS function.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Reset code age and the OSR arming. The OSR field and BytecodeAgeOffset are
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// 8-bit fields next to each other, so we could just optimize by writing a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// 16-bit. These static asserts guard our assumption is valid.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  STATIC_ASSERT(BytecodeArray<span style="color:#f92672">::</span>kBytecodeAgeOffset <span style="color:#f92672">==</span>
</span></span><span style="display:flex;"><span>                BytecodeArray<span style="color:#f92672">::</span>kOSRNestingLevelOffset <span style="color:#f92672">+</span> kCharSize);
</span></span><span style="display:flex;"><span>  STATIC_ASSERT(BytecodeArray<span style="color:#f92672">::</span>kNoAgeBytecodeAge <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">movw</span>(FieldOperand(kInterpreterBytecodeArrayRegister,
</span></span><span style="display:flex;"><span>                       BytecodeArray<span style="color:#f92672">::</span>kOSRNestingLevelOffset),
</span></span><span style="display:flex;"><span>          Immediate(<span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Load initial bytecode offset.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __ <span style="color:#a6e22e">movq</span>(kInterpreterBytecodeOffsetRegister,
</span></span><span style="display:flex;"><span>          Immediate(BytecodeArray<span style="color:#f92672">::</span>kHeaderSize <span style="color:#f92672">-</span> kHeapObjectTag));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Push bytecode array and Smi tagged bytecode offset.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __ <span style="color:#a6e22e">Push</span>(kInterpreterBytecodeArrayRegister);
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">SmiTag</span>(rcx, kInterpreterBytecodeOffsetRegister);
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">Push</span>(rcx);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Allocate the local and temporary register file on the stack.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Load frame size from the BytecodeArray object.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ <span style="color:#a6e22e">movl</span>(rcx, FieldOperand(kInterpreterBytecodeArrayRegister,
</span></span><span style="display:flex;"><span>                              BytecodeArray<span style="color:#f92672">::</span>kFrameSizeOffset));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Do a stack check to ensure we don&#39;t go over the limit.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Label ok;
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">movq</span>(rax, rsp);
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">subq</span>(rax, rcx);
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">CompareRoot</span>(rax, RootIndex<span style="color:#f92672">::</span>kRealStackLimit);
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">j</span>(above_equal, <span style="color:#f92672">&amp;</span>ok, Label<span style="color:#f92672">::</span>kNear);
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">CallRuntime</span>(Runtime<span style="color:#f92672">::</span>kThrowStackOverflow);
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">bind</span>(<span style="color:#f92672">&amp;</span>ok);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// If ok, push undefined as the initial value for all register file entries.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Label loop_header;
</span></span><span style="display:flex;"><span>    Label loop_check;
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">LoadRoot</span>(rax, RootIndex<span style="color:#f92672">::</span>kUndefinedValue);
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">j</span>(always, <span style="color:#f92672">&amp;</span>loop_check, Label<span style="color:#f92672">::</span>kNear);
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">bind</span>(<span style="color:#f92672">&amp;</span>loop_header);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO(rmcilroy): Consider doing more than one push per loop iteration.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ <span style="color:#a6e22e">Push</span>(rax);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Continue loop if not done.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ <span style="color:#a6e22e">bind</span>(<span style="color:#f92672">&amp;</span>loop_check);
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">subq</span>(rcx, Immediate(kSystemPointerSize));
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">j</span>(greater_equal, <span style="color:#f92672">&amp;</span>loop_header, Label<span style="color:#f92672">::</span>kNear);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// If the bytecode array has a valid incoming new target or generator object
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// register, initialize it with incoming value which was passed in rdx.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Label no_incoming_new_target_or_generator_register;
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">movsxlq</span>(
</span></span><span style="display:flex;"><span>      rax,
</span></span><span style="display:flex;"><span>      FieldOperand(kInterpreterBytecodeArrayRegister,
</span></span><span style="display:flex;"><span>                   BytecodeArray<span style="color:#f92672">::</span>kIncomingNewTargetOrGeneratorRegisterOffset));
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">testl</span>(rax, rax);
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">j</span>(zero, <span style="color:#f92672">&amp;</span>no_incoming_new_target_or_generator_register, Label<span style="color:#f92672">::</span>kNear);
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">movq</span>(Operand(rbp, rax, times_system_pointer_size, <span style="color:#ae81ff">0</span>), rdx);
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">bind</span>(<span style="color:#f92672">&amp;</span>no_incoming_new_target_or_generator_register);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Load accumulator with undefined.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __ <span style="color:#a6e22e">LoadRoot</span>(kInterpreterAccumulatorRegister, RootIndex<span style="color:#f92672">::</span>kUndefinedValue);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Load the dispatch table into a register and dispatch to the bytecode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// handler at the current bytecode offset.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Label do_dispatch;
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">bind</span>(<span style="color:#f92672">&amp;</span>do_dispatch);
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">Move</span>(
</span></span><span style="display:flex;"><span>      kInterpreterDispatchTableRegister,
</span></span><span style="display:flex;"><span>      ExternalReference<span style="color:#f92672">::</span>interpreter_dispatch_table_address(masm<span style="color:#f92672">-&gt;</span>isolate()));
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">movzxbq</span>(r11, Operand(kInterpreterBytecodeArrayRegister,
</span></span><span style="display:flex;"><span>                          kInterpreterBytecodeOffsetRegister, times_1, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">movq</span>(kJavaScriptCallCodeStartRegister,
</span></span><span style="display:flex;"><span>          Operand(kInterpreterDispatchTableRegister, r11,
</span></span><span style="display:flex;"><span>                  times_system_pointer_size, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">call</span>(kJavaScriptCallCodeStartRegister);
</span></span><span style="display:flex;"><span>  masm<span style="color:#f92672">-&gt;</span>isolate()<span style="color:#f92672">-&gt;</span>heap()<span style="color:#f92672">-&gt;</span>SetInterpreterEntryReturnPCOffset(masm<span style="color:#f92672">-&gt;</span>pc_offset());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Any returns to the entry trampoline are either due to the return bytecode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// or the interpreter tail calling a builtin and then a dispatch.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Get bytecode array and bytecode offset from the stack frame.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __ <span style="color:#a6e22e">movq</span>(kInterpreterBytecodeArrayRegister,
</span></span><span style="display:flex;"><span>          Operand(rbp, InterpreterFrameConstants<span style="color:#f92672">::</span>kBytecodeArrayFromFp));
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">movq</span>(kInterpreterBytecodeOffsetRegister,
</span></span><span style="display:flex;"><span>          Operand(rbp, InterpreterFrameConstants<span style="color:#f92672">::</span>kBytecodeOffsetFromFp));
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">SmiUntag</span>(kInterpreterBytecodeOffsetRegister,
</span></span><span style="display:flex;"><span>              kInterpreterBytecodeOffsetRegister);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Either return, or advance to the next bytecode and dispatch.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Label do_return;
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">movzxbq</span>(rbx, Operand(kInterpreterBytecodeArrayRegister,
</span></span><span style="display:flex;"><span>                          kInterpreterBytecodeOffsetRegister, times_1, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>  AdvanceBytecodeOffsetOrReturn(masm, kInterpreterBytecodeArrayRegister,
</span></span><span style="display:flex;"><span>                                kInterpreterBytecodeOffsetRegister, rbx, rcx,
</span></span><span style="display:flex;"><span>                                <span style="color:#f92672">&amp;</span>do_return);
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">jmp</span>(<span style="color:#f92672">&amp;</span>do_dispatch);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">bind</span>(<span style="color:#f92672">&amp;</span>do_return);
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// The return value is in rax.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  LeaveInterpreterFrame(masm, rbx, rcx);
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">ret</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">bind</span>(<span style="color:#f92672">&amp;</span>compile_lazy);
</span></span><span style="display:flex;"><span>  GenerateTailCallToReturnedCode(masm, Runtime<span style="color:#f92672">::</span>kCompileLazy);
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">int3</span>();  <span style="color:#75715e">// Should not return.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>这个函数会构造一个 InterpreterFrame：</p>
<p>register 0 - N (v8 解释器使用的寄存器，其实是在栈上存储的，寄存器的数量是编译时计算的存储在字节码信息中)
Bytecode Offset(SMI)
Bytecode Array
function
function context
old RBP</p>
<p>再往下就调用到了具体的字节码处理程序，例如 StackCheckHandler, 实现代码在 interpreter-generator.cc。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// StackCheck
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Performs a stack guard check.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>IGNITION_HANDLER(StackCheck, InterpreterAssembler) {
</span></span><span style="display:flex;"><span>  TNode<span style="color:#f92672">&lt;</span>Context<span style="color:#f92672">&gt;</span> context <span style="color:#f92672">=</span> CAST(GetContext());
</span></span><span style="display:flex;"><span>  PerformStackCheck(context);
</span></span><span style="display:flex;"><span>  Dispatch();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Turbofan 生成的代码，会创建一个 StubFrame。</p>
<p>space to save spilll registers
FrameTypeMarker (0x16 - StackFrame::STUB)
old RBP</p>
<p>有些字节码处理函数中会通过 Builtins_CEntry_Xxxxx  调用 CPP 编写的 Runtime/Builtin 函数，
例如 CallNoFeedback,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>IGNITION_HANDLER(CallNoFeedback, InterpreterJSCallAssembler) {
</span></span><span style="display:flex;"><span>  JSCallNoFeedback(ConvertReceiverMode<span style="color:#f92672">::</span>kAny);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Generates code to perform a JS call without collecting feedback.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">JSCallNoFeedback</span>(ConvertReceiverMode receiver_mode) {
</span></span><span style="display:flex;"><span>	Node<span style="color:#f92672">*</span> function <span style="color:#f92672">=</span> LoadRegisterAtOperandIndex(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>	RegListNodePair args <span style="color:#f92672">=</span> GetRegisterListAtOperandIndex(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	Node<span style="color:#f92672">*</span> context <span style="color:#f92672">=</span> GetContext();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Call the function and dispatch to the next handler.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	CallJSAndDispatch(function, context, args, receiver_mode);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> InterpreterAssembler<span style="color:#f92672">::</span>CallJSAndDispatch(
</span></span><span style="display:flex;"><span>    Node<span style="color:#f92672">*</span> function, Node<span style="color:#f92672">*</span> context, <span style="color:#66d9ef">const</span> RegListNodePair<span style="color:#f92672">&amp;</span> args,
</span></span><span style="display:flex;"><span>    ConvertReceiverMode receiver_mode) {
</span></span><span style="display:flex;"><span>  DCHECK(Bytecodes<span style="color:#f92672">::</span>MakesCallAlongCriticalPath(bytecode_));
</span></span><span style="display:flex;"><span>  DCHECK(Bytecodes<span style="color:#f92672">::</span>IsCallOrConstruct(bytecode_) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>         bytecode_ <span style="color:#f92672">==</span> Bytecode<span style="color:#f92672">::</span>kInvokeIntrinsic);
</span></span><span style="display:flex;"><span>  DCHECK_EQ(Bytecodes<span style="color:#f92672">::</span>GetReceiverMode(bytecode_), receiver_mode);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Node<span style="color:#f92672">*</span> args_count;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (receiver_mode <span style="color:#f92672">==</span> ConvertReceiverMode<span style="color:#f92672">::</span>kNullOrUndefined) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The receiver is implied, so it is not in the argument list.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    args_count <span style="color:#f92672">=</span> args.reg_count();
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Subtract the receiver from the argument count.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Node<span style="color:#f92672">*</span> receiver_count <span style="color:#f92672">=</span> Int32Constant(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    args_count <span style="color:#f92672">=</span> Int32Sub(args.reg_count(), receiver_count);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Callable callable <span style="color:#f92672">=</span> CodeFactory<span style="color:#f92672">::</span>InterpreterPushArgsThenCall(
</span></span><span style="display:flex;"><span>      isolate(), receiver_mode, InterpreterPushArgsMode<span style="color:#f92672">::</span>kOther);
</span></span><span style="display:flex;"><span>  Node<span style="color:#f92672">*</span> code_target <span style="color:#f92672">=</span> HeapConstant(callable.code());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  TailCallStubThenBytecodeDispatch(callable.descriptor(), code_target, context,
</span></span><span style="display:flex;"><span>                                   args_count, args.base_reg_location(),
</span></span><span style="display:flex;"><span>                                   function);
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// TailCallStubThenDispatch updates accumulator with result.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  accumulator_use_ <span style="color:#f92672">=</span> accumulator_use_ <span style="color:#f92672">|</span> AccumulatorUse<span style="color:#f92672">::</span>kWrite;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>结合生成的代码理解 CallNoFeedback 只是从栈上保存的解释器的寄存器中加载了函数、参数和 Context 然后尾递归(JUMP)调用 InterpreterPushArgsThenCall 函数，后者只是简单的把参数都 PUSH 到栈上，然后尾递归调用 Call_ReceiverIsAny 函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Builtins<span style="color:#f92672">::</span>Generate_InterpreterPushArgsThenCall(MacroAssembler<span style="color:#f92672">*</span> masm) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Generate_InterpreterPushArgsThenCallImpl</span>(
</span></span><span style="display:flex;"><span>      masm, ConvertReceiverMode<span style="color:#f92672">::</span>kAny, InterpreterPushArgsMode<span style="color:#f92672">::</span>kOther);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// static
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> Builtins<span style="color:#f92672">::</span>Generate_InterpreterPushArgsThenCallImpl(
</span></span><span style="display:flex;"><span>    MacroAssembler<span style="color:#f92672">*</span> masm, ConvertReceiverMode receiver_mode,
</span></span><span style="display:flex;"><span>    InterpreterPushArgsMode mode) {
</span></span><span style="display:flex;"><span>  DCHECK(mode <span style="color:#f92672">!=</span> InterpreterPushArgsMode<span style="color:#f92672">::</span>kArrayFunction);
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ----------- S t a t e -------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//  -- rax : the number of arguments (not including the receiver)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//  -- rbx : the address of the first argument to be pushed. Subsequent
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//           arguments should be consecutive above this, in the same order as
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//           they are to be pushed onto the stack.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//  -- rdi : the target to call (can be any Object).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// -----------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Label stack_overflow;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Number of values to be pushed.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __ <span style="color:#a6e22e">leal</span>(rcx, Operand(rax, <span style="color:#ae81ff">1</span>));  <span style="color:#75715e">// Add one for receiver.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Add a stack check before pushing arguments.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Generate_StackOverflowCheck(masm, rcx, rdx, <span style="color:#f92672">&amp;</span>stack_overflow);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Pop return address to allow tail-call after pushing arguments.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __ <span style="color:#a6e22e">PopReturnAddressTo</span>(kScratchRegister);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Push &#34;undefined&#34; as the receiver arg if we need to.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (receiver_mode <span style="color:#f92672">==</span> ConvertReceiverMode<span style="color:#f92672">::</span>kNullOrUndefined) {
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">PushRoot</span>(RootIndex<span style="color:#f92672">::</span>kUndefinedValue);
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">decl</span>(rcx);  <span style="color:#75715e">// Subtract one for receiver.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// rbx and rdx will be modified.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Generate_InterpreterPushArgs(masm, rcx, rbx, rdx);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (mode <span style="color:#f92672">==</span> InterpreterPushArgsMode<span style="color:#f92672">::</span>kWithFinalSpread) {
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">Pop</span>(rbx);                 <span style="color:#75715e">// Pass the spread in a register
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ <span style="color:#a6e22e">decl</span>(rax);                <span style="color:#75715e">// Subtract one for spread
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Call the target.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __ <span style="color:#a6e22e">PushReturnAddressFrom</span>(kScratchRegister);  <span style="color:#75715e">// Re-push return address.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (mode <span style="color:#f92672">==</span> InterpreterPushArgsMode<span style="color:#f92672">::</span>kWithFinalSpread) {
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">Jump</span>(BUILTIN_CODE(masm<span style="color:#f92672">-&gt;</span>isolate(), CallWithSpread),
</span></span><span style="display:flex;"><span>            RelocInfo<span style="color:#f92672">::</span>CODE_TARGET);
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">Jump</span>(masm<span style="color:#f92672">-&gt;</span>isolate()<span style="color:#f92672">-&gt;</span>builtins()<span style="color:#f92672">-&gt;</span>Call(receiver_mode),
</span></span><span style="display:flex;"><span>            RelocInfo<span style="color:#f92672">::</span>CODE_TARGET);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Throw stack overflow exception.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __ <span style="color:#a6e22e">bind</span>(<span style="color:#f92672">&amp;</span>stack_overflow);
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">TailCallRuntime</span>(Runtime<span style="color:#f92672">::</span>kThrowStackOverflow);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// This should be unreachable.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ <span style="color:#a6e22e">int3</span>();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Call_ReceiverIsAny 函数在前面已经介绍过了。</p>
<p>这里以 Builts_CEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit() 为例。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CPP" data-lang="CPP"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Builtins<span style="color:#f92672">::</span>Generate_CEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit(
</span></span><span style="display:flex;"><span>    MacroAssembler<span style="color:#f92672">*</span> masm) {
</span></span><span style="display:flex;"><span>  Generate_CEntry(masm, <span style="color:#ae81ff">1</span>, kDontSaveFPRegs, kArgvOnStack, false);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Builtins<span style="color:#f92672">::</span>Generate_CEntry(MacroAssembler<span style="color:#f92672">*</span> masm, <span style="color:#66d9ef">int</span> result_size,
</span></span><span style="display:flex;"><span>                               SaveFPRegsMode save_doubles, ArgvMode argv_mode,
</span></span><span style="display:flex;"><span>                               <span style="color:#66d9ef">bool</span> builtin_exit_frame) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// rax: number of arguments including receiver
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// rbx: pointer to C function  (C callee-saved)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// rbp: frame pointer of calling JS frame (restored after C call)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// rsp: stack pointer  (restored after C call)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// rsi: current context (restored)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// If argv_mode == kArgvInRegister:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// r15: pointer to the first argument
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef _WIN64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Windows 64-bit ABI passes arguments in rcx, rdx, r8, r9. It requires the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// stack to be aligned to 16 bytes. It only allows a single-word to be
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// returned in register rax. Larger return sizes must be written to an address
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// passed as a hidden first argument.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> Register kCCallArg0 <span style="color:#f92672">=</span> rcx;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> Register kCCallArg1 <span style="color:#f92672">=</span> rdx;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> Register kCCallArg2 <span style="color:#f92672">=</span> r8;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> Register kCCallArg3 <span style="color:#f92672">=</span> r9;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> kArgExtraStackSpace <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> kMaxRegisterResultSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#else
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// GCC / Clang passes arguments in rdi, rsi, rdx, rcx, r8, r9. Simple results
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// are returned in rax, and a struct of two pointers are returned in rax+rdx.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Larger return sizes must be written to an address passed as a hidden first
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// argument.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> Register kCCallArg0 <span style="color:#f92672">=</span> rdi;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> Register kCCallArg1 <span style="color:#f92672">=</span> rsi;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> Register kCCallArg2 <span style="color:#f92672">=</span> rdx;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> Register kCCallArg3 <span style="color:#f92672">=</span> rcx;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> kArgExtraStackSpace <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> kMaxRegisterResultSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif  </span><span style="color:#75715e">// _WIN64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Enter the exit frame that transitions from JavaScript to C++.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> arg_stack_space <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>      kArgExtraStackSpace <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>      (result_size <span style="color:#f92672">&lt;=</span> kMaxRegisterResultSize <span style="color:#f92672">?</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">:</span> result_size);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (argv_mode <span style="color:#f92672">==</span> kArgvInRegister) {
</span></span><span style="display:flex;"><span>    DCHECK(save_doubles <span style="color:#f92672">==</span> kDontSaveFPRegs);
</span></span><span style="display:flex;"><span>    DCHECK(<span style="color:#f92672">!</span>builtin_exit_frame);
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">EnterApiExitFrame</span>(arg_stack_space);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Move argc into r14 (argv is already in r15).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ <span style="color:#a6e22e">movq</span>(r14, rax);
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">EnterExitFrame</span>(
</span></span><span style="display:flex;"><span>        arg_stack_space, save_doubles <span style="color:#f92672">==</span> kSaveFPRegs,
</span></span><span style="display:flex;"><span>        builtin_exit_frame <span style="color:#f92672">?</span> StackFrame<span style="color:#f92672">::</span>BUILTIN_EXIT : StackFrame<span style="color:#f92672">::</span>EXIT);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// rbx: pointer to builtin function  (C callee-saved).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// rbp: frame pointer of exit frame  (restored after C call).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// rsp: stack pointer (restored after C call).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// r14: number of arguments including receiver (C callee-saved).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// r15: argv pointer (C callee-saved).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Check stack alignment.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (FLAG_debug_code) {
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">CheckStackAlignment</span>();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Call C function. The arguments object will be created by stubs declared by
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// DECLARE_RUNTIME_FUNCTION().
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (result_size <span style="color:#f92672">&lt;=</span> kMaxRegisterResultSize) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Pass a pointer to the Arguments object as the first argument.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Return result in single register (rax), or a register pair (rax, rdx).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ <span style="color:#a6e22e">movq</span>(kCCallArg0, r14);  <span style="color:#75715e">// argc.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ <span style="color:#a6e22e">movq</span>(kCCallArg1, r15);  <span style="color:#75715e">// argv.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ <span style="color:#a6e22e">Move</span>(kCCallArg2, ExternalReference<span style="color:#f92672">::</span>isolate_address(masm<span style="color:#f92672">-&gt;</span>isolate()));
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    DCHECK_LE(result_size, <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Pass a pointer to the result location as the first argument.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ <span style="color:#a6e22e">leaq</span>(kCCallArg0, StackSpaceOperand(kArgExtraStackSpace));
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Pass a pointer to the Arguments object as the second argument.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ <span style="color:#a6e22e">movq</span>(kCCallArg1, r14);  <span style="color:#75715e">// argc.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ <span style="color:#a6e22e">movq</span>(kCCallArg2, r15);  <span style="color:#75715e">// argv.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    __ <span style="color:#a6e22e">Move</span>(kCCallArg3, ExternalReference<span style="color:#f92672">::</span>isolate_address(masm<span style="color:#f92672">-&gt;</span>isolate()));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">call</span>(rbx);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (result_size <span style="color:#f92672">&gt;</span> kMaxRegisterResultSize) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Read result values stored on stack. Result is stored
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// above the the two Arguments object slots on Win64.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    DCHECK_LE(result_size, <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">movq</span>(kReturnRegister0, StackSpaceOperand(kArgExtraStackSpace <span style="color:#f92672">+</span> <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">movq</span>(kReturnRegister1, StackSpaceOperand(kArgExtraStackSpace <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Result is in rax or rdx:rax - do not destroy these registers!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Check result for exception sentinel.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Label exception_returned;
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">CompareRoot</span>(rax, RootIndex<span style="color:#f92672">::</span>kException);
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">j</span>(equal, <span style="color:#f92672">&amp;</span>exception_returned);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Check that there is no pending exception, otherwise we
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// should have returned the exception sentinel.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (FLAG_debug_code) {
</span></span><span style="display:flex;"><span>    Label okay;
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">LoadRoot</span>(r14, RootIndex<span style="color:#f92672">::</span>kTheHoleValue);
</span></span><span style="display:flex;"><span>    ExternalReference pending_exception_address <span style="color:#f92672">=</span> ExternalReference<span style="color:#f92672">::</span>Create(
</span></span><span style="display:flex;"><span>        IsolateAddressId<span style="color:#f92672">::</span>kPendingExceptionAddress, masm<span style="color:#f92672">-&gt;</span>isolate());
</span></span><span style="display:flex;"><span>    Operand pending_exception_operand <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>        masm<span style="color:#f92672">-&gt;</span>ExternalReferenceAsOperand(pending_exception_address);
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">cmpq</span>(r14, pending_exception_operand);
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">j</span>(equal, <span style="color:#f92672">&amp;</span>okay, Label<span style="color:#f92672">::</span>kNear);
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">int3</span>();
</span></span><span style="display:flex;"><span>    __ <span style="color:#a6e22e">bind</span>(<span style="color:#f92672">&amp;</span>okay);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Exit the JavaScript to C++ exit frame.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __ <span style="color:#a6e22e">LeaveExitFrame</span>(save_doubles <span style="color:#f92672">==</span> kSaveFPRegs, argv_mode <span style="color:#f92672">==</span> kArgvOnStack);
</span></span><span style="display:flex;"><span>  __ <span style="color:#a6e22e">ret</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Handling of exception.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __ <span style="color:#a6e22e">bind</span>(<span style="color:#f92672">&amp;</span>exception_returned);
</span></span><span style="display:flex;"><span>  ... <span style="color:#75715e">// 异常处理的代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> MacroAssembler<span style="color:#f92672">::</span>EnterExitFrame(<span style="color:#66d9ef">int</span> arg_stack_space, <span style="color:#66d9ef">bool</span> save_doubles,
</span></span><span style="display:flex;"><span>                                    StackFrame<span style="color:#f92672">::</span>Type frame_type) {
</span></span><span style="display:flex;"><span>  EnterExitFramePrologue(true, frame_type);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Set up argv in callee-saved register r15. It is reused in LeaveExitFrame,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// so it must be retained across the C-call.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> offset <span style="color:#f92672">=</span> StandardFrameConstants<span style="color:#f92672">::</span>kCallerSPOffset <span style="color:#f92672">-</span> kSystemPointerSize;
</span></span><span style="display:flex;"><span>  leaq(r15, Operand(rbp, r14, times_system_pointer_size, offset));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  EnterExitFrameEpilogue(arg_stack_space, save_doubles);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> MacroAssembler<span style="color:#f92672">::</span>EnterExitFramePrologue(<span style="color:#66d9ef">bool</span> save_rax,
</span></span><span style="display:flex;"><span>                                            StackFrame<span style="color:#f92672">::</span>Type frame_type) {
</span></span><span style="display:flex;"><span>  DCHECK(frame_type <span style="color:#f92672">==</span> StackFrame<span style="color:#f92672">::</span>EXIT <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>         frame_type <span style="color:#f92672">==</span> StackFrame<span style="color:#f92672">::</span>BUILTIN_EXIT);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Set up the frame structure on the stack.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// All constants are relative to the frame pointer of the exit frame.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  DCHECK_EQ(kFPOnStackSize <span style="color:#f92672">+</span> kPCOnStackSize,
</span></span><span style="display:flex;"><span>            ExitFrameConstants<span style="color:#f92672">::</span>kCallerSPDisplacement);
</span></span><span style="display:flex;"><span>  DCHECK_EQ(kFPOnStackSize, ExitFrameConstants<span style="color:#f92672">::</span>kCallerPCOffset);
</span></span><span style="display:flex;"><span>  DCHECK_EQ(<span style="color:#ae81ff">0</span> <span style="color:#f92672">*</span> kSystemPointerSize, ExitFrameConstants<span style="color:#f92672">::</span>kCallerFPOffset);
</span></span><span style="display:flex;"><span>  pushq(rbp);
</span></span><span style="display:flex;"><span>  movq(rbp, rsp);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Reserve room for entry stack pointer.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Push(Immediate(StackFrame<span style="color:#f92672">::</span>TypeToMarker(frame_type)));
</span></span><span style="display:flex;"><span>  DCHECK_EQ(<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> kSystemPointerSize, ExitFrameConstants<span style="color:#f92672">::</span>kSPOffset);
</span></span><span style="display:flex;"><span>  Push(Immediate(<span style="color:#ae81ff">0</span>));  <span style="color:#75715e">// Saved entry sp, patched before call.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Save the frame pointer and the context in top.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (save_rax) {
</span></span><span style="display:flex;"><span>    movq(r14, rax);  <span style="color:#75715e">// Backup rax in callee-save register.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Store(
</span></span><span style="display:flex;"><span>      ExternalReference<span style="color:#f92672">::</span>Create(IsolateAddressId<span style="color:#f92672">::</span>kCEntryFPAddress, isolate()),
</span></span><span style="display:flex;"><span>      rbp);
</span></span><span style="display:flex;"><span>  Store(ExternalReference<span style="color:#f92672">::</span>Create(IsolateAddressId<span style="color:#f92672">::</span>kContextAddress, isolate()),
</span></span><span style="display:flex;"><span>        rsi);
</span></span><span style="display:flex;"><span>  Store(
</span></span><span style="display:flex;"><span>      ExternalReference<span style="color:#f92672">::</span>Create(IsolateAddressId<span style="color:#f92672">::</span>kCFunctionAddress, isolate()),
</span></span><span style="display:flex;"><span>      rbx);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> MacroAssembler<span style="color:#f92672">::</span>EnterExitFrameEpilogue(<span style="color:#66d9ef">int</span> arg_stack_space,
</span></span><span style="display:flex;"><span>                                            <span style="color:#66d9ef">bool</span> save_doubles) {
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef _WIN64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> kShadowSpace <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>  arg_stack_space <span style="color:#f92672">+=</span> kShadowSpace;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Optionally save all XMM registers.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (save_doubles) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> space <span style="color:#f92672">=</span> XMMRegister<span style="color:#f92672">::</span>kNumRegisters <span style="color:#f92672">*</span> kDoubleSize <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>                arg_stack_space <span style="color:#f92672">*</span> kSystemPointerSize;
</span></span><span style="display:flex;"><span>    AllocateStackSpace(space);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> offset <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>ExitFrameConstants<span style="color:#f92672">::</span>kFixedFrameSizeFromFp;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> RegisterConfiguration<span style="color:#f92672">*</span> config <span style="color:#f92672">=</span> RegisterConfiguration<span style="color:#f92672">::</span>Default();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> config<span style="color:#f92672">-&gt;</span>num_allocatable_double_registers(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>      DoubleRegister reg <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>          DoubleRegister<span style="color:#f92672">::</span>from_code(config<span style="color:#f92672">-&gt;</span>GetAllocatableDoubleCode(i));
</span></span><span style="display:flex;"><span>      Movsd(Operand(rbp, offset <span style="color:#f92672">-</span> ((i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> kDoubleSize)), reg);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (arg_stack_space <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    AllocateStackSpace(arg_stack_space <span style="color:#f92672">*</span> kSystemPointerSize);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Get the required frame alignment for the OS.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> kFrameAlignment <span style="color:#f92672">=</span> base<span style="color:#f92672">::</span>OS<span style="color:#f92672">::</span>ActivationFrameAlignment();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (kFrameAlignment <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    DCHECK(base<span style="color:#f92672">::</span>bits<span style="color:#f92672">::</span>IsPowerOfTwo(kFrameAlignment));
</span></span><span style="display:flex;"><span>    DCHECK(is_int8(kFrameAlignment));
</span></span><span style="display:flex;"><span>    andq(rsp, Immediate(<span style="color:#f92672">-</span>kFrameAlignment));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Patch the saved entry sp.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  movq(Operand(rbp, ExitFrameConstants<span style="color:#f92672">::</span>kSPOffset), rsp);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>它会构建下面的栈帧</p>
<p>old RSP
FrameTypeMarker(0x6 - )
old RBP</p>
<p>并且把这个栈帧存放到 c_entry_fp 中</p>
<p>CallUndefinedReceiver</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>IGNITION_HANDLER(CallUndefinedReceiver, InterpreterJSCallAssembler) {
</span></span><span style="display:flex;"><span>  JSCall(ConvertReceiverMode<span style="color:#f92672">::</span>kNullOrUndefined);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Generates code to perform a JS call that collects type feedback.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">JSCall</span>(ConvertReceiverMode receiver_mode) {
</span></span><span style="display:flex;"><span>    Node<span style="color:#f92672">*</span> function <span style="color:#f92672">=</span> LoadRegisterAtOperandIndex(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    RegListNodePair args <span style="color:#f92672">=</span> GetRegisterListAtOperandIndex(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    Node<span style="color:#f92672">*</span> slot_id <span style="color:#f92672">=</span> BytecodeOperandIdx(<span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>    Node<span style="color:#f92672">*</span> maybe_feedback_vector <span style="color:#f92672">=</span> LoadFeedbackVector();
</span></span><span style="display:flex;"><span>    Node<span style="color:#f92672">*</span> context <span style="color:#f92672">=</span> GetContext();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Collect the {function} feedback.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    CollectCallFeedback(function, context, maybe_feedback_vector, slot_id);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Call the function and dispatch to the next handler.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    CallJSAndDispatch(function, context, args, receiver_mode);
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://localhost:1313/" >
    &copy;  My New Hugo Site 2024 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
